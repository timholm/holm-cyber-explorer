<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HOLM VAULT — Graph View</title>
<style>
:root {
  --bg: #1e1e2e;
  --bg-secondary: #181825;
  --bg-surface: #313244;
  --text: #cdd6f4;
  --text-muted: #6c7086;
  --accent: #89b4fa;
  --border: #313244;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: var(--bg);
  color: var(--text);
  font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
  overflow: hidden;
  height: 100vh;
}
canvas { display: block; }

.toolbar {
  position: fixed;
  top: 12px;
  left: 12px;
  display: flex;
  gap: 8px;
  z-index: 10;
}
.toolbar button, .toolbar a {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 14px;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
.toolbar button:hover, .toolbar a:hover { background: #45475a; }

.tooltip {
  position: fixed;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 12px;
  pointer-events: none;
  display: none;
  z-index: 20;
  max-width: 300px;
}
.tooltip .tt-id { color: var(--accent); font-weight: 700; font-size: 11px; }
.tooltip .tt-title { margin-top: 2px; }
.tooltip .tt-domain { color: var(--text-muted); font-size: 11px; margin-top: 4px; }

.legend {
  position: fixed;
  bottom: 12px;
  left: 12px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px 14px;
  font-size: 11px;
  z-index: 10;
  max-height: 50vh;
  overflow-y: auto;
}
.legend h4 { color: var(--text-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px; font-size: 10px; }
.legend-item { display: flex; align-items: center; gap: 6px; margin: 3px 0; }
.legend-dot { width: 8px; height: 8px; border-radius: 50%; }

.stats {
  position: fixed;
  top: 12px;
  right: 12px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 14px;
  font-size: 11px;
  color: var(--text-muted);
  z-index: 10;
}
.stats span { color: var(--accent); font-weight: 700; }

.loading-overlay {
  position: fixed;
  inset: 0;
  background: var(--bg);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
  font-size: 14px;
  color: var(--text-muted);
}
</style>
</head>
<body>

<div class="loading-overlay" id="loading">Loading graph data...</div>

<canvas id="canvas"></canvas>

<div class="toolbar">
  <a href="/">← Vault</a>
  <button onclick="resetView()">Reset View</button>
  <button onclick="toggleLabels()">Labels</button>
</div>

<div class="tooltip" id="tooltip">
  <div class="tt-id" id="ttId"></div>
  <div class="tt-title" id="ttTitle"></div>
  <div class="tt-domain" id="ttDomain"></div>
</div>

<div class="legend" id="legend"></div>

<div class="stats" id="stats"></div>

<script>
const DOMAIN_COLORS = {
  '1': '#89b4fa', '2': '#a6e3a1', '3': '#f38ba8', '4': '#fab387',
  '5': '#cba6f7', '6': '#94e2d5', '7': '#f9e2af', '8': '#f5c2e7',
  '9': '#89dceb', '10': '#b4befe', '11': '#74c7ec', '12': '#f38ba8',
  '13': '#a6e3a1', '14': '#fab387', '15': '#cba6f7', '16': '#94e2d5',
  '17': '#f9e2af', '18': '#f5c2e7', '19': '#89dceb', '20': '#b4befe',
  'META': '#6c7086', 'FW': '#585b70', 'HIC': '#74c7ec'
};

const DOMAIN_NAMES = {
  '1': 'Constitution', '2': 'Governance', '3': 'Security', '4': 'Infrastructure',
  '5': 'Platform', '6': 'Data', '7': 'Intelligence', '8': 'Automation',
  '9': 'Education', '10': 'User Ops', '11': 'Administration', '12': 'Disaster Recovery',
  '13': 'Evolution', '14': 'Research', '15': 'Ethics', '16': 'Federation',
  '17': 'Fed Protocol', '18': 'Data Pipeline', '19': 'Adv Automation', '20': 'Meta',
  'META': 'Meta', 'FW': 'Framework', 'HIC': 'HIC'
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let nodes = [];
let edges = [];
let nodeMap = {};
let showLabels = true;

// Camera / transform
let camX = 0, camY = 0, camScale = 1;
let dragging = false, dragNode = null;
let lastMouse = { x: 0, y: 0 };
let hoveredNode = null;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

async function loadGraph() {
  try {
    const res = await fetch('/api/graph');
    const data = await res.json();

    // Build nodes with physics
    const cx = canvas.width / 2, cy = canvas.height / 2;
    nodes = data.nodes.map((n, i) => {
      const angle = (i / data.nodes.length) * Math.PI * 2;
      const r = 200 + Math.random() * 300;
      return {
        ...n,
        x: cx + Math.cos(angle) * r,
        y: cy + Math.sin(angle) * r,
        vx: 0, vy: 0,
        radius: 4,
        color: DOMAIN_COLORS[n.domain] || '#6c7086'
      };
    });

    nodeMap = {};
    nodes.forEach(n => nodeMap[n.id] = n);

    // Only keep edges where both source and target exist
    edges = data.edges.filter(e => nodeMap[e.source] && nodeMap[e.target]);

    // Stats
    const domains = new Set(nodes.map(n => n.domain));
    document.getElementById('stats').innerHTML =
      `<span>${nodes.length}</span> nodes &middot; <span>${edges.length}</span> edges &middot; <span>${domains.size}</span> domains`;

    // Legend
    const domainCounts = {};
    nodes.forEach(n => { domainCounts[n.domain] = (domainCounts[n.domain] || 0) + 1; });
    let legendHtml = '<h4>Domains</h4>';
    Object.keys(domainCounts).sort((a,b) => {
      const na = parseInt(a), nb = parseInt(b);
      if (!isNaN(na) && !isNaN(nb)) return na - nb;
      return a.localeCompare(b);
    }).forEach(d => {
      legendHtml += `<div class="legend-item"><div class="legend-dot" style="background:${DOMAIN_COLORS[d]||'#6c7086'}"></div>${d}: ${DOMAIN_NAMES[d]||d} (${domainCounts[d]})</div>`;
    });
    document.getElementById('legend').innerHTML = legendHtml;

    document.getElementById('loading').style.display = 'none';
    simulate();
  } catch (err) {
    document.getElementById('loading').textContent = 'Failed to load graph: ' + err.message;
  }
}

// Force-directed simulation
function simulate() {
  let iterations = 0;
  const maxIterations = 300;
  const damping = 0.92;

  function step() {
    iterations++;
    const alpha = Math.max(0.01, 1 - iterations / maxIterations);

    // Repulsion between all nodes
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const a = nodes[i], b = nodes[j];
        let dx = b.x - a.x, dy = b.y - a.y;
        let dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const force = -800 * alpha / (dist * dist);
        const fx = (dx / dist) * force;
        const fy = (dy / dist) * force;
        a.vx -= fx; a.vy -= fy;
        b.vx += fx; b.vy += fy;
      }
    }

    // Attraction along edges
    for (const e of edges) {
      const a = nodeMap[e.source], b = nodeMap[e.target];
      if (!a || !b) continue;
      let dx = b.x - a.x, dy = b.y - a.y;
      let dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const force = (dist - 80) * 0.03 * alpha;
      const fx = (dx / dist) * force;
      const fy = (dy / dist) * force;
      a.vx += fx; a.vy += fy;
      b.vx -= fx; b.vy -= fy;
    }

    // Center gravity
    const cx = canvas.width / 2, cy = canvas.height / 2;
    for (const n of nodes) {
      n.vx += (cx - n.x) * 0.001 * alpha;
      n.vy += (cy - n.y) * 0.001 * alpha;
    }

    // Apply velocity
    for (const n of nodes) {
      if (n === dragNode) continue;
      n.vx *= damping;
      n.vy *= damping;
      n.x += n.vx;
      n.y += n.vy;
    }

    draw();
    if (iterations < maxIterations || dragNode) {
      requestAnimationFrame(step);
    } else {
      // Keep rendering for interaction
      function interactionLoop() {
        draw();
        requestAnimationFrame(interactionLoop);
      }
      interactionLoop();
    }
  }
  step();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(camX, camY);
  ctx.scale(camScale, camScale);

  // Edges
  ctx.lineWidth = 0.5;
  for (const e of edges) {
    const a = nodeMap[e.source], b = nodeMap[e.target];
    if (!a || !b) continue;
    ctx.strokeStyle = 'rgba(108,112,134,0.25)';
    if (hoveredNode && (e.source === hoveredNode.id || e.target === hoveredNode.id)) {
      ctx.strokeStyle = 'rgba(137,180,250,0.6)';
      ctx.lineWidth = 1.5;
    }
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    ctx.lineWidth = 0.5;
  }

  // Nodes
  for (const n of nodes) {
    const isHovered = hoveredNode && hoveredNode.id === n.id;
    const isConnected = hoveredNode && edges.some(e =>
      (e.source === hoveredNode.id && e.target === n.id) ||
      (e.target === hoveredNode.id && e.source === n.id)
    );
    const r = isHovered ? 7 : (isConnected ? 5 : n.radius);
    const alpha = hoveredNode ? (isHovered || isConnected ? 1 : 0.3) : 0.85;

    ctx.beginPath();
    ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
    ctx.fillStyle = n.color;
    ctx.globalAlpha = alpha;
    ctx.fill();
    ctx.globalAlpha = 1;

    // Labels
    if (showLabels && (isHovered || isConnected || camScale > 1.5)) {
      ctx.font = `${isHovered ? 'bold ' : ''}${10 / Math.max(camScale, 1)}px -apple-system, sans-serif`;
      ctx.fillStyle = isHovered ? '#cdd6f4' : 'rgba(205,214,244,0.6)';
      ctx.textAlign = 'center';
      ctx.fillText(n.id, n.x, n.y - r - 4);
    }
  }

  ctx.restore();
}

// Interaction
function screenToWorld(sx, sy) {
  return { x: (sx - camX) / camScale, y: (sy - camY) / camScale };
}

function findNode(sx, sy) {
  const w = screenToWorld(sx, sy);
  for (let i = nodes.length - 1; i >= 0; i--) {
    const n = nodes[i];
    const dx = n.x - w.x, dy = n.y - w.y;
    if (dx * dx + dy * dy < 100) return n;
  }
  return null;
}

canvas.addEventListener('mousedown', e => {
  const n = findNode(e.clientX, e.clientY);
  if (n) {
    dragNode = n;
  } else {
    dragging = true;
  }
  lastMouse = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener('mousemove', e => {
  if (dragNode) {
    const w = screenToWorld(e.clientX, e.clientY);
    dragNode.x = w.x;
    dragNode.y = w.y;
    dragNode.vx = 0;
    dragNode.vy = 0;
  } else if (dragging) {
    camX += e.clientX - lastMouse.x;
    camY += e.clientY - lastMouse.y;
  } else {
    const n = findNode(e.clientX, e.clientY);
    hoveredNode = n;
    const tooltip = document.getElementById('tooltip');
    if (n) {
      canvas.style.cursor = 'pointer';
      tooltip.style.display = 'block';
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top = (e.clientY + 12) + 'px';
      document.getElementById('ttId').textContent = n.id;
      document.getElementById('ttTitle').textContent = n.title;
      document.getElementById('ttDomain').textContent = `Domain ${n.domain}: ${n.domainName || DOMAIN_NAMES[n.domain] || n.domain}`;
    } else {
      canvas.style.cursor = 'grab';
      tooltip.style.display = 'none';
    }
  }
  lastMouse = { x: e.clientX, y: e.clientY };
});

canvas.addEventListener('mouseup', e => {
  if (dragNode && !dragging) {
    // If it was a click (not drag), open the doc
    const dx = e.clientX - lastMouse.x, dy = e.clientY - lastMouse.y;
  }
  dragNode = null;
  dragging = false;
});

canvas.addEventListener('dblclick', e => {
  const n = findNode(e.clientX, e.clientY);
  if (n) {
    window.open(`/#${n.id}`, '_blank');
  }
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const zoom = e.deltaY > 0 ? 0.9 : 1.1;
  const wx = (e.clientX - camX) / camScale;
  const wy = (e.clientY - camY) / camScale;
  camScale *= zoom;
  camScale = Math.max(0.1, Math.min(5, camScale));
  camX = e.clientX - wx * camScale;
  camY = e.clientY - wy * camScale;
}, { passive: false });

// Touch support
let touchDist = 0;
canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    const t = e.touches[0];
    const n = findNode(t.clientX, t.clientY);
    if (n) dragNode = n;
    else dragging = true;
    lastMouse = { x: t.clientX, y: t.clientY };
  } else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    touchDist = Math.sqrt(dx * dx + dy * dy);
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  if (e.touches.length === 1) {
    const t = e.touches[0];
    if (dragNode) {
      const w = screenToWorld(t.clientX, t.clientY);
      dragNode.x = w.x; dragNode.y = w.y;
      dragNode.vx = 0; dragNode.vy = 0;
    } else if (dragging) {
      camX += t.clientX - lastMouse.x;
      camY += t.clientY - lastMouse.y;
    }
    lastMouse = { x: t.clientX, y: t.clientY };
  } else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const zoom = dist / touchDist;
    camScale *= zoom;
    camScale = Math.max(0.1, Math.min(5, camScale));
    touchDist = dist;
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', () => { dragNode = null; dragging = false; });

function resetView() {
  camX = 0; camY = 0; camScale = 1;
}

function toggleLabels() { showLabels = !showLabels; }

loadGraph();
</script>
</body>
</html>
