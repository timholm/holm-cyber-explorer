<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HOLM VAULT</title>
<style>
:root {
  --bg-primary: #1e1e2e;
  --bg-secondary: #181825;
  --bg-tertiary: #11111b;
  --bg-surface: #313244;
  --bg-hover: #45475a;
  --text-primary: #cdd6f4;
  --text-secondary: #a6adc8;
  --text-muted: #7f849c;
  --accent: #89b4fa;
  --accent-dim: #2a3a5c;
  --green: #a6e3a1;
  --red: #f38ba8;
  --yellow: #f9e2af;
  --peach: #fab387;
  --mauve: #cba6f7;
  --teal: #94e2d5;
  --pink: #f5c2e7;
  --border: #313244;
  --sidebar-width: 260px;
  --backlinks-width: 240px;
  --header-height: 48px;
}

/* LIGHT THEME OVERRIDES */
body.light-theme {
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #e8e8e8;
  --bg-surface: #e0e0e0;
  --bg-hover: #d4d4d4;
  --text-primary: #1e1e2e;
  --text-secondary: #4c4f69;
  --text-muted: #636679;
  --accent: #2563eb;
  --accent-dim: #dbeafe;
  --green: #16a34a;
  --red: #dc2626;
  --yellow: #ca8a04;
  --peach: #ea580c;
  --mauve: #9333ea;
  --teal: #0d9488;
  --pink: #db2777;
  --border: #d1d5db;
}

/* Light theme: element-specific overrides for hardcoded colors */
body.light-theme .search-result-item mark { background: rgba(202, 138, 4, 0.2); color: #92400e; }
body.light-theme .code-copy-btn { background: rgba(224, 224, 224, 0.9); }
body.light-theme .scroll-to-top { background: rgba(224, 224, 224, 0.95); box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12); }
body.light-theme .scroll-to-top:hover { background: rgba(212, 212, 212, 0.98); }
body.light-theme .quick-open-overlay { background: rgba(0, 0, 0, 0.3); }
body.light-theme .quick-open-panel { box-shadow: 0 24px 64px rgba(0, 0, 0, 0.2); }
body.light-theme .quick-open-item { border-bottom: 1px solid rgba(209, 213, 219, 0.5); }
body.light-theme .shortcuts-modal-overlay { background: rgba(0, 0, 0, 0.35); }
body.light-theme .shortcuts-modal { box-shadow: 0 24px 64px rgba(0, 0, 0, 0.2); }
body.light-theme .stats-overlay { background: rgba(0, 0, 0, 0.4); }
body.light-theme .stats-dashboard { box-shadow: 0 24px 64px rgba(0, 0, 0, 0.15); }
body.light-theme .doc-link-tooltip { box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1); }
body.light-theme .sidebar.open { box-shadow: 6px 0 32px rgba(0, 0, 0, 0.15); }
body.light-theme .doc-badge-pill.badge-version { background: rgba(37, 99, 235, 0.1); border-color: rgba(37, 99, 235, 0.3); }
body.light-theme .doc-badge-pill.badge-status-ratified { background: rgba(22, 163, 74, 0.1); border-color: rgba(22, 163, 74, 0.3); }
body.light-theme .doc-badge-pill.badge-status-draft { background: rgba(202, 138, 4, 0.1); border-color: rgba(202, 138, 4, 0.3); }
body.light-theme .doc-badge-pill.badge-status-active { background: rgba(37, 99, 235, 0.1); border-color: rgba(37, 99, 235, 0.3); }
body.light-theme .doc-badge-pill.badge-status-deprecated { background: rgba(220, 38, 38, 0.1); border-color: rgba(220, 38, 38, 0.3); }
body.light-theme .doc-badge-pill.badge-status-other { background: rgba(108, 111, 133, 0.1); border-color: rgba(108, 111, 133, 0.3); }
body.light-theme .doc-badge-pill.badge-date { background: rgba(108, 111, 133, 0.08); border-color: rgba(108, 111, 133, 0.2); }
body.light-theme .stats-table td { border-bottom: 1px solid rgba(209, 213, 219, 0.5); }
body.light-theme .fullscreen-exit-hint { box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1); }
body.light-theme .doc-body em { color: #92400e; }
body.light-theme .filter-tag.active { color: #ffffff; }

/* Theme toggle button */
.theme-toggle {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  white-space: nowrap;
  line-height: 1;
  transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}
.theme-toggle:hover { background: var(--bg-hover); }

/* Accent color picker */
.accent-picker-wrapper { position: relative; }
.accent-picker-btn {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 5px 10px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: var(--text-primary);
  white-space: nowrap;
  line-height: 1;
  transition: background-color 0.2s ease, border-color 0.2s ease;
}
.accent-picker-btn:hover { background: var(--bg-hover); }
.accent-swatch-preview {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--accent);
  border: 2px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}
body.light-theme .accent-swatch-preview { border-color: rgba(0,0,0,0.15); }

.accent-popover {
  display: none;
  position: absolute;
  top: calc(100% + 6px);
  right: 0;
  width: 240px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 14px;
  z-index: 500;
  box-shadow: 0 12px 40px rgba(0,0,0,0.35), 0 2px 8px rgba(0,0,0,0.2);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
}
body.light-theme .accent-popover {
  box-shadow: 0 12px 40px rgba(0,0,0,0.15), 0 2px 8px rgba(0,0,0,0.08);
}
.accent-popover.open { display: block; }
.accent-popover-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 10px;
}
.accent-swatches {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 8px;
  justify-items: center;
  margin-bottom: 12px;
}
.accent-swatch {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 2px solid transparent;
  cursor: pointer;
  position: relative;
  transition: transform 0.15s ease, border-color 0.15s ease;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.accent-swatch:hover { transform: scale(1.15); }
.accent-swatch.active {
  border-color: var(--text-primary);
  box-shadow: 0 0 0 2px var(--bg-secondary), 0 0 0 4px var(--text-primary);
}
.accent-swatch.active::after {
  content: '\2713';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
  font-weight: 700;
  color: #fff;
  text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}
.accent-popover-divider {
  height: 1px;
  background: var(--border);
  margin: 12px 0;
}
.accent-custom-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 10px;
}
.accent-custom-row label {
  font-size: 12px;
  color: var(--text-secondary);
  flex-shrink: 0;
}
.accent-custom-row input[type="color"] {
  width: 32px;
  height: 24px;
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  background: none;
  padding: 0;
  -webkit-appearance: none;
  appearance: none;
}
.accent-custom-row input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
.accent-custom-row input[type="color"]::-webkit-color-swatch { border: none; border-radius: 2px; }
.accent-custom-row .accent-hex-value {
  font-size: 11px;
  font-family: 'SF Mono', 'Fira Code', monospace;
  color: var(--text-muted);
}
.accent-reset-btn {
  width: 100%;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 6px 0;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  transition: background-color 0.15s ease, color 0.15s ease;
}
.accent-reset-btn:hover { background: var(--bg-hover); color: var(--text-primary); }

* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  height: 100vh;
  overflow: hidden;
  transition: background-color 0.2s ease, color 0.2s ease;
}
a { color: var(--accent); text-decoration: none; }
a:hover { text-decoration: underline; }

/* HEADER */
.header {
  height: var(--header-height);
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 12px;
  z-index: 100;
}
.header-brand {
  font-weight: 700;
  font-size: 14px;
  color: var(--accent);
  letter-spacing: 1px;
  white-space: nowrap;
}
.hamburger {
  display: none;
  background: none;
  border: none;
  color: var(--text-primary);
  font-size: 20px;
  cursor: pointer;
  padding: 4px 8px;
}
.search-box {
  flex: 1;
  max-width: 400px;
  position: relative;
}
.search-box input {
  width: 100%;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text-primary);
  padding: 6px 12px 6px 32px;
  font-size: 13px;
  outline: none;
}
.search-box input:focus { border-color: var(--accent); }
.search-box::before {
  content: '⌕';
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text-muted);
  font-size: 14px;
}
.search-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  margin-top: 4px;
  max-height: 400px;
  overflow-y: auto;
  display: none;
  z-index: 200;
}
.search-results.active { display: block; }
.search-result-item {
  padding: 8px 12px;
  cursor: pointer;
  border-bottom: 1px solid var(--border);
}
.search-result-item:hover { background: var(--bg-hover); }
.search-result-item .sr-id { color: var(--accent); font-size: 11px; font-weight: 600; }
.search-result-item .sr-title { font-size: 13px; }
.sr-snippet { font-size: 12px; color: var(--text-muted); margin-top: 2px; max-height: 36px; overflow: hidden; }
.search-result-item mark { background: rgba(249,226,175,0.3); color: var(--yellow); padding: 0 2px; border-radius: 2px; }
.header-actions { display: flex; gap: 8px; margin-left: auto; }
.header-btn {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  white-space: nowrap;
}
.header-btn:hover { background: var(--bg-hover); }
.header-btn.active { background: var(--accent-dim); border-color: var(--accent); }

/* TAB BAR */
.tab-bar {
  display: flex;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  overflow-x: auto;
  min-height: 0;
  scrollbar-width: none;
  flex-shrink: 0;
}
.tab-bar::-webkit-scrollbar { display: none; }
.tab-bar:empty { min-height: 0; border: none; }
.tab {
  display: flex;
  align-items: center;
  padding: 4px 12px;
  font-size: 12px;
  cursor: pointer;
  border-right: 1px solid var(--border);
  white-space: nowrap;
  color: var(--text-muted);
  gap: 6px;
  max-width: 180px;
  min-width: 0;
  user-select: none;
}
.tab:hover { background: var(--bg-surface); }
.tab.active { background: var(--bg-primary); color: var(--text-primary); border-bottom: 2px solid var(--accent); }
.tab-close { font-size: 14px; opacity: 0.5; line-height: 1; flex-shrink: 0; border-radius: 3px; padding: 0 2px; }
.tab-close:hover { opacity: 1; background: var(--bg-hover); }
.tab-title { overflow: hidden; text-overflow: ellipsis; min-width: 0; }
.tab-id { font-family: 'SF Mono', 'Fira Code', monospace; font-size: 10px; color: var(--accent); opacity: 0.8; flex-shrink: 0; }
.tab.active .tab-id { opacity: 1; }
.tab.dragging { opacity: 0.4; transform: scale(0.95); }
.tab.drag-over { box-shadow: inset 3px 0 0 var(--accent); }

/* PINNED TABS */
.tab.pinned {
  max-width: 72px;
  min-width: 40px;
  padding: 4px 8px;
  border-left: 2px solid var(--accent);
  gap: 4px;
}
.tab.pinned .tab-title { display: none; }
.tab.pinned .tab-close { display: none; }
.tab.pinned .pin-indicator {
  font-size: 10px;
  line-height: 1;
  opacity: 0.7;
  flex-shrink: 0;
}
.tab.pinned.active .pin-indicator { opacity: 1; }
.tab.pinned .tab-id { font-size: 11px; }

/* Pin context menu */
.pin-context-menu {
  position: fixed;
  z-index: 10000;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 4px 0;
  min-width: 140px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.25);
  font-size: 12px;
  color: var(--text-primary);
  animation: pinMenuFadeIn 0.1s ease;
}
@keyframes pinMenuFadeIn {
  from { opacity: 0; transform: translateY(-4px); }
  to { opacity: 1; transform: translateY(0); }
}
.pin-context-menu-item {
  padding: 6px 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  white-space: nowrap;
}
.pin-context-menu-item:hover {
  background: var(--bg-hover);
}
.pin-context-menu-separator {
  height: 1px;
  background: var(--border);
  margin: 4px 0;
}

/* LAYOUT */
.layout {
  display: flex;
  height: calc(100vh - var(--header-height));
}

/* SIDEBAR */
.sidebar {
  width: var(--sidebar-width);
  min-width: var(--sidebar-width);
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  overflow-x: hidden;
  padding: 8px 0;
  transition: transform 0.2s;
}
.sidebar-filter {
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
}
.filter-tag {
  display: inline-block;
  background: var(--accent-dim);
  color: var(--accent);
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 11px;
  margin: 2px;
  cursor: pointer;
}
.filter-tag:hover { background: var(--bg-hover); }
.filter-tag.active { background: var(--accent); color: var(--bg-tertiary); }
.clear-filter { font-size: 11px; color: var(--text-muted); cursor: pointer; margin-left: 4px; }
.clear-filter:hover { color: var(--red); }
.sidebar-sort-controls { display: flex; align-items: center; gap: 4px; padding: 6px 12px; border-bottom: 1px solid var(--border); }
.sidebar-sort-controls .sort-label { font-size: 10px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-right: 2px; flex-shrink: 0; }
.sidebar-sort-btn { background: none; border: 1px solid transparent; color: var(--text-muted); font-size: 11px; padding: 2px 7px; border-radius: 4px; cursor: pointer; white-space: nowrap; font-family: inherit; line-height: 1.4; transition: background 0.15s, color 0.15s, border-color 0.15s; }
.sidebar-sort-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
.sidebar-sort-btn.active { background: var(--accent-dim); color: var(--accent); border-color: var(--accent); }
.sidebar-sort-btn .sort-arrow { font-size: 9px; margin-left: 2px; opacity: 0; display: inline-block; transition: opacity 0.15s; }
.sidebar-sort-btn.active .sort-arrow { opacity: 1; }
.sidebar-section.flat-group .sidebar-section-header { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
.sidebar-section { margin-bottom: 2px; }
.sidebar-section-header {
  display: flex;
  align-items: center;
  padding: 6px 12px;
  cursor: pointer;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  user-select: none;
}
.sidebar-section-header:hover { color: var(--text-primary); }
.sidebar-section-header .chevron {
  margin-right: 6px;
  font-size: 8px;
  transition: transform 0.2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 12px;
  flex-shrink: 0;
}
.sidebar-section.collapsed .chevron { transform: rotate(-90deg); }
.sidebar-items-wrap {
  overflow: hidden;
  transition: height 0.2s ease;
}
.sidebar-item {
  display: flex;
  align-items: center;
  padding: 4px 12px 4px 28px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.sidebar-item:hover { background: var(--bg-hover); color: var(--text-primary); }
.sidebar-item.active { background: var(--accent-dim); color: var(--accent); }
.sidebar-item .doc-id {
  color: var(--text-muted);
  font-size: 11px;
  font-family: monospace;
  margin-right: 8px;
  min-width: 56px;
}
.sidebar-item .doc-title { overflow: hidden; text-overflow: ellipsis; }
.doc-count {
  padding: 8px 12px;
  font-size: 11px;
  color: var(--text-muted);
  border-top: 1px solid var(--border);
}

/* MAIN CONTENT */
.main-content {
  flex: 1;
  overflow-y: auto;
  padding: 32px 48px;
  min-width: 0;
  position: relative;
}

/* READING PROGRESS BAR */
.reading-progress-bar {
  position: sticky;
  top: 0;
  left: 0;
  width: 0%;
  height: 3px;
  background: linear-gradient(90deg, var(--accent), var(--mauve));
  z-index: 50;
  transition: width 0.15s ease-out;
  pointer-events: none;
  opacity: 0;
  margin: -32px -48px 32px -48px;
}
.reading-progress-bar.visible {
  opacity: 1;
}

.welcome {
  max-width: 600px;
  margin: 80px auto;
  text-align: center;
}
.welcome h1 { font-size: 28px; margin-bottom: 12px; color: var(--accent); }
.welcome p { color: var(--text-secondary); font-size: 14px; line-height: 1.6; }
.welcome .stats { margin-top: 24px; display: flex; gap: 24px; justify-content: center; }
.welcome .stat { text-align: center; }
.welcome .stat-num { font-size: 28px; font-weight: 700; color: var(--accent); }
.welcome .stat-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; }

/* BREADCRUMB */
.breadcrumb {
  display: none;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 12px;
  user-select: none;
}
.breadcrumb.active { display: flex; }
.breadcrumb .bc-separator { color: var(--text-muted); opacity: 0.5; font-size: 10px; }
.breadcrumb .bc-vault { color: var(--text-muted); }
.breadcrumb .bc-domain {
  color: var(--text-secondary);
  cursor: pointer;
  border-radius: 3px;
  padding: 1px 4px;
  transition: color 0.15s, background 0.15s;
}
.breadcrumb .bc-domain:hover { color: var(--accent); background: var(--accent-dim); }
.breadcrumb .bc-current { color: var(--text-muted); font-family: 'SF Mono', 'Fira Code', monospace; font-size: 11px; }

/* DOC VIEWER */
.doc-viewer { display: none; max-width: 860px; opacity: 1; transition: opacity 0.15s ease; }
.doc-viewer.active { display: block; }
.doc-viewer.doc-transitioning { opacity: 0; }
.doc-header { margin-bottom: 24px; }
.doc-header h1 { font-size: 24px; line-height: 1.3; margin-bottom: 8px; }
.doc-badges { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
.doc-badge-pill { display: inline-flex; align-items: center; font-size: 11px; font-weight: 600; padding: 2px 10px; border-radius: 9999px; line-height: 1.6; letter-spacing: 0.2px; white-space: nowrap; border: 1px solid transparent; }
.doc-badge-pill.badge-version { background: rgba(137,180,250,0.15); color: var(--accent); border-color: rgba(137,180,250,0.3); }
.doc-badge-pill.badge-status-ratified { background: rgba(166,227,161,0.15); color: var(--green); border-color: rgba(166,227,161,0.3); }
.doc-badge-pill.badge-status-draft { background: rgba(249,226,175,0.15); color: var(--yellow); border-color: rgba(249,226,175,0.3); }
.doc-badge-pill.badge-status-active { background: rgba(137,180,250,0.15); color: var(--accent); border-color: rgba(137,180,250,0.3); }
.doc-badge-pill.badge-status-deprecated { background: rgba(243,139,168,0.15); color: var(--red); border-color: rgba(243,139,168,0.3); }
.doc-badge-pill.badge-status-other { background: rgba(108,112,134,0.15); color: var(--text-muted); border-color: rgba(108,112,134,0.3); }
.doc-badge-pill.badge-date { background: rgba(108,112,134,0.10); color: var(--text-muted); border-color: rgba(108,112,134,0.2); font-weight: 500; }
.doc-meta { display: flex; gap: 12px; flex-wrap: wrap; font-size: 12px; color: var(--text-muted); }
.doc-meta .badge { background: var(--bg-surface); padding: 2px 8px; border-radius: 4px; }
.doc-reading-info { font-size: 12px; color: var(--text-muted); margin-top: 6px; letter-spacing: 0.2px; }
.doc-toolbar {
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 12px;
}
.doc-toolbar button {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 4px 12px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
}
.doc-toolbar button:hover { color: var(--text-primary); background: var(--bg-surface); }
.doc-toolbar button:disabled { color: var(--text-muted); opacity: 0.4; cursor: default; pointer-events: none; }
.doc-toolbar button.active { color: var(--accent); border-color: var(--accent); }
.doc-toolbar .nav-btn { font-size: 14px; padding: 4px 8px; min-width: 28px; display: inline-flex; align-items: center; justify-content: center; }
.doc-toolbar .nav-separator { width: 1px; background: var(--border); align-self: stretch; margin: 2px 4px; }
.doc-body { font-size: 15px; line-height: 1.7; color: var(--text-primary); }
.doc-body h1 { font-size: 22px; margin: 24px 0 12px; color: var(--text-primary); }
.doc-body h2 { font-size: 18px; margin: 20px 0 10px; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 4px; }
.doc-body h3 { font-size: 15px; margin: 16px 0 8px; color: var(--peach); }
.doc-body p { margin: 8px 0; }
.doc-body ul, .doc-body ol { margin: 8px 0 8px 24px; }
.doc-body li { margin: 4px 0; }
.doc-body em { color: var(--yellow); font-style: italic; }
.doc-body strong { color: var(--text-primary); font-weight: 700; }
.doc-body blockquote {
  border-left: 3px solid var(--accent);
  padding: 8px 16px;
  margin: 12px 0;
  background: var(--bg-secondary);
  border-radius: 0 4px 4px 0;
}
.doc-body code { background: var(--bg-surface); padding: 1px 5px; border-radius: 3px; font-size: 13px; font-family: 'SF Mono', 'Fira Code', monospace; }
.doc-body pre { background: var(--bg-tertiary); padding: 16px; border-radius: 6px; overflow-x: auto; margin: 12px 0; position: relative; }
.doc-body pre code { background: none; padding: 0; }

/* CODE BLOCK COPY BUTTON */
.code-copy-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  background: rgba(49, 50, 68, 0.8);
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 11px;
  font-family: inherit;
  padding: 2px 8px;
  border-radius: 4px;
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.15s, background 0.15s, color 0.15s;
  z-index: 1;
  line-height: 1.4;
}
.doc-body pre:hover .code-copy-btn { opacity: 1; }
.code-copy-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
.code-copy-btn.copied { color: var(--green); border-color: var(--green); }
.doc-body table { border-collapse: collapse; margin: 12px 0; width: 100%; }
.doc-body th, .doc-body td { border: 1px solid var(--border); padding: 8px 12px; font-size: 13px; text-align: left; }
.doc-body th { background: var(--bg-surface); font-weight: 600; }
.doc-body .metadata { display: none; }
.doc-body aside.metadata { display: none; }

/* Doc ID inline links */
a.doc-link { color: var(--accent); cursor: pointer; text-decoration: underline dotted; text-underline-offset: 3px; }

/* Doc link preview tooltip */
.doc-link-tooltip {
  position: fixed;
  z-index: 500;
  display: none;
  width: 320px;
  max-width: calc(100vw - 32px);
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 2px 8px rgba(0, 0, 0, 0.3);
  padding: 12px 14px;
  pointer-events: none;
  font-size: 13px;
  line-height: 1.5;
}
.doc-link-tooltip.visible { display: block; }
.doc-link-tooltip-id {
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 11px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 4px;
}
.doc-link-tooltip-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 6px;
  line-height: 1.3;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}
.doc-link-tooltip-domain {
  font-size: 11px;
  color: var(--text-muted);
  margin-bottom: 6px;
}
.doc-link-tooltip-excerpt {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.5;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  margin-bottom: 6px;
}
.doc-link-tooltip-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}
.doc-link-tooltip-tag {
  display: inline-block;
  background: var(--accent-dim);
  color: var(--accent);
  padding: 1px 6px;
  border-radius: 3px;
  font-size: 10px;
}

/* Edit mode */
.edit-area {
  display: none;
  width: 100%;
  min-height: 500px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 14px;
  line-height: 1.6;
  padding: 16px;
  border-radius: 6px;
  resize: vertical;
}
.edit-area.active { display: block; }
.save-bar { display: none; margin-top: 12px; gap: 8px; }
.save-bar.active { display: flex; }
.save-bar button { padding: 6px 16px; border-radius: 6px; font-size: 13px; cursor: pointer; border: none; }
.save-btn { background: var(--accent); color: var(--bg-tertiary); font-weight: 600; }
.cancel-btn { background: var(--bg-surface); color: var(--text-secondary); border: 1px solid var(--border) !important; }

/* TABLE OF CONTENTS */
.toc-section { margin-bottom: 20px; }
.toc-item { display: block; padding: 2px 0; font-size: 13px; color: var(--text-secondary); cursor: pointer; }
.toc-item:hover { color: var(--text-primary); }
.toc-item.toc-h2 { padding-left: 0; }
.toc-item.toc-h3 { padding-left: 12px; font-size: 12px; }

/* LOCAL GRAPH */
.local-graph { width: 100%; height: 200px; border-bottom: 1px solid var(--border); margin-bottom: 12px; position: relative; }
.local-graph canvas { display: block; width: 100%; height: 100%; cursor: default; }
#localGraphTooltip {
  position: fixed;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-size: 11px;
  font-family: 'SF Mono', 'Fira Code', monospace;
  padding: 4px 8px;
  border-radius: 4px;
  pointer-events: none;
  white-space: nowrap;
  z-index: 999;
  display: none;
}

/* BACKLINKS PANEL */
.backlinks-panel {
  width: var(--backlinks-width);
  min-width: var(--backlinks-width);
  background: var(--bg-secondary);
  border-left: 1px solid var(--border);
  overflow-y: auto;
  padding: 16px;
  display: none;
}
.backlinks-panel.active { display: block; }
.backlinks-section { margin-bottom: 20px; }
.backlinks-section h3 {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-muted);
  margin-bottom: 8px;
}
.backlink-item { display: block; padding: 4px 0; font-size: 13px; color: var(--accent); cursor: pointer; }
.backlink-item:hover { color: var(--text-primary); }
.tag-item {
  display: inline-block;
  background: var(--accent-dim);
  color: var(--accent);
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 11px;
  margin: 2px 4px 2px 0;
  cursor: pointer;
}
.tag-item:hover { background: var(--bg-hover); }

/* PERSONAL NOTES */
.notes-section { margin-bottom: 20px; }
.notes-section h3 {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-muted);
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.notes-section h3 .notes-count {
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 400;
}
.notes-textarea {
  width: 100%;
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px;
  font-size: 12px;
  font-family: inherit;
  resize: vertical;
  outline: none;
  line-height: 1.4;
}
.notes-textarea:focus {
  border-color: var(--accent);
}
.notes-textarea::placeholder {
  color: var(--text-muted);
  font-style: italic;
}
.notes-actions {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 6px;
  min-height: 20px;
}
.notes-clear-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 4px;
  cursor: pointer;
}
.notes-clear-btn:hover {
  color: var(--red);
  border-color: var(--red);
}
.notes-saved-indicator {
  font-size: 11px;
  color: var(--green);
  opacity: 0;
  transition: opacity 0.3s ease;
}
.notes-saved-indicator.visible {
  opacity: 1;
}
.sidebar-item .note-icon {
  font-size: 10px;
  color: var(--yellow);
  margin-left: auto;
  flex-shrink: 0;
  opacity: 0.8;
  padding-left: 4px;
}

/* RELATED DOCS SECTION */
.related-section h3 { cursor: pointer; user-select: none; display: flex; align-items: center; gap: 4px; }
.related-section h3 .related-chevron {
  display: inline-block;
  font-size: 8px;
  transition: transform 0.2s ease;
}
.related-section.collapsed h3 .related-chevron { transform: rotate(-90deg); }
.related-section.collapsed .related-list { display: none; }
.related-item {
  display: block;
  padding: 5px 0;
  border-bottom: 1px solid var(--border);
}
.related-item:last-child { border-bottom: none; }
.related-item-link {
  display: block;
  font-size: 13px;
  color: var(--accent);
  cursor: pointer;
}
.related-item-link:hover { color: var(--text-primary); }
.related-item-title {
  font-size: 12px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.related-item-score {
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 1px;
}

/* LOADING */
.loading { display: flex; align-items: center; justify-content: center; height: 200px; color: var(--text-muted); }
.spinner {
  width: 24px;
  height: 24px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
  margin-right: 12px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* STATUS BAR */
.status-bar {
  height: 24px;
  background: var(--bg-tertiary);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  font-size: 11px;
  color: var(--text-muted);
  gap: 16px;
}

/* QUICK OPEN / COMMAND PALETTE */
.quick-open-overlay {
  position: fixed; inset: 0;
  background: rgba(0, 0, 0, 0.55);
  z-index: 300;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding-top: 12vh;
  backdrop-filter: blur(2px);
}
.quick-open-panel {
  width: 100%; max-width: 500px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: 0 24px 64px rgba(0, 0, 0, 0.6);
  overflow: hidden;
  display: flex; flex-direction: column;
  max-height: 70vh;
}
#quickOpenInput {
  width: 100%; background: var(--bg-surface); border: none;
  border-bottom: 1px solid var(--border);
  color: var(--text-primary); font-size: 15px; padding: 14px 16px;
  outline: none; font-family: inherit; flex-shrink: 0;
}
#quickOpenInput::placeholder { color: var(--text-muted); }
.quick-open-results { overflow-y: auto; flex: 1; }
.quick-open-item {
  display: flex; align-items: baseline; gap: 10px;
  padding: 9px 16px; cursor: pointer;
  border-bottom: 1px solid rgba(49, 50, 68, 0.5);
}
.quick-open-item:last-child { border-bottom: none; }
.quick-open-item:hover, .quick-open-item.selected { background: var(--bg-hover); }
.quick-open-item .qo-id { color: var(--accent); font-size: 11px; font-weight: 600; font-family: 'SF Mono', 'Fira Code', monospace; min-width: 60px; flex-shrink: 0; }
.quick-open-item .qo-title { font-size: 13px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.quick-open-empty { padding: 24px 16px; text-align: center; color: var(--text-muted); font-size: 13px; }
.quick-open-hint {
  padding: 7px 16px; font-size: 11px; color: var(--text-muted);
  background: var(--bg-tertiary); border-top: 1px solid var(--border);
  display: flex; gap: 16px; flex-shrink: 0;
}
.quick-open-hint kbd {
  display: inline-block; background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 3px; padding: 0px 5px; font-size: 10px; font-family: inherit;
  color: var(--text-secondary); margin-right: 3px;
}

/* KEYBOARD SHORTCUTS MODAL */
.shortcuts-modal-overlay {
  display: none; position: fixed; inset: 0;
  background: rgba(0, 0, 0, 0.65); z-index: 1000;
  align-items: center; justify-content: center;
  backdrop-filter: blur(2px);
}
.shortcuts-modal-overlay.active { display: flex; }
.shortcuts-modal {
  background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 10px;
  width: 520px; max-width: calc(100vw - 32px); max-height: calc(100vh - 64px);
  overflow-y: auto; box-shadow: 0 24px 64px rgba(0, 0, 0, 0.6);
}
.shortcuts-modal-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 18px 24px 14px; border-bottom: 1px solid var(--border);
}
.shortcuts-modal-header h2 { font-size: 15px; font-weight: 700; color: var(--text-primary); }
.shortcuts-modal-close {
  background: none; border: none; color: var(--text-muted); font-size: 20px;
  cursor: pointer; line-height: 1; padding: 2px 6px; border-radius: 4px;
}
.shortcuts-modal-close:hover { color: var(--text-primary); background: var(--bg-hover); }
.shortcuts-modal-body { padding: 16px 24px 20px; }
.shortcuts-group { margin-bottom: 20px; }
.shortcuts-group:last-child { margin-bottom: 0; }
.shortcuts-group-label { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.8px; color: var(--text-muted); margin-bottom: 8px; }
.shortcuts-table { width: 100%; border-collapse: collapse; }
.shortcuts-table tr + tr td { border-top: 1px solid var(--border); }
.shortcuts-table td { padding: 7px 0; font-size: 13px; vertical-align: middle; }
.shortcuts-table td:first-child { color: var(--text-secondary); padding-right: 24px; white-space: nowrap; }
.shortcuts-table td:last-child { color: var(--text-muted); text-align: right; }
.kbd {
  display: inline-block; background: var(--bg-surface); border: 1px solid var(--bg-hover);
  border-bottom-width: 2px; border-radius: 4px; padding: 1px 7px; font-size: 11px;
  font-family: 'SF Mono', 'Fira Code', monospace; color: var(--accent); white-space: nowrap;
}
.kbd + .kbd { margin-left: 4px; }

/* RESPONSIVE - MOBILE (below 768px) */
@media (max-width: 768px) {

  /* --- Hamburger menu button: touch-friendly 44px target --- */
  .hamburger {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 44px;
    min-height: 44px;
    font-size: 22px;
    padding: 0;
    border-radius: 6px;
    -webkit-tap-highlight-color: transparent;
  }
  .hamburger:active {
    background: var(--bg-hover);
  }

  /* --- Header: compact for mobile, no overflow --- */
  .header {
    padding: 0 8px;
    gap: 6px;
    overflow: hidden;
  }
  .header-brand {
    font-size: 12px;
    letter-spacing: 0.5px;
    flex-shrink: 0;
  }
  .search-box {
    max-width: none;
    min-width: 0;
    flex: 1;
  }
  .search-box input {
    font-size: 16px; /* prevents iOS auto-zoom on focus */
    padding: 8px 12px 8px 32px;
    min-height: 38px;
  }
  .header-actions {
    gap: 2px;
    flex-shrink: 0;
  }
  .header-actions .graph-label { display: none; }
  .accent-picker-label { display: none; }
  .header-btn {
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 6px;
    font-size: 15px;
    -webkit-tap-highlight-color: transparent;
  }
  .header-btn:active {
    background: var(--bg-hover);
  }

  /* --- Tab bar: horizontally scrollable with touch momentum --- */
  .tab-bar {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scroll-snap-type: x proximity;
    flex-shrink: 0;
  }
  .tab {
    min-height: 44px;
    padding: 6px 14px;
    font-size: 13px;
    scroll-snap-align: start;
    flex-shrink: 0;
    -webkit-tap-highlight-color: transparent;
  }
  .tab-close {
    min-width: 30px;
    min-height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    border-radius: 4px;
    -webkit-tap-highlight-color: transparent;
  }

  .tab.pinned {
    min-height: 44px;
    padding: 6px 10px;
    max-width: 60px;
  }
  .pin-context-menu {
    font-size: 14px;
  }
  .pin-context-menu-item {
    padding: 10px 14px;
    min-height: 44px;
  }

  /* --- Layout: stack vertically on mobile --- */
  .layout {
    flex-direction: column;
    height: calc(100vh - var(--header-height));
    overflow: hidden;
  }

  /* --- Sidebar: fixed overlay sliding in from left --- */
  .sidebar {
    position: fixed;
    top: var(--header-height);
    left: 0;
    bottom: 24px;
    z-index: 50;
    transform: translateX(-100%);
    transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: none;
    will-change: transform;
  }
  .sidebar.open {
    transform: translateX(0);
    box-shadow: 6px 0 32px rgba(0, 0, 0, 0.5);
  }

  /* --- Sidebar overlay: tap outside to close --- */
  .sidebar-overlay {
    display: none;
    position: fixed;
    inset: 0;
    top: var(--header-height);
    bottom: 24px;
    background: rgba(0, 0, 0, 0.5);
    z-index: 49;
    -webkit-tap-highlight-color: transparent;
  }
  .sidebar-overlay.active {
    display: block;
  }

  /* --- Sidebar items: touch-friendly 44px tap targets --- */
  .sidebar-section-header {
    min-height: 44px;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .sidebar-item {
    min-height: 44px;
    padding: 8px 12px 8px 28px;
    display: flex;
    align-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .sidebar-item:active {
    background: var(--bg-hover);
  }
  .filter-tag {
    min-height: 34px;
    display: inline-flex;
    align-items: center;
    padding: 4px 14px;
    font-size: 12px;
  }
  .clear-filter {
    min-width: 44px;
    min-height: 44px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  /* --- Main content: reduced padding --- */
  .main-content {
    padding: 16px 14px;
    flex: 1;
    min-height: 0;
    overflow-y: auto;
  }
  .reading-progress-bar {
    margin: -16px -14px 16px -14px;
  }
  .welcome {
    margin: 40px auto;
    padding: 0 8px;
  }
  .welcome h1 { font-size: 22px; }
  .welcome p { font-size: 13px; }
  .welcome .stats { gap: 16px; flex-wrap: wrap; }
  .welcome .stat-num { font-size: 22px; }

  /* --- Doc viewer --- */
  .doc-header h1 { font-size: 18px; word-break: break-word; }
  .doc-meta { font-size: 11px; gap: 6px; }
  .doc-meta .badge { padding: 3px 8px; }
  .doc-body { font-size: 14px; line-height: 1.65; }
  .doc-body h1 { font-size: 19px; }
  .doc-body h2 { font-size: 16px; }
  .doc-body h3 { font-size: 14px; }
  .doc-body pre {
    padding: 12px;
    font-size: 12px;
    -webkit-overflow-scrolling: touch;
  }
  .doc-body table {
    display: block;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  .doc-body blockquote {
    padding: 6px 12px;
    margin: 8px 0;
  }
  .doc-body ul, .doc-body ol { margin-left: 18px; }

  /* --- Code copy button: always visible on mobile (no hover) --- */
  .code-copy-btn {
    opacity: 1;
    min-width: 44px;
    min-height: 32px;
    padding: 4px 10px;
    font-size: 12px;
  }

  /* --- Doc toolbar: scrollable, prevents overflow --- */
  .doc-toolbar {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    flex-wrap: nowrap;
    gap: 6px;
    padding-bottom: 10px;
    margin-bottom: 16px;
    scrollbar-width: none;
  }
  .doc-toolbar::-webkit-scrollbar { display: none; }
  .doc-toolbar button {
    min-height: 44px;
    min-width: 44px;
    padding: 8px 16px;
    flex-shrink: 0;
    white-space: nowrap;
    font-size: 13px;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- Backlinks panel: moves below content (not side-by-side) --- */
  .backlinks-panel {
    width: 100%;
    min-width: 100%;
    max-height: none;
    border-left: none;
    border-top: 1px solid var(--border);
    overflow-y: auto;
    flex-shrink: 0;
    padding: 14px;
  }
  .backlinks-panel.active {
    display: block;
    max-height: 45vh;
  }
  .backlink-item {
    min-height: 44px;
    display: flex;
    align-items: center;
    padding: 6px 0;
    -webkit-tap-highlight-color: transparent;
  }
  .tag-item {
    min-height: 34px;
    display: inline-flex;
    align-items: center;
    padding: 4px 14px;
    font-size: 12px;
  }
  .toc-item {
    min-height: 38px;
    display: flex;
    align-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .local-graph {
    height: 160px;
  }
  .backlinks-section h3 {
    min-height: 32px;
    display: flex;
    align-items: center;
  }

  /* --- Quick open palette: full-width on mobile --- */
  .quick-open-overlay {
    padding-top: 0;
    align-items: flex-start;
  }
  .quick-open-panel {
    max-width: 100%;
    width: 100%;
    border-radius: 0 0 10px 10px;
    max-height: 85vh;
  }
  #quickOpenInput {
    font-size: 16px; /* prevents iOS zoom */
    padding: 16px;
    min-height: 52px;
  }
  .quick-open-item {
    min-height: 48px;
    padding: 10px 16px;
    display: flex;
    align-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .quick-open-hint {
    flex-wrap: wrap;
    padding: 8px 16px;
    gap: 8px;
  }

  /* --- Search results dropdown --- */
  .search-results {
    max-height: 60vh;
  }
  .search-result-item {
    min-height: 44px;
    padding: 10px 12px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- Shortcuts modal --- */
  .shortcuts-modal {
    width: calc(100vw - 16px);
    max-height: calc(100vh - 32px);
  }
  .shortcuts-modal-body { padding: 12px 16px 16px; }
  .shortcuts-modal-header { padding: 14px 16px 10px; }
  .shortcuts-modal-close {
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* --- Favorites button: touch-friendly --- */
  .favorite-btn {
    min-width: 44px;
    min-height: 44px;
  }
  .sidebar-section.favorites-section .sidebar-item .fav-remove {
    opacity: 0.6;
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* --- Scroll-to-top: touch-friendly --- */
  .scroll-to-top {
    bottom: 16px;
    right: 16px;
    width: 44px;
    height: 44px;
  }

  /* --- Status bar --- */
  .status-bar {
    font-size: 10px;
    padding: 0 8px;
    gap: 8px;
    overflow: hidden;
    white-space: nowrap;
  }

  /* --- Edit area --- */
  .edit-area {
    font-size: 14px;
    padding: 12px;
    min-height: 300px;
  }
  .save-bar button {
    min-height: 44px;
    min-width: 80px;
    padding: 8px 20px;
    font-size: 14px;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- Breadcrumb --- */
  .breadcrumb {
    font-size: 11px;
    flex-wrap: wrap;
    gap: 4px;
  }
  .breadcrumb .bc-domain {
    min-height: 28px;
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
  }

  /* --- Doc links: touch-friendly --- */
  a.doc-link {
    padding: 2px 0;
  }
}

/* Extra small screens (below 480px) */
@media (max-width: 480px) {
  .header-brand { display: none; }
  .main-content { padding: 12px 10px; }
  .reading-progress-bar { margin: -12px -10px 12px -10px; }
  .doc-header h1 { font-size: 16px; }
  .doc-body { font-size: 13px; line-height: 1.6; }
  .doc-body h1 { font-size: 17px; }
  .doc-body h2 { font-size: 15px; }
  .doc-body h3 { font-size: 13px; }
  .welcome h1 { font-size: 18px; }
  .welcome p { font-size: 12px; }
  .quick-open-panel { border-radius: 0; }
  .doc-meta { gap: 4px; }
  .doc-meta .badge { font-size: 10px; }
}

/* FAVORITES STAR BUTTON (doc toolbar) */
.favorite-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 16px;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 4px;
  line-height: 1;
  transition: color 0.15s, border-color 0.15s;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin-left: auto;
}
.favorite-btn:hover { color: var(--yellow); border-color: var(--yellow); background: var(--bg-surface); }
.favorite-btn.favorited { color: var(--yellow); border-color: var(--yellow); }

/* FAVORITES SIDEBAR SECTION */
.sidebar-section.favorites-section .sidebar-section-header {
  color: var(--yellow);
}
.sidebar-section.favorites-section .sidebar-item {
  padding-right: 8px;
}
.sidebar-section.favorites-section .sidebar-item .fav-remove {
  margin-left: auto;
  font-size: 13px;
  color: var(--text-muted);
  opacity: 0;
  padding: 0 4px;
  cursor: pointer;
  flex-shrink: 0;
  transition: opacity 0.15s;
  line-height: 1;
}
.sidebar-section.favorites-section .sidebar-item:hover .fav-remove {
  opacity: 1;
}
.sidebar-section.favorites-section .sidebar-item .fav-remove:hover {
  color: var(--red);
}
.sidebar-section.favorites-section .sidebar-items-empty {
  padding: 4px 12px 8px 28px;
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
}

/* SCROLL-TO-TOP BUTTON */
.scroll-to-top {
  position: absolute;
  bottom: 24px;
  right: 24px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: rgba(49, 50, 68, 0.85);
  border: 1px solid var(--border);
  color: var(--accent);
  font-size: 18px;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 30;
  opacity: 0;
  transform: translateY(12px);
  pointer-events: none;
  transition: opacity 0.25s ease, transform 0.25s ease, background 0.15s ease, border-color 0.15s ease;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}
.scroll-to-top.visible {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
}
.scroll-to-top:hover {
  background: rgba(69, 71, 90, 0.95);
  color: var(--text-primary);
  border-color: var(--accent);
}
.scroll-to-top:active {
  transform: scale(0.92);
}


/* RECENTLY VIEWED */
.recent-section { border-bottom: 1px solid var(--border); padding-bottom: 4px; margin-bottom: 4px; }
.recent-section-header {
  display: flex;
  align-items: center;
  padding: 6px 12px;
  cursor: pointer;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--yellow);
  user-select: none;
}
.recent-section-header:hover { color: var(--text-primary); }
.recent-section-header .chevron {
  margin-right: 6px;
  font-size: 10px;
  transition: transform 0.15s;
  display: inline-block;
  width: 12px;
}
.recent-section.collapsed .chevron { transform: rotate(-90deg); }
.recent-section.collapsed .recent-items { display: none; }
.recent-section.collapsed .recent-clear-btn { display: none; }
.recent-clear-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 10px;
  padding: 1px 6px;
  border-radius: 3px;
  cursor: pointer;
  margin-left: auto;
  line-height: 1.4;
}
.recent-clear-btn:hover { color: var(--red); border-color: var(--red); }


/* ─── SPLIT PANE VIEW ──────────────────────────────────────────────────── */
.split-pane-wrapper { display: none; flex: 1; min-width: 0; min-height: 0; }
.split-pane-wrapper.active { display: flex; }
.split-pane-wrapper.active ~ #mainContent { display: none; }
.split-pane { flex: 1; min-width: 0; overflow-y: auto; padding: 32px 36px; position: relative; }
.split-pane .split-pane-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; padding-bottom: 10px; border-bottom: 1px solid var(--border); }
.split-pane .split-pane-title { font-size: 16px; font-weight: 700; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; min-width: 0; }
.split-pane .split-pane-close { background: none; border: 1px solid var(--border); color: var(--text-muted); font-size: 16px; cursor: pointer; padding: 2px 8px; border-radius: 4px; margin-left: 12px; flex-shrink: 0; line-height: 1; transition: color 0.15s, border-color 0.15s, background 0.15s; }
.split-pane .split-pane-close:hover { color: var(--red); border-color: var(--red); background: var(--bg-surface); }
.split-pane .split-pane-body { font-size: 15px; line-height: 1.7; color: var(--text-primary); }
.split-pane .split-pane-body h1 { font-size: 22px; margin: 24px 0 12px; color: var(--text-primary); }
.split-pane .split-pane-body h2 { font-size: 18px; margin: 20px 0 10px; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 4px; }
.split-pane .split-pane-body h3 { font-size: 15px; margin: 16px 0 8px; color: var(--peach); }
.split-pane .split-pane-body p { margin: 8px 0; }
.split-pane .split-pane-body ul, .split-pane .split-pane-body ol { margin: 8px 0 8px 24px; }
.split-pane .split-pane-body li { margin: 4px 0; }
.split-pane .split-pane-body em { color: var(--yellow); font-style: italic; }
.split-pane .split-pane-body strong { color: var(--text-primary); font-weight: 700; }
.split-pane .split-pane-body blockquote { border-left: 3px solid var(--accent); padding: 8px 16px; margin: 12px 0; background: var(--bg-surface); border-radius: 0 4px 4px 0; }
.split-pane .split-pane-body pre { background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 6px; padding: 16px; overflow-x: auto; margin: 12px 0; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 13px; line-height: 1.5; }
.split-pane .split-pane-body code { font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 13px; background: var(--bg-surface); padding: 1px 5px; border-radius: 3px; }
.split-pane .split-pane-body pre code { background: none; padding: 0; }
.split-pane .split-pane-body table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 13px; }
.split-pane .split-pane-body th, .split-pane .split-pane-body td { border: 1px solid var(--border); padding: 8px 12px; text-align: left; }
.split-pane .split-pane-body th { background: var(--bg-surface); font-weight: 600; }
.split-pane .split-pane-body a { color: var(--accent); }
.split-pane .split-pane-body a:hover { text-decoration: underline; }
.split-divider { width: 3px; background: var(--border); cursor: col-resize; flex-shrink: 0; position: relative; transition: background 0.15s; }
.split-divider:hover, .split-divider.dragging { background: var(--accent); }
.split-divider::after { content: ''; position: absolute; top: 0; bottom: 0; left: -4px; right: -4px; }
.split-picker-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 300; justify-content: center; align-items: flex-start; padding-top: 80px; }
.split-picker-overlay.active { display: flex; }
.split-picker-panel { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 10px; width: 440px; max-width: 90vw; max-height: 60vh; display: flex; flex-direction: column; box-shadow: 0 24px 64px rgba(0,0,0,0.4); }
.split-picker-header { padding: 14px 18px 10px; border-bottom: 1px solid var(--border); display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
.split-picker-header h3 { font-size: 14px; font-weight: 700; color: var(--text-primary); flex: 1; }
.split-picker-close { background: none; border: none; color: var(--text-muted); font-size: 20px; cursor: pointer; padding: 2px 6px; border-radius: 4px; line-height: 1; }
.split-picker-close:hover { color: var(--text-primary); background: var(--bg-hover); }
.split-picker-search { width: 100%; background: var(--bg-surface); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary); padding: 7px 12px; font-size: 13px; outline: none; }
.split-picker-search:focus { border-color: var(--accent); }
.split-picker-body { overflow-y: auto; padding: 8px 0; flex: 1; min-height: 0; }
.split-picker-group-label { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-muted); padding: 8px 18px 4px; }
.split-picker-item { display: flex; align-items: center; gap: 8px; padding: 8px 18px; cursor: pointer; font-size: 13px; color: var(--text-primary); transition: background 0.1s; }
.split-picker-item:hover { background: var(--bg-hover); }
.split-picker-item .spi-id { color: var(--accent); font-size: 11px; font-weight: 600; flex-shrink: 0; }
.split-picker-item .spi-title { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; min-width: 0; }
.split-picker-empty { padding: 16px 18px; color: var(--text-muted); font-size: 13px; text-align: center; }
.split-btn { position: relative; }
@media (max-width: 900px) { .split-btn { display: none !important; } .split-pane-wrapper { display: none !important; } }
body.light-theme .split-picker-overlay { background: rgba(0,0,0,0.3); }
body.light-theme .split-picker-panel { box-shadow: 0 24px 64px rgba(0,0,0,0.2); }
body.light-theme .split-pane .split-pane-body em { color: #92400e; }

/* FULLSCREEN / FOCUS MODE */
body.fullscreen-mode .sidebar {
  width: 0; min-width: 0; padding: 0; overflow: hidden;
  border-right-color: transparent; opacity: 0; pointer-events: none;
}
body.fullscreen-mode .backlinks-panel {
  width: 0; min-width: 0; padding: 0; overflow: hidden;
  border-left-color: transparent; opacity: 0; pointer-events: none;
}
body.fullscreen-mode .tab-bar {
  max-height: 0; min-height: 0; overflow: hidden; border-bottom: none; opacity: 0;
}
body.fullscreen-mode .main-content {
  padding: 48px 64px;
}
body.fullscreen-mode .reading-progress-bar {
  margin: -48px -64px 48px -64px;
}
body.fullscreen-mode .doc-viewer {
  max-width: 800px;
  margin: 0 auto;
}
body.fullscreen-mode .welcome {
  max-width: 800px;
}
body.fullscreen-mode #fullscreenToggle {
  background: var(--accent-dim);
  border-color: var(--accent);
  color: var(--accent);
}

/* Smooth transitions for fullscreen */
.sidebar {
  transition: width 0.3s ease, min-width 0.3s ease, opacity 0.25s ease,
              padding 0.3s ease, border-right-color 0.3s ease, transform 0.2s;
}
.backlinks-panel {
  transition: width 0.3s ease, min-width 0.3s ease, opacity 0.25s ease,
              padding 0.3s ease, border-left-color 0.3s ease;
}
.tab-bar {
  transition: max-height 0.3s ease, opacity 0.25s ease;
}
.main-content {
  transition: padding 0.3s ease;
}
.doc-viewer {
  transition: max-width 0.3s ease, margin 0.3s ease, opacity 0.15s ease;
}


/* ─── ZEN MODE ──────────────────────────────────────────────────────────── */
body.zen-mode .header,
body.zen-mode .tab-bar,
body.zen-mode .sidebar,
body.zen-mode .sidebar-overlay,
body.zen-mode .sidebar-resize-handle,
body.zen-mode .backlinks-panel,
body.zen-mode .doc-toolbar,
body.zen-mode .breadcrumb,
body.zen-mode .reading-progress-bar,
body.zen-mode .minimap-container,
body.zen-mode .status-bar,
body.zen-mode .scroll-to-top,
body.zen-mode .fullscreen-exit-hint,
body.zen-mode .doc-reading-info,
body.zen-mode .doc-link-tooltip,
body.zen-mode .find-bar,
body.zen-mode .floating-toc,
body.zen-mode .floating-toc-toggle,
body.zen-mode .batch-action-bar {
  display: none !important;
}
body.zen-mode .layout {
  height: 100vh;
}
body.zen-mode .main-content {
  padding: 80px 32px 120px;
  background: var(--bg-zen, var(--bg-primary));
}
body.zen-mode .doc-viewer {
  max-width: 680px;
  margin: 0 auto;
}
body.zen-mode .doc-body {
  font-size: 1.05em;
  line-height: 1.8;
}
body.zen-mode {
  --bg-zen: #1c1c2c;
}
body.zen-mode.light-theme {
  --bg-zen: #fafafa;
}
body.zen-mode::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 9999;
  background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.15) 100%);
}
body.zen-mode.light-theme::after {
  background: radial-gradient(ellipse at center, transparent 60%, rgba(0,0,0,0.06) 100%);
}
.zen-exit-btn {
  display: none;
  position: fixed;
  top: 16px; right: 16px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
  padding: 6px 14px;
  border-radius: 8px;
  font-size: 12px;
  font-family: inherit;
  cursor: pointer;
  z-index: 10000;
  opacity: 0;
  transition: opacity 0.3s ease, color 0.2s ease, border-color 0.2s ease;
  user-select: none;
  white-space: nowrap;
  box-shadow: 0 2px 12px rgba(0,0,0,0.3);
}
body.zen-mode .zen-exit-btn { display: block; }
.zen-exit-btn.visible { opacity: 1; }
.zen-exit-btn:hover { color: var(--text-primary); border-color: var(--accent); }
.zen-exit-btn .kbd { font-size: 10px; margin-left: 6px; }
body.zen-mode .doc-body { animation: zenFadeIn 0.4s ease; }
@keyframes zenFadeIn {
  from { opacity: 0.7; transform: translateY(8px); }
  to   { opacity: 1; transform: translateY(0); }
}

/* Floating exit hint */
.fullscreen-exit-hint {
  display: none;
  position: fixed;
  bottom: 36px;
  left: 50%;
  transform: translateX(-50%) translateY(8px);
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
  padding: 6px 16px;
  border-radius: 8px;
  font-size: 12px;
  z-index: 150;
  cursor: pointer;
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
  user-select: none;
}
.fullscreen-exit-hint:hover {
  color: var(--text-primary);
  border-color: var(--accent);
}
.fullscreen-exit-hint .kbd {
  font-size: 10px;
  margin-left: 6px;
}
body.fullscreen-mode .fullscreen-exit-hint {
  display: block;
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* Scrollbar */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--bg-secondary); }
::-webkit-scrollbar-thumb { background: var(--bg-hover); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

/* ─── BATCH SELECT MODE ──────────────────────────────────────────────────── */
.batch-checkbox {
  display: none;
  width: 16px;
  height: 16px;
  min-width: 16px;
  border: 2px solid var(--text-muted);
  border-radius: 4px;
  background: transparent;
  cursor: pointer;
  margin-right: 8px;
  position: relative;
  flex-shrink: 0;
  transition: border-color 0.15s ease, background-color 0.15s ease;
}
body.batch-mode .batch-checkbox {
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.batch-checkbox:hover { border-color: var(--accent); }
.batch-checkbox.checked {
  background: var(--accent);
  border-color: var(--accent);
}
.batch-checkbox.checked::after {
  content: '';
  display: block;
  width: 4px;
  height: 8px;
  border: solid var(--bg-tertiary);
  border-width: 0 2px 2px 0;
  transform: rotate(45deg) translate(-0.5px, -0.5px);
}
.batch-domain-checkbox {
  display: none;
  width: 14px;
  height: 14px;
  min-width: 14px;
  border: 2px solid var(--text-muted);
  border-radius: 3px;
  background: transparent;
  cursor: pointer;
  margin-right: 6px;
  position: relative;
  flex-shrink: 0;
  transition: border-color 0.15s ease, background-color 0.15s ease;
}
body.batch-mode .batch-domain-checkbox {
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.batch-domain-checkbox:hover { border-color: var(--accent); }
.batch-domain-checkbox.checked {
  background: var(--accent);
  border-color: var(--accent);
}
.batch-domain-checkbox.partial {
  border-color: var(--accent);
  background: transparent;
}
.batch-domain-checkbox.partial::after {
  content: '';
  display: block;
  width: 8px;
  height: 2px;
  background: var(--accent);
  border-radius: 1px;
}
.batch-domain-checkbox.checked::after {
  content: '';
  display: block;
  width: 3.5px;
  height: 7px;
  border: solid var(--bg-tertiary);
  border-width: 0 2px 2px 0;
  transform: rotate(45deg) translate(-0.5px, -0.5px);
}
body.batch-mode .sidebar-item.batch-selected {
  background: var(--accent-dim);
}
body.batch-mode .sidebar-item.batch-selected:hover {
  background: var(--accent-dim);
}
body.batch-mode .sidebar-item {
  padding-left: 12px;
}
.batch-action-bar {
  display: none;
  position: fixed;
  bottom: 32px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 10px 16px;
  z-index: 200;
  align-items: center;
  gap: 12px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  transition: opacity 0.2s ease, transform 0.2s ease;
  max-width: calc(100vw - 32px);
  flex-wrap: wrap;
  justify-content: center;
}
body.batch-mode .batch-action-bar { display: flex; }
body.light-theme .batch-action-bar {
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.08);
}
.batch-action-bar .batch-count {
  font-size: 13px;
  color: var(--text-secondary);
  white-space: nowrap;
  font-weight: 600;
}
.batch-action-bar .batch-count .count-num { color: var(--accent); }
.batch-action-bar .batch-separator {
  width: 1px;
  height: 20px;
  background: var(--border);
  flex-shrink: 0;
}
.batch-action-bar button {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  white-space: nowrap;
  font-family: inherit;
  transition: background-color 0.15s ease, color 0.15s ease, border-color 0.15s ease;
}
.batch-action-bar button:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}
.batch-action-bar button.batch-export-btn {
  background: var(--accent);
  color: var(--bg-tertiary);
  border-color: var(--accent);
  font-weight: 600;
}
.batch-action-bar button.batch-export-btn:hover { opacity: 0.9; }
.batch-action-bar button.batch-cancel-btn { color: var(--text-muted); }
.batch-action-bar button.batch-cancel-btn:hover {
  color: var(--red);
  border-color: var(--red);
}
body.batch-mode #batchSelectBtn {
  background: var(--accent-dim);
  border-color: var(--accent);
  color: var(--accent);
}
@media (max-width: 768px) {
  .batch-action-bar {
    bottom: 32px;
    left: 8px;
    right: 8px;
    transform: none;
    padding: 8px 12px;
    gap: 8px;
    border-radius: 10px;
  }
  .batch-action-bar button {
    min-height: 36px;
    padding: 6px 10px;
    font-size: 11px;
  }
  .batch-action-bar .batch-count {
    font-size: 12px;
    width: 100%;
    text-align: center;
  }
  .batch-action-bar .batch-separator { display: none; }
  body.batch-mode .sidebar-item { padding-left: 8px; }
  .batch-checkbox { width: 20px; height: 20px; min-width: 20px; }
  .batch-domain-checkbox { width: 18px; height: 18px; min-width: 18px; }
}

/* ─── PRINT STYLES ───────────────────────────────────────────────────────── */
@media print {
  /* Reset base colors for paper */
  * { color-adjust: exact; -webkit-print-color-adjust: exact; }
  html, body {
    background: #fff !important;
    color: #000 !important;
    height: auto !important;
    overflow: visible !important;
    font-size: 12pt;
  }

  /* Hide all chrome: sidebar, backlinks, toolbar, tabs, header, graph, overlays, status bar */
  .header,
  .tab-bar,
  .sidebar,
  .sidebar-overlay,
  .backlinks-panel,
  .doc-toolbar,
  .status-bar,
  .quick-open-overlay,
  .shortcuts-modal-overlay,
  .search-results,
  .local-graph,
  #localGraphTooltip,
  .hamburger,
  .welcome,
  .edit-area,
  .save-bar,
  .loading,
  .breadcrumb,
  .code-copy-btn,
  .doc-reading-info,
  .fullscreen-exit-hint,
  .reading-progress-bar,
  .minimap-container,
  .floating-toc,
  .floating-toc-toggle,
  .toast-container,
  .zen-exit-btn,
  .zen-btn,
  .batch-action-bar,
  .batch-checkbox,
  .batch-domain-checkbox,
  .split-pane-wrapper,
  .split-picker-overlay,
  .wordcloud-overlay ,
  .find-bar { display: none !important; }

  /* Layout: full width, no flex constraints */
  .layout {
    display: block !important;
    height: auto !important;
    overflow: visible !important;
  }
  .main-content {
    padding: 0 !important;
    overflow: visible !important;
    width: 100% !important;
    max-width: 100% !important;
  }
  .doc-viewer {
    display: block !important;
    max-width: 100% !important;
  }

  /* Doc header: show title and ID prominently at top of printed page */
  .doc-header {
    margin-bottom: 16pt !important;
    border-bottom: 2pt solid #000;
    padding-bottom: 10pt;
  }
  .doc-header h1 {
    font-size: 20pt !important;
    color: #000 !important;
    margin-bottom: 6pt !important;
  }
  .doc-meta {
    font-size: 10pt !important;
    color: #333 !important;
  }
  .doc-meta .badge {
    background: #eee !important;
    color: #333 !important;
    border: 1px solid #ccc;
    padding: 1pt 6pt;
  }

  /* Body text */
  .doc-body {
    font-size: 11pt !important;
    line-height: 1.6 !important;
    color: #000 !important;
  }
  .doc-body h1 {
    font-size: 18pt !important;
    color: #000 !important;
    margin: 18pt 0 8pt !important;
  }
  .doc-body h2 {
    font-size: 15pt !important;
    color: #000 !important;
    border-bottom: 1px solid #999 !important;
    padding-bottom: 3pt !important;
    margin: 14pt 0 7pt !important;
  }
  .doc-body h3 {
    font-size: 13pt !important;
    color: #222 !important;
    margin: 10pt 0 5pt !important;
  }
  .doc-body p { color: #000 !important; }
  .doc-body em { color: #000 !important; font-style: italic; }
  .doc-body strong { color: #000 !important; }
  .doc-body ul, .doc-body ol { color: #000 !important; }
  .doc-body li { color: #000 !important; }
  .doc-body blockquote {
    border-left: 3px solid #666 !important;
    background: #f5f5f5 !important;
    color: #000 !important;
    padding: 6pt 12pt !important;
  }

  /* Inline code */
  .doc-body code {
    background: #f0f0f0 !important;
    color: #000 !important;
    border: 1px solid #ddd;
    padding: 0pt 3pt;
    font-size: 9pt !important;
  }

  /* Code blocks: avoid page breaks inside, clean border */
  .doc-body pre {
    background: #f5f5f5 !important;
    color: #000 !important;
    border: 1px solid #ccc;
    padding: 10pt !important;
    border-radius: 0 !important;
    page-break-inside: avoid;
    break-inside: avoid;
    overflow-x: visible !important;
    white-space: pre-wrap !important;
    word-wrap: break-word !important;
  }
  .doc-body pre code {
    background: none !important;
    border: none !important;
    color: #000 !important;
  }

  /* Tables: avoid page breaks inside, clean borders */
  .doc-body table {
    page-break-inside: avoid;
    break-inside: avoid;
    border-collapse: collapse !important;
    width: 100% !important;
  }
  .doc-body th, .doc-body td {
    border: 1px solid #999 !important;
    padding: 5pt 8pt !important;
    font-size: 10pt !important;
    color: #000 !important;
  }
  .doc-body th {
    background: #e8e8e8 !important;
    font-weight: 700 !important;
    color: #000 !important;
  }

  /* Links: show URL after the link text */
  .doc-body a[href]::after {
    content: " (" attr(href) ")";
    font-size: 9pt;
    color: #555;
    font-style: italic;
    word-break: break-all;
  }
  /* Doc-link cross-references (onclick-based, no href) -- keep clean */
  a.doc-link::after { content: none !important; }
  a.doc-link { color: #000 !important; text-decoration: underline !important; }

  /* General link styling for print */
  a { color: #000 !important; text-decoration: underline !important; }

  /* Headings: avoid orphaned headings at bottom of page */
  .doc-body h1, .doc-body h2, .doc-body h3 {
    page-break-after: avoid;
    break-after: avoid;
  }

  /* Images: avoid breaking */
  .doc-body img {
    max-width: 100% !important;
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Page margins */
  @page {
    margin: 2cm;
  }
}

/* STATS DASHBOARD */
.stats-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.75);
  z-index: 500;
  backdrop-filter: blur(4px);
  overflow-y: auto;
}
.stats-overlay.active { display: block; }
.stats-dashboard {
  max-width: 900px;
  margin: 40px auto;
  padding: 32px 40px 48px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 24px 64px rgba(0, 0, 0, 0.6);
  position: relative;
}
.stats-dashboard-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 28px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 16px;
}
.stats-dashboard-header h2 {
  font-size: 18px;
  font-weight: 700;
  color: var(--accent);
  letter-spacing: 0.5px;
}
.stats-close-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 18px;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 6px;
  line-height: 1;
}
.stats-close-btn:hover { color: var(--text-primary); background: var(--bg-hover); }
.stats-summary {
  display: flex;
  gap: 24px;
  margin-bottom: 32px;
  flex-wrap: wrap;
}
.stats-card {
  flex: 1;
  min-width: 140px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px 20px;
  text-align: center;
}
.stats-card-num {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  line-height: 1.2;
}
.stats-card-label {
  font-size: 11px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: 4px;
}
.stats-section {
  margin-bottom: 28px;
}
.stats-section h3 {
  font-size: 13px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 12px;
}
.stats-bar-chart {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.stats-bar-row {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
}
.stats-bar-label {
  min-width: 160px;
  max-width: 200px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: right;
  flex-shrink: 0;
}
.stats-bar-track {
  flex: 1;
  height: 20px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}
.stats-bar-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.4s ease;
  min-width: 2px;
}
.stats-bar-value {
  min-width: 36px;
  color: var(--text-muted);
  font-size: 11px;
  font-family: 'SF Mono', 'Fira Code', monospace;
  text-align: right;
  flex-shrink: 0;
}
.stats-table {
  width: 100%;
  border-collapse: collapse;
}
.stats-table th {
  text-align: left;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.3px;
  padding: 6px 10px;
  border-bottom: 1px solid var(--border);
}
.stats-table td {
  padding: 6px 10px;
  font-size: 13px;
  border-bottom: 1px solid rgba(49, 50, 68, 0.5);
  color: var(--text-secondary);
}
.stats-table tr:hover td { background: var(--bg-surface); }
.stats-table .st-docid {
  color: var(--accent);
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
}
.stats-table .st-docid:hover { text-decoration: underline; }
.stats-table .st-num {
  text-align: right;
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 12px;
  color: var(--text-muted);
}
.stats-columns {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 28px;
}
@media (max-width: 768px) {
  .stats-dashboard { margin: 16px; padding: 20px; }
  .stats-columns { grid-template-columns: 1fr; }
  .stats-bar-label { min-width: 100px; max-width: 120px; }
}

/* SYNTAX HIGHLIGHTING */
.syn-keyword { color: var(--mauve); }
.syn-string { color: var(--green); }
.syn-comment { color: var(--overlay0, #6c7086); font-style: italic; }
.syn-number { color: var(--peach); }
.syn-tag { color: var(--red); }
.syn-attr { color: var(--yellow); }

/* DOCUMENT OUTLINE MINIMAP */
.minimap-container {
  position: absolute;
  top: 0;
  right: 0;
  width: 40px;
  height: 100%;
  z-index: 20;
  pointer-events: none;
  display: none;
}
.minimap-container.visible {
  display: block;
}
.minimap-container canvas {
  display: block;
  width: 100%;
  height: 100%;
  pointer-events: auto;
  cursor: pointer;
}
.minimap-viewport {
  position: absolute;
  left: 2px;
  right: 2px;
  background: rgba(137, 180, 250, 0.10);
  border: 1px solid rgba(137, 180, 250, 0.25);
  border-radius: 2px;
  pointer-events: none;
  transition: top 0.08s ease-out, height 0.08s ease-out;
}
@media (max-width: 768px) {
  .minimap-container { display: none !important; }
}
@media print {
  .minimap-container { display: none !important; }
}


/* TOAST NOTIFICATIONS */
.toast-container {
  position: fixed;
  bottom: 40px;
  right: 20px;
  z-index: 900;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  pointer-events: none;
  max-width: 380px;
  width: calc(100vw - 40px);
}
.toast {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 13px;
  line-height: 1.4;
  color: var(--text-primary);
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
  pointer-events: auto;
  transform: translateX(calc(100% + 20px));
  opacity: 0;
  animation: toast-slide-in 0.35s cubic-bezier(0.22, 1, 0.36, 1) forwards;
  overflow: hidden;
  word-break: break-word;
}
.toast.toast-dismissing {
  animation: toast-slide-out 0.3s cubic-bezier(0.55, 0, 1, 0.45) forwards;
}
.toast-icon {
  font-size: 16px;
  flex-shrink: 0;
  line-height: 1;
}
.toast-message {
  flex: 1;
  min-width: 0;
}
.toast.toast-success { border-left: 3px solid var(--green); }
.toast.toast-success .toast-icon { color: var(--green); }
.toast.toast-info { border-left: 3px solid var(--accent); }
.toast.toast-info .toast-icon { color: var(--accent); }
.toast.toast-warning { border-left: 3px solid var(--yellow); }
.toast.toast-warning .toast-icon { color: var(--yellow); }
.toast.toast-error { border-left: 3px solid var(--red); }
.toast.toast-error .toast-icon { color: var(--red); }

@keyframes toast-slide-in {
  from { transform: translateX(calc(100% + 20px)); opacity: 0; }
  to   { transform: translateX(0); opacity: 1; }
}
@keyframes toast-slide-out {
  from { transform: translateX(0); opacity: 1; }
  to   { transform: translateX(calc(100% + 20px)); opacity: 0; }
}

@media print {
  .toast-container { display: none !important; }
}

/* SIDEBAR RESIZE HANDLE */
.sidebar-resize-handle {
  width: 4px;
  cursor: col-resize;
  background: transparent;
  flex-shrink: 0;
  position: relative;
  z-index: 10;
  transition: background 0.15s ease;
}
.sidebar-resize-handle::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  width: 4px;
  height: 48px;
  transform: translateY(-50%);
  border-radius: 2px;
  background: transparent;
  transition: background 0.15s ease;
}
.sidebar-resize-handle:hover {
  background: var(--border);
}
.sidebar-resize-handle:hover::after {
  background: var(--text-muted);
}
body.sidebar-resizing .sidebar-resize-handle {
  background: var(--accent);
}
body.sidebar-resizing .sidebar-resize-handle::after {
  background: var(--accent);
}
body.sidebar-resizing {
  user-select: none;
  -webkit-user-select: none;
  cursor: col-resize;
}
body.sidebar-resizing .sidebar {
  transition: none;
}
body.fullscreen-mode .sidebar-resize-handle {
  display: none;
}
@media (max-width: 768px) {
  .sidebar-resize-handle {
    display: none;
  }
}

/* IMAGE ZOOM LIGHTBOX */
.doc-body img {
  cursor: zoom-in;
  transition: opacity 0.15s;
}
.doc-body img:hover {
  opacity: 0.85;
}
.lightbox-overlay {
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.25s ease, visibility 0.25s ease;
  cursor: zoom-out;
}
.lightbox-overlay.active {
  opacity: 1;
  visibility: visible;
}
.lightbox-img-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  max-width: 95vw;
  max-height: 85vh;
  overflow: hidden;
  cursor: default;
}
.lightbox-img-wrapper img {
  max-width: 95vw;
  max-height: 85vh;
  object-fit: contain;
  transform-origin: center center;
  transform: scale(0.9);
  transition: transform 0.25s ease;
  user-select: none;
  -webkit-user-drag: none;
  pointer-events: auto;
}
.lightbox-overlay.active .lightbox-img-wrapper img {
  transform: scale(1);
}
.lightbox-img-wrapper.zoomed {
  cursor: grab;
  overflow: visible;
}
.lightbox-img-wrapper.zoomed.dragging {
  cursor: grabbing;
}
.lightbox-img-wrapper.zoomed img {
  max-width: none;
  max-height: none;
  transition: none;
}
.lightbox-close {
  position: absolute;
  top: 16px;
  right: 20px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #fff;
  font-size: 24px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.15s, transform 0.15s;
  z-index: 10001;
  line-height: 1;
}
.lightbox-close:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.1);
}
.lightbox-caption {
  color: rgba(255, 255, 255, 0.8);
  font-size: 13px;
  text-align: center;
  padding: 10px 20px;
  max-width: 80vw;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  opacity: 0;
  transform: translateY(8px);
  transition: opacity 0.3s ease 0.1s, transform 0.3s ease 0.1s;
}
.lightbox-overlay.active .lightbox-caption {
  opacity: 1;
  transform: translateY(0);
}
.lightbox-zoom-hint {
  position: absolute;
  bottom: 60px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.45);
  font-size: 11px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease;
}
.lightbox-overlay.active .lightbox-zoom-hint {
  opacity: 1;
  transition-delay: 0.6s;
}
.lightbox-overlay.active .lightbox-zoom-hint.faded {
  opacity: 0;
  transition-delay: 0s;
}
@media print {
  .lightbox-overlay { display: none !important; }
  .doc-body img { cursor: default; }
}

/* ─── ACCESSIBILITY (A11Y) ───────────────────────────────────────────────── */

/* Skip navigation link */
.skip-link {
  position: absolute;
  top: -100%;
  left: 16px;
  z-index: 10000;
  background: var(--accent);
  color: var(--bg-tertiary);
  padding: 8px 16px;
  border-radius: 0 0 6px 6px;
  font-size: 14px;
  font-weight: 600;
  text-decoration: none;
  opacity: 0;
  pointer-events: none;
  transition: top 0.15s ease, opacity 0.15s ease;
}
.skip-link:focus {
  top: 0;
  opacity: 1;
  pointer-events: auto;
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

/* Focus-visible indicators for all interactive elements */
:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}
/* Remove default outline for mouse clicks */
:focus:not(:focus-visible) {
  outline: none;
}
/* Specific focus styles for inputs that had outline:none */
.search-box input:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -1px;
  border-color: var(--accent);
}
#quickOpenInput:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -1px;
}
.find-bar-input:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -1px;
  border-color: var(--accent);
}
.notes-textarea:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -1px;
  border-color: var(--accent);
}
.edit-area:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -1px;
}
/* Sidebar items focus */
.sidebar-item:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -2px;
  background: var(--bg-hover);
}
.sidebar-section-header:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -2px;
}
/* Tab focus */
.tab:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: -2px;
}
/* Button focus (header buttons, toolbar, etc.) */
.header-btn:focus-visible,
.theme-toggle:focus-visible,
.hamburger:focus-visible,
.favorite-btn:focus-visible,
.scroll-to-top:focus-visible,
.doc-toolbar button:focus-visible,
.find-bar-btn:focus-visible,
.filter-tag:focus-visible,
.clear-filter:focus-visible,
.backlink-item:focus-visible,
.tag-item:focus-visible,
.toc-item:focus-visible,
.search-result-item:focus-visible,
.quick-open-item:focus-visible,
.code-copy-btn:focus-visible,
.recent-clear-btn:focus-visible,
.notes-clear-btn:focus-visible,
.lightbox-close:focus-visible,
.stats-close-btn:focus-visible,
.shortcuts-modal-close:focus-visible,
.save-btn:focus-visible,
.cancel-btn:focus-visible {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

@media print {
  .skip-link { display: none !important; }
}

/* ─── FLOATING TABLE OF CONTENTS ─────────────────────────────────────────── */
.floating-toc {
  position: absolute;
  top: 80px;
  right: 52px;
  width: 220px;
  max-height: calc(100vh - 200px);
  overflow-y: auto;
  background: rgba(24, 24, 37, 0.78);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 14px 0;
  z-index: 40;
  opacity: 0;
  transform: translateX(12px);
  pointer-events: none;
  transition: opacity 0.25s ease, transform 0.25s ease;
  scrollbar-width: thin;
  scrollbar-color: var(--bg-hover) transparent;
}
body.light-theme .floating-toc {
  background: rgba(245, 245, 245, 0.82);
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
}
.floating-toc.visible {
  opacity: 1;
  transform: translateX(0);
  pointer-events: auto;
}
.floating-toc::-webkit-scrollbar { width: 4px; }
.floating-toc::-webkit-scrollbar-track { background: transparent; }
.floating-toc::-webkit-scrollbar-thumb { background: var(--bg-hover); border-radius: 2px; }
.floating-toc-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 14px 10px 14px;
  border-bottom: 1px solid var(--border);
  margin-bottom: 6px;
}
.floating-toc-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.floating-toc-close {
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: 16px;
  cursor: pointer;
  padding: 0 2px;
  line-height: 1;
  border-radius: 4px;
  transition: color 0.15s ease, background 0.15s ease;
}
.floating-toc-close:hover {
  color: var(--text-primary);
  background: var(--bg-hover);
}
.floating-toc-list {
  list-style: none;
  margin: 0;
  padding: 0;
}
.floating-toc-item {
  display: block;
  padding: 5px 14px 5px 14px;
  font-size: 12px;
  color: var(--text-secondary);
  cursor: pointer;
  border-left: 2px solid transparent;
  transition: color 0.15s ease, background 0.15s ease, border-color 0.15s ease;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  line-height: 1.4;
}
.floating-toc-item:hover {
  color: var(--text-primary);
  background: var(--bg-hover);
}
.floating-toc-item.active {
  color: var(--accent);
  border-left-color: var(--accent);
  background: var(--accent-dim);
}
.floating-toc-item[data-level="1"] { padding-left: 14px; font-weight: 600; font-size: 12.5px; }
.floating-toc-item[data-level="2"] { padding-left: 14px; }
.floating-toc-item[data-level="3"] { padding-left: 28px; font-size: 11.5px; }
.floating-toc-item[data-level="4"] { padding-left: 42px; font-size: 11px; color: var(--text-muted); }
.floating-toc-toggle {
  position: absolute;
  top: 80px;
  right: 12px;
  width: 36px;
  height: 36px;
  border-radius: 8px;
  background: rgba(24, 24, 37, 0.78);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  font-size: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 40;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.25s ease, background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}
body.light-theme .floating-toc-toggle {
  background: rgba(245, 245, 245, 0.88);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}
.floating-toc-toggle.visible {
  opacity: 1;
  pointer-events: auto;
}
.floating-toc-toggle:hover {
  color: var(--accent);
  border-color: var(--accent);
  background: var(--bg-surface);
}
.floating-toc-toggle.active {
  background: var(--accent-dim);
  border-color: var(--accent);
  color: var(--accent);
}
@media (max-width: 1200px) {
  .floating-toc {
    right: 12px;
    top: 124px;
    width: 240px;
    max-height: calc(100vh - 240px);
  }
  .floating-toc-toggle {
    top: 80px;
    right: 12px;
  }
}
body.fullscreen-mode .floating-toc {
  right: 24px;
  top: 80px;
}
body.fullscreen-mode .floating-toc-toggle {
  right: 24px;
}
@media print {
  .floating-toc,
  .floating-toc-toggle { display: none !important; }
}

/* ─── SEARCH HISTORY DROPDOWN ─────────────────────────────────────────────── */
.search-history-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 4px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.28), 0 2px 8px rgba(0, 0, 0, 0.12);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  z-index: 190;
  max-height: 320px;
  overflow-y: auto;
  display: none;
  opacity: 0;
  transform: translateY(-4px);
  transition: opacity 0.15s ease, transform 0.15s ease;
}
.search-history-dropdown.visible {
  display: block;
  opacity: 1;
  transform: translateY(0);
}
.search-history-dropdown::-webkit-scrollbar { width: 5px; }
.search-history-dropdown::-webkit-scrollbar-track { background: transparent; }
.search-history-dropdown::-webkit-scrollbar-thumb { background: var(--bg-hover); border-radius: 3px; }
.search-history-header {
  padding: 8px 12px 4px;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  user-select: none;
}
.search-history-item {
  display: flex;
  align-items: center;
  padding: 7px 12px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text-primary);
  transition: background-color 0.1s ease;
  gap: 8px;
}
.search-history-item:hover,
.search-history-item.selected {
  background: var(--bg-hover);
}
.search-history-item .sh-icon {
  color: var(--text-muted);
  font-size: 12px;
  flex-shrink: 0;
  width: 16px;
  text-align: center;
}
.search-history-item .sh-text {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.search-history-item .sh-remove {
  color: var(--text-muted);
  font-size: 14px;
  padding: 2px 4px;
  border-radius: 4px;
  line-height: 1;
  opacity: 0;
  transition: opacity 0.1s ease, color 0.1s ease, background-color 0.1s ease;
  flex-shrink: 0;
}
.search-history-item:hover .sh-remove,
.search-history-item.selected .sh-remove {
  opacity: 1;
}
.search-history-item .sh-remove:hover {
  color: var(--red);
  background: rgba(243, 139, 168, 0.1);
}
.search-history-clear {
  display: block;
  padding: 8px 12px;
  font-size: 12px;
  color: var(--text-muted);
  text-align: center;
  cursor: pointer;
  border-top: 1px solid var(--border);
  transition: color 0.1s ease, background-color 0.1s ease;
  user-select: none;
}
.search-history-clear:hover {
  color: var(--red);
  background: var(--bg-hover);
}
.search-history-empty {
  padding: 16px 12px;
  font-size: 12px;
  color: var(--text-muted);
  text-align: center;
  font-style: italic;
}
body.light-theme .search-history-dropdown {
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), 0 2px 8px rgba(0, 0, 0, 0.06);
}
body.light-theme .search-history-item .sh-remove:hover {
  background: rgba(220, 38, 38, 0.1);
}

/* SHARED HIGHLIGHT */
.shared-highlight {
  background: rgba(249, 226, 175, 0.35);
  border-radius: 2px;
  padding: 1px 0;
  animation: highlight-pulse 2s ease-out;
}
@keyframes highlight-pulse {
  0%   { background: rgba(249, 226, 175, 0.7); box-shadow: 0 0 12px rgba(249, 226, 175, 0.6); }
  40%  { background: rgba(249, 226, 175, 0.55); box-shadow: 0 0 8px rgba(249, 226, 175, 0.4); }
  100% { background: rgba(249, 226, 175, 0.2); box-shadow: none; }
}
.shared-highlight.settled {
  animation: none;
  background: rgba(249, 226, 175, 0.15);
}
body.light-theme .shared-highlight {
  background: rgba(202, 138, 4, 0.25);
  animation: highlight-pulse-light 2s ease-out;
}
@keyframes highlight-pulse-light {
  0%   { background: rgba(202, 138, 4, 0.45); box-shadow: 0 0 12px rgba(202, 138, 4, 0.35); }
  40%  { background: rgba(202, 138, 4, 0.35); box-shadow: 0 0 8px rgba(202, 138, 4, 0.2); }
  100% { background: rgba(202, 138, 4, 0.12); box-shadow: none; }
}
body.light-theme .shared-highlight.settled {
  animation: none;
  background: rgba(202, 138, 4, 0.1);
}

/* TEXT SHARE BUTTON */
.text-share-btn {
  position: absolute;
  z-index: 300;
  display: none;
  align-items: center;
  gap: 5px;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 12px;
  font-family: inherit;
  cursor: pointer;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
  white-space: nowrap;
  transition: background-color 0.15s ease, border-color 0.15s ease;
  line-height: 1.4;
}
.text-share-btn:hover {
  background: var(--bg-hover);
  border-color: var(--accent);
}
.text-share-btn.visible {
  display: flex;
}
body.light-theme .text-share-btn {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
}

@media print {
  .text-share-btn { display: none !important; }
  .shared-highlight { background: rgba(249, 226, 175, 0.2); box-shadow: none; animation: none; }
}

/* ─── WORD CLOUD MODAL ────────────────────────────────────────────────────── */
.wordcloud-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.75);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
}
.wordcloud-overlay.active { display: flex; }
.wordcloud-panel {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  width: 680px;
  max-width: calc(100vw - 32px);
  max-height: calc(100vh - 64px);
  overflow: hidden;
  box-shadow: 0 24px 64px rgba(0, 0, 0, 0.6);
  display: flex;
  flex-direction: column;
}
.wordcloud-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 18px 24px 14px;
  border-bottom: 1px solid var(--border);
  gap: 12px;
}
.wordcloud-header h2 {
  font-size: 15px;
  font-weight: 700;
  color: var(--text-primary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  flex: 1;
}
.wordcloud-header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}
.wordcloud-scope-toggle {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  font-size: 11px;
  padding: 4px 10px;
  border-radius: 4px;
  cursor: pointer;
  white-space: nowrap;
}
.wordcloud-scope-toggle:hover { background: var(--bg-hover); color: var(--text-primary); }
.wordcloud-scope-toggle.active { color: var(--accent); border-color: var(--accent); }
.wordcloud-close {
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: 20px;
  cursor: pointer;
  line-height: 1;
  padding: 2px 6px;
  border-radius: 4px;
}
.wordcloud-close:hover { color: var(--text-primary); background: var(--bg-hover); }
.wordcloud-body {
  padding: 20px 24px 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}
.wordcloud-canvas {
  display: block;
  max-width: 100%;
  border-radius: 6px;
}
.wordcloud-tooltip {
  position: fixed;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 4px 10px;
  border-radius: 5px;
  font-size: 12px;
  pointer-events: none;
  z-index: 1001;
  display: none;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  white-space: nowrap;
}
.wordcloud-empty {
  color: var(--text-muted);
  font-size: 13px;
  padding: 40px 0;
  text-align: center;
}
body.light-theme .wordcloud-overlay { background: rgba(0, 0, 0, 0.35); }
body.light-theme .wordcloud-panel { box-shadow: 0 24px 64px rgba(0, 0, 0, 0.2); }
@media (max-width: 768px) {
  .wordcloud-panel { width: calc(100vw - 16px); max-height: calc(100vh - 32px); }
  .wordcloud-header { padding: 14px 16px 10px; }
  .wordcloud-body { padding: 12px 16px 16px; }
}
@media print {
  .wordcloud-overlay { display: none !important; }
}

/* FIND IN DOCUMENT */
.find-bar {
  position: sticky;
  top: 0;
  left: 0;
  right: 0;
  z-index: 80;
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  background: var(--bg-tertiary);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
  animation: findBarSlideDown 0.18s ease-out;
  font-size: 13px;
}
.find-bar.hidden { display: none; }
@keyframes findBarSlideDown {
  from { opacity: 0; transform: translateY(-100%); }
  to   { opacity: 1; transform: translateY(0); }
}
.find-bar-input {
  flex: 1;
  min-width: 120px;
  max-width: 320px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 5px;
  color: var(--text-primary);
  padding: 5px 10px;
  font-size: 13px;
  font-family: inherit;
  outline: none;
  transition: border-color 0.15s ease;
}
.find-bar-input:focus { border-color: var(--accent); }
.find-bar-input::placeholder { color: var(--text-muted); }
.find-bar-count {
  color: var(--text-secondary);
  font-size: 12px;
  min-width: 60px;
  text-align: center;
  white-space: nowrap;
  user-select: none;
}
.find-bar-count.no-results { color: var(--red); }
.find-bar-btn {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  width: 28px;
  height: 28px;
  border-radius: 5px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  line-height: 1;
  transition: background-color 0.15s ease, border-color 0.15s ease;
  flex-shrink: 0;
}
.find-bar-btn:hover { background: var(--bg-hover); }
.find-bar-btn:active { background: var(--accent-dim); }
.find-bar-btn:disabled { opacity: 0.35; cursor: default; }
.find-bar-close { font-size: 18px; margin-left: 2px; }
.find-match {
  background: rgba(249, 226, 175, 0.35);
  color: inherit;
  border-radius: 2px;
  box-shadow: 0 0 0 1px rgba(249, 226, 175, 0.25);
}
.find-match-current {
  background: rgba(250, 179, 135, 0.6);
  color: inherit;
  border-radius: 2px;
  box-shadow: 0 0 0 2px var(--peach);
}
body.light-theme .find-match {
  background: rgba(202, 138, 4, 0.18);
  box-shadow: 0 0 0 1px rgba(202, 138, 4, 0.2);
}
body.light-theme .find-match-current {
  background: rgba(234, 88, 12, 0.3);
  box-shadow: 0 0 0 2px rgba(234, 88, 12, 0.5);
}
@media print {
  .find-bar { display: none !important; }
  .find-match, .find-match-current { background: none !important; box-shadow: none !important; }
}
</style>
<script>
// Apply saved theme immediately to avoid flash of wrong theme
(function() {
  var saved = localStorage.getItem('holm-theme');
  if (saved === 'light') {
    document.documentElement.style.background = '#ffffff';
    document.documentElement.style.colorScheme = 'light';
  }
})();

// ─── SIDEBAR RESIZE (DRAG HANDLE) ──────────────────────────────────────────
(function() {
  const SIDEBAR_WIDTH_KEY = 'holm-sidebar-width';
  const MIN_WIDTH = 180;
  const MAX_WIDTH = 500;
  const handle = document.getElementById('sidebarResizeHandle');
  const sidebar = document.getElementById('sidebar');

  // Restore saved width on load
  const savedWidth = localStorage.getItem(SIDEBAR_WIDTH_KEY);
  if (savedWidth) {
    const w = Math.min(MAX_WIDTH, Math.max(MIN_WIDTH, parseInt(savedWidth, 10)));
    document.documentElement.style.setProperty('--sidebar-width', w + 'px');
  }

  let isDragging = false;
  let startX = 0;
  let startWidth = 0;

  function getStartWidth() {
    return sidebar.getBoundingClientRect().width;
  }

  function onDragStart(clientX) {
    isDragging = true;
    startX = clientX;
    startWidth = getStartWidth();
    document.body.classList.add('sidebar-resizing');
  }

  function onDragMove(clientX) {
    if (!isDragging) return;
    const delta = clientX - startX;
    const newWidth = Math.min(MAX_WIDTH, Math.max(MIN_WIDTH, startWidth + delta));
    document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
  }

  function onDragEnd() {
    if (!isDragging) return;
    isDragging = false;
    document.body.classList.remove('sidebar-resizing');
    // Save current width
    const currentWidth = sidebar.getBoundingClientRect().width;
    localStorage.setItem(SIDEBAR_WIDTH_KEY, Math.round(currentWidth));
  }

  // Mouse events
  handle.addEventListener('mousedown', function(e) {
    e.preventDefault();
    onDragStart(e.clientX);
  });

  document.addEventListener('mousemove', function(e) {
    if (!isDragging) return;
    e.preventDefault();
    onDragMove(e.clientX);
  });

  document.addEventListener('mouseup', function(e) {
    onDragEnd();
  });

  // Touch events for tablet support
  handle.addEventListener('touchstart', function(e) {
    if (e.touches.length !== 1) return;
    e.preventDefault();
    onDragStart(e.touches[0].clientX);
  }, { passive: false });

  document.addEventListener('touchmove', function(e) {
    if (!isDragging) return;
    if (e.touches.length !== 1) return;
    e.preventDefault();
    onDragMove(e.touches[0].clientX);
  }, { passive: false });

  document.addEventListener('touchend', function(e) {
    onDragEnd();
  });

  document.addEventListener('touchcancel', function(e) {
    onDragEnd();
  });
})();

</script>
<script>
// Early accent color restoration to prevent flash
(function() {
  var savedAccent = localStorage.getItem('holm-accent-color');
  if (savedAccent) {
    var isLight = localStorage.getItem('holm-theme') === 'light';
    var r = parseInt(savedAccent.slice(1, 3), 16);
    var g = parseInt(savedAccent.slice(3, 5), 16);
    var b = parseInt(savedAccent.slice(5, 7), 16);
    var dim = isLight
      ? 'rgba(' + r + ',' + g + ',' + b + ',0.1)'
      : 'rgba(' + r + ',' + g + ',' + b + ',0.18)';
    document.documentElement.style.setProperty('--accent', savedAccent);
    document.documentElement.style.setProperty('--accent-dim', dim);
  }
})();
</script>
</head>
<body>

<!-- SKIP NAVIGATION -->
<a class="skip-link" href="#mainContent">Skip to main content</a>

<!-- HEADER -->
<div class="header" role="banner">
  <button class="hamburger" onclick="toggleSidebar()" aria-label="Toggle sidebar menu">☰</button>
  <div class="header-brand">HOLM VAULT</div>
  <div class="search-box" role="search" aria-label="Search documents">
    <input type="text" id="searchInput" placeholder="Search docs... (Cmd+K)" autocomplete="off" aria-label="Search documents">
    <div class="search-results" id="searchResults" aria-live="polite" role="listbox" aria-label="Search results"></div>
    <div class="search-history-dropdown" id="searchHistoryDropdown"></div>
  </div>
  <div class="header-actions">
    <div class="accent-picker-wrapper" id="accentPickerWrapper">
      <button class="accent-picker-btn" id="accentPickerBtn" title="Accent color" aria-label="Change accent color">
        <span class="accent-swatch-preview" id="accentSwatchPreview"></span>
        <span class="accent-picker-label">Accent</span>
      </button>
      <div class="accent-popover" id="accentPopover">
        <div class="accent-popover-title">Accent Color</div>
        <div class="accent-swatches" id="accentSwatches"></div>
        <div class="accent-popover-divider"></div>
        <div class="accent-custom-row">
          <label>Custom</label>
          <input type="color" id="accentCustomColor" value="#89b4fa">
          <span class="accent-hex-value" id="accentHexValue">#89b4fa</span>
        </div>
        <div class="accent-popover-divider"></div>
        <button class="accent-reset-btn" id="accentResetBtn">Reset to default</button>
      </div>
    </div>
    <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle light/dark theme" aria-label="Toggle light/dark theme">☾</button>
    <button class="header-btn" id="batchSelectBtn" onclick="toggleBatchMode()" title="Batch select documents" aria-label="Batch select documents"><span class="graph-label">Select </span>&#x2611;</button>
    <button class="header-btn" onclick="window.open('/graph.html','_blank')" aria-label="Open graph view"><span class="graph-label">Graph </span>⬡</button>
    <button class="header-btn" id="statsBtn" onclick="openStatsDashboard()" title="Domain Statistics" aria-label="Open domain statistics"><span class="graph-label">Stats </span>&#x25A4;</button>
    <button class="header-btn" id="backlinkToggle" onclick="toggleBacklinks()" aria-label="Toggle backlinks panel">◫</button>
    <button class="header-btn" id="fullscreenToggle" onclick="toggleFullscreen()" title="Focus mode (Cmd+Shift+F)" aria-label="Toggle focus mode">&#x26F6;</button>
    <button class="header-btn" onclick="showShortcutsModal()" aria-label="Show keyboard shortcuts">?</button>
  </div>
</div>

<!-- TAB BAR -->
<div class="tab-bar" id="tabBar" role="tablist" aria-label="Open documents"></div>

<!-- LAYOUT -->
<div class="layout">
  <div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>

  <!-- SIDEBAR -->
  <div class="sidebar" id="sidebar" role="navigation" aria-label="Document sidebar">
    <div id="sidebarContent">
      <div class="loading"><div class="spinner"></div>Loading...</div>
    </div>
    <div class="doc-count" id="docCount"></div>
  </div>

  <!-- SIDEBAR RESIZE HANDLE -->
  <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>

  <!-- SPLIT PANE WRAPPER -->
  <div class="split-pane-wrapper" id="splitPaneWrapper">
    <div class="split-pane" id="splitPaneLeft">
      <div class="split-pane-header">
        <span class="split-pane-title" id="splitLeftTitle"></span>
        <button class="split-pane-close" onclick="closeSplitPane('left')" title="Close pane" aria-label="Close left pane">&times;</button>
      </div>
      <div class="split-pane-body" id="splitLeftBody"></div>
    </div>
    <div class="split-divider" id="splitDivider"></div>
    <div class="split-pane" id="splitPaneRight">
      <div class="split-pane-header">
        <span class="split-pane-title" id="splitRightTitle"></span>
        <button class="split-pane-close" onclick="closeSplitPane('right')" title="Close pane" aria-label="Close right pane">&times;</button>
      </div>
      <div class="split-pane-body" id="splitRightBody"></div>
    </div>
  </div>

  <!-- MAIN CONTENT -->
  <div class="main-content" id="mainContent" role="main" aria-label="Document content">
    <div class="reading-progress-bar" id="readingProgressBar"></div>
    <div class="welcome" id="welcome">
      <h1>HOLM VAULT</h1>
      <p>The holm.chat Documentation Institution — an Obsidian-like knowledge explorer backed by MongoDB.</p>
      <p style="margin-top:8px;color:var(--text-muted)">Select a document from the sidebar, use search, or press <kbd class="kbd">Cmd</kbd><kbd class="kbd">K</kbd> to begin.</p>
      <div class="stats" id="welcomeStats"></div>
    </div>
    <div class="doc-viewer" id="docViewer">
      <div class="breadcrumb" id="breadcrumb">
        <span class="bc-vault">HOLM Vault</span>
        <span class="bc-separator">&#8250;</span>
        <span class="bc-domain" id="bcDomain"></span>
        <span class="bc-separator">&#8250;</span>
        <span class="bc-current" id="bcDocId"></span>
      </div>
      <div class="doc-header">
        <h1 id="docTitle" tabindex="-1"></h1>
        <div class="doc-badges" id="docBadges"></div>
        <div class="doc-meta" id="docMeta"></div>
        <div class="doc-reading-info" id="docReadingInfo"></div>
      </div>
      <div class="doc-toolbar">
        <button class="nav-btn" id="btnNavBack" onclick="navBack()" title="Back (Alt+Left)" aria-label="Navigate back" disabled>&#x2190;</button>
        <button class="nav-btn" id="btnNavForward" onclick="navForward()" title="Forward (Alt+Right)" aria-label="Navigate forward" disabled>&#x2192;</button>
        <div class="nav-separator"></div>
        <button class="active" onclick="setViewMode('preview')" id="btnPreview">Preview</button>
        <button onclick="setViewMode('edit')" id="btnEdit">Edit</button>
        <button onclick="setViewMode('raw')" id="btnRaw">Raw HTML</button>
        <button class="favorite-btn" id="favoriteBtn" onclick="toggleFavorite()" title="Toggle favorite" aria-label="Toggle favorite">&#9734;</button>
        <button onclick="exportAsMarkdown()" title="Export as Markdown">&#x2913; Export</button>
        <button onclick="openWordCloud()" title="Word Cloud">&#x2601; Cloud</button>
        <button class="zen-btn" onclick="toggleZenMode()" title="Zen mode (Cmd+Shift+Z)">&#x1F9D8; Zen</button>
        <button class="split-btn" id="splitBtn" onclick="openSplitPicker()" title="Split view (Cmd+Shift+S)">&#x2ACD; Split</button>
      </div>
      <!-- FIND IN DOCUMENT BAR -->
      <div class="find-bar hidden" id="findBar">
        <input type="text" class="find-bar-input" id="findInput" placeholder="Find in document..." autocomplete="off" spellcheck="false" aria-label="Find in document">
        <span class="find-bar-count" id="findCount" aria-live="polite"></span>
        <button class="find-bar-btn" id="findPrev" title="Previous match (Shift+Enter)" aria-label="Previous match" disabled>&#x2191;</button>
        <button class="find-bar-btn" id="findNext" title="Next match (Enter)" aria-label="Next match" disabled>&#x2193;</button>
        <button class="find-bar-btn find-bar-close" id="findClose" title="Close (Esc)" aria-label="Close find bar">&times;</button>
      </div>
            <div class="doc-body" id="docBody"></div>
      <textarea class="edit-area" id="editArea" aria-label="Edit document source"></textarea>
      <div class="save-bar" id="saveBar">
        <button class="save-btn" onclick="saveDoc()">Save</button>
        <button class="cancel-btn" onclick="setViewMode('preview')">Cancel</button>
      </div>
    </div>
    <button class="scroll-to-top" id="scrollToTop" title="Scroll to top" aria-label="Scroll to top">&#x2191;</button>
    <!-- FLOATING TABLE OF CONTENTS -->
    <div class="floating-toc" id="floatingToc">
      <div class="floating-toc-header">
        <span class="floating-toc-title">On this page</span>
        <button class="floating-toc-close" onclick="toggleFloatingToc()" title="Hide TOC (Cmd+Shift+T)" aria-label="Hide table of contents">&times;</button>
      </div>
      <div class="floating-toc-list" id="floatingTocList"></div>
    </div>
    <button class="floating-toc-toggle" id="floatingTocToggle" onclick="toggleFloatingToc()" title="Table of Contents (Cmd+Shift+T)" aria-label="Toggle table of contents">&#x2630;</button>
    <!-- DOCUMENT OUTLINE MINIMAP -->
    <div class="minimap-container" id="minimapContainer">
      <canvas id="minimapCanvas"></canvas>
      <div class="minimap-viewport" id="minimapViewport"></div>
    </div>
  </div>

  <!-- BACKLINKS PANEL -->
  <div class="backlinks-panel" id="backlinksPanel" role="complementary" aria-label="Backlinks and metadata">
    <div class="local-graph" id="localGraphContainer">
      <canvas id="localGraphCanvas"></canvas>
    </div>
    <div id="localGraphTooltip"></div>
    <div class="backlinks-section toc-section">
      <h3>Contents</h3>
      <div id="tocList"></div>
    </div>
    <div class="backlinks-section">
      <h3>Depends On</h3>
      <div id="dependsOnList"></div>
    </div>
    <div class="backlinks-section">
      <h3>Depended Upon By</h3>
      <div id="dependedByList"></div>
    </div>
    <div class="backlinks-section">
      <h3>Tags</h3>
      <div id="tagsList"></div>
    </div>
    <div class="backlinks-section notes-section" id="notesSection">
      <h3>My Notes <span class="notes-count" id="notesCount"></span></h3>
      <textarea class="notes-textarea" id="notesTextarea" rows="3" placeholder="Add a personal note for this document..." aria-label="Personal notes for this document"></textarea>
      <div class="notes-actions">
        <button class="notes-clear-btn" id="notesClearBtn" onclick="clearCurrentNote()">Clear note</button>
        <span class="notes-saved-indicator" id="notesSavedIndicator">Saved</span>
      </div>
    </div>
    <div class="backlinks-section related-section" id="relatedSection">
      <h3 onclick="document.getElementById('relatedSection').classList.toggle('collapsed')"><span class="related-chevron">&#9660;</span> <span id="relatedHeader">Related</span></h3>
      <div class="related-list" id="relatedList"></div>
    </div>
  </div>
</div>

<!-- DOC LINK PREVIEW TOOLTIP -->
<div class="doc-link-tooltip" id="docLinkTooltip">
  <div class="doc-link-tooltip-id" id="tooltipDocId"></div>
  <div class="doc-link-tooltip-title" id="tooltipTitle"></div>
  <div class="doc-link-tooltip-domain" id="tooltipDomain"></div>
  <div class="doc-link-tooltip-excerpt" id="tooltipExcerpt"></div>
  <div class="doc-link-tooltip-tags" id="tooltipTags"></div>
</div>

<!-- FULLSCREEN EXIT HINT -->
<div class="fullscreen-exit-hint" id="fullscreenExitHint" onclick="toggleFullscreen()" role="button" tabindex="0" aria-label="Exit focus mode" onkeydown="if(event.key==='Enter')toggleFullscreen()">
  Exit focus mode <span class="kbd">Esc</span>
</div>


<!-- ZEN MODE EXIT BUTTON -->
<button class="zen-exit-btn" id="zenExitBtn" onclick="toggleZenMode()" aria-label="Exit zen mode">
  Exit Zen <span class="kbd">Esc</span>
</button>

<!-- TOAST NOTIFICATIONS -->
<div class="toast-container" id="toastContainer"></div>
<!-- TEXT SHARE BUTTON -->
<button class="text-share-btn" id="textShareBtn" title="Copy link to selected text">&#128279; Share</button>


<!-- STATUS BAR -->
<div class="status-bar" role="status" aria-label="Document status">
  <span id="statusDocs">0 docs</span>
  <span id="statusDomain"></span>
  <span id="statusUpdated"></span>
</div>

<!-- QUICK OPEN -->
<div class="quick-open-overlay" id="quickOpen" style="display:none" role="dialog" aria-label="Quick open document" aria-modal="true">
  <div class="quick-open-panel">
    <input type="text" id="quickOpenInput" placeholder="Type to search docs..." autocomplete="off" spellcheck="false" aria-label="Quick open document search">
    <div class="quick-open-results" id="quickOpenResults"></div>
    <div class="quick-open-hint">
      <span><kbd>↑</kbd><kbd>↓</kbd> navigate</span>
      <span><kbd>↵</kbd> open</span>
      <span><kbd>Esc</kbd> close</span>
      <span><kbd>⌘K</kbd> toggle</span>
    </div>
  </div>
</div>

<!-- KEYBOARD SHORTCUTS MODAL -->
<!-- SPLIT PICKER -->
<div class="split-picker-overlay" id="splitPickerOverlay" onclick="closeSplitPickerOnOverlay(event)">
  <div class="split-picker-panel">
    <div class="split-picker-header">
      <h3>Open in Split View</h3>
      <button class="split-picker-close" onclick="closeSplitPicker()" aria-label="Close split picker">&times;</button>
      <input class="split-picker-search" id="splitPickerSearch" type="text" placeholder="Search documents..." autocomplete="off">
    </div>
    <div class="split-picker-body" id="splitPickerBody"></div>
  </div>
</div>

<div class="shortcuts-modal-overlay" id="shortcutsModal" onclick="closeShortcutsModal(event)" role="dialog" aria-label="Keyboard shortcuts" aria-modal="true">
  <div class="shortcuts-modal">
    <div class="shortcuts-modal-header">
      <h2>Keyboard Shortcuts</h2>
      <button class="shortcuts-modal-close" onclick="hideShortcutsModal()" aria-label="Close keyboard shortcuts">&times;</button>
    </div>
    <div class="shortcuts-modal-body">
      <div class="shortcuts-group">
        <div class="shortcuts-group-label">Navigation</div>
        <table class="shortcuts-table">
          <tr><td>Quick open</td><td><span class="kbd">Cmd</span><span class="kbd">K</span></td></tr>
          <tr><td>Graph view</td><td><span class="kbd">Cmd</span><span class="kbd">G</span></td></tr>
          <tr><td>Previous document</td><td><span class="kbd">Alt</span><span class="kbd">↑</span></td></tr>
          <tr><td>Next document</td><td><span class="kbd">Alt</span><span class="kbd">↓</span></td></tr>
          <tr><td>History back</td><td><span class="kbd">Alt</span><span class="kbd">←</span></td></tr>
          <tr><td>History forward</td><td><span class="kbd">Alt</span><span class="kbd">→</span></td></tr>
        </table>
      </div>
      <div class="shortcuts-group">
        <div class="shortcuts-group-label">View</div>
        <table class="shortcuts-table">
          <tr><td>Toggle sidebar</td><td><span class="kbd">Cmd</span><span class="kbd">\</span></td></tr>
          <tr><td>Toggle backlinks</td><td><span class="kbd">Cmd</span><span class="kbd">B</span></td></tr>
          <tr><td>Focus mode</td><td><span class="kbd">Cmd</span><span class="kbd">Shift</span><span class="kbd">F</span></td></tr>
          <tr><td>Toggle floating TOC</td><td><span class="kbd">Cmd</span><span class="kbd">Shift</span><span class="kbd">T</span></td></tr>
          <tr><td>Zen mode</td><td><span class="kbd">Cmd</span><span class="kbd">Shift</span><span class="kbd">Z</span></td></tr>
          <tr><td>Split view</td><td><span class="kbd">Cmd</span><span class="kbd">Shift</span><span class="kbd">S</span></td></tr>
                  <tr><td>Find in document</td><td><span class="kbd">Cmd</span><span class="kbd">F</span></td></tr>
        </table>
      </div>
      <div class="shortcuts-group">
        <div class="shortcuts-group-label">Editing</div>
        <table class="shortcuts-table">
          <tr><td>Toggle edit mode</td><td><span class="kbd">Cmd</span><span class="kbd">E</span></td></tr>
          <tr><td>Save</td><td><span class="kbd">Cmd</span><span class="kbd">S</span></td></tr>
        </table>
      </div>
      <div class="shortcuts-group">
        <div class="shortcuts-group-label">General</div>
        <table class="shortcuts-table">
          <tr><td>Show shortcuts</td><td><span class="kbd">?</span></td></tr>
          <tr><td>Close / cancel</td><td><span class="kbd">Esc</span></td></tr>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
// ─── STATE ──────────────────────────────────────────────────────────────────
let allDocs = [];
let currentDoc = null;
let viewMode = 'preview';
let backlinksPanelOpen = window.innerWidth > 768;
let docsById = {};
let activeTagFilter = null;
let sidebarSortMode = (function() { try { return localStorage.getItem("holm-sidebar-sort") || "id"; } catch(e) { return "id"; } })();
let openTabs = [];
let pinnedTabIds = new Set();
const PINNED_TABS_KEY = 'holm-pinned-tabs';
let navHistory = [];
let navHistoryPos = -1;
let navIsTraversing = false;
const NAV_HISTORY_MAX = 50;

const DOMAIN_COLORS = {
  '1': '#89b4fa', '2': '#a6e3a1', '3': '#f38ba8', '4': '#fab387',
  '5': '#cba6f7', '6': '#94e2d5', '7': '#f9e2af', '8': '#f5c2e7',
  '9': '#89dceb', '10': '#b4befe', '11': '#74c7ec', '12': '#f38ba8',
  '13': '#a6e3a1', '14': '#fab387', '15': '#cba6f7', '16': '#94e2d5',
  '17': '#f9e2af', '18': '#f5c2e7', '19': '#89dceb', '20': '#b4befe',
  'META': '#6c7086', 'FW': '#585b70', 'HIC': '#74c7ec'
};

// ─── TOAST NOTIFICATIONS ────────────────────────────────────────────────────
const TOAST_ICONS = {
  success: '\u2714',
  info: '\u24D8',
  warning: '\u26A0',
  error: '\u2716'
};
const TOAST_MAX = 4;

function showToast(message, type) {
  type = type || 'info';
  const container = document.getElementById('toastContainer');
  if (!container) return;

  const toasts = container.querySelectorAll('.toast:not(.toast-dismissing)');
  if (toasts.length >= TOAST_MAX) {
    dismissToast(toasts[toasts.length - 1]);
  }

  const el = document.createElement('div');
  el.className = 'toast toast-' + type;
  el.innerHTML =
    '<span class="toast-icon">' + (TOAST_ICONS[type] || '') + '</span>' +
    '<span class="toast-message">' + escHtml(message) + '</span>';
  container.appendChild(el);

  const duration = (type === 'warning' || type === 'error') ? 5000 : 3000;
  el._toastTimer = setTimeout(function() { dismissToast(el); }, duration);
}

function dismissToast(el) {
  if (!el || el.classList.contains('toast-dismissing')) return;
  clearTimeout(el._toastTimer);
  el.classList.add('toast-dismissing');
  el.addEventListener('animationend', function() { el.remove(); }, { once: true });
}

// ─── THEME ──────────────────────────────────────────────────────────────────────
function applyTheme(theme) {
  const btn = document.getElementById('themeToggle');
  if (theme === 'light') {
    document.body.classList.add('light-theme');
    if (btn) btn.textContent = '\u2600';
    document.documentElement.style.background = '#ffffff';
    document.documentElement.style.colorScheme = 'light';
  } else {
    document.body.classList.remove('light-theme');
    if (btn) btn.textContent = '\u263e';
    document.documentElement.style.background = '#1e1e2e';
    document.documentElement.style.colorScheme = 'dark';
  }
  // Re-apply custom accent color if one is saved
  reapplyCustomAccent();
}

function toggleTheme() {
  const isLight = document.body.classList.contains('light-theme');
  const newTheme = isLight ? 'dark' : 'light';
  localStorage.setItem('holm-theme', newTheme);
  applyTheme(newTheme);
}

// Apply theme on DOM ready (before full render)
(function() {
  var saved = localStorage.getItem('holm-theme');
  if (saved === 'light') {
    document.body.classList.add('light-theme');
  }
  // Update button text once DOM is available
  var btn = document.getElementById('themeToggle');
  if (btn) btn.textContent = saved === 'light' ? '\u2600' : '\u263e';
})();

// ─── ACCENT COLOR PICKER ─────────────────────────────────────────────────────
var ACCENT_PRESETS = [
  { name: 'Blue',   color: '#89b4fa' },
  { name: 'Purple', color: '#cba6f7' },
  { name: 'Green',  color: '#a6e3a1' },
  { name: 'Teal',   color: '#94e2d5' },
  { name: 'Pink',   color: '#f5c2e7' },
  { name: 'Red',    color: '#f38ba8' },
  { name: 'Orange', color: '#fab387' },
  { name: 'Yellow', color: '#f9e2af' },
  { name: 'Sky',    color: '#89dceb' },
  { name: 'Indigo', color: '#7287fd' }
];

var ACCENT_DEFAULTS = { dark: '#89b4fa', light: '#2563eb' };
var ACCENT_DIM_DEFAULTS = { dark: '#2a3a5c', light: '#dbeafe' };

function hexToRgb(hex) {
  var r = parseInt(hex.slice(1, 3), 16);
  var g = parseInt(hex.slice(3, 5), 16);
  var b = parseInt(hex.slice(5, 7), 16);
  return { r: r, g: g, b: b };
}

function computeAccentDim(hex) {
  var rgb = hexToRgb(hex);
  var isLight = document.body.classList.contains('light-theme');
  if (isLight) {
    // Light mode: very light tint of the color
    return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0.1)';
  } else {
    // Dark mode: dark shade of the color
    return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',0.18)';
  }
}

function applyAccentColor(hex) {
  document.documentElement.style.setProperty('--accent', hex);
  document.documentElement.style.setProperty('--accent-dim', computeAccentDim(hex));
  // Update the preview swatch
  var preview = document.getElementById('accentSwatchPreview');
  if (preview) preview.style.background = hex;
  // Update the custom color input and hex display
  var colorInput = document.getElementById('accentCustomColor');
  var hexDisplay = document.getElementById('accentHexValue');
  if (colorInput) colorInput.value = hex;
  if (hexDisplay) hexDisplay.textContent = hex;
  // Update active state on swatches
  updateAccentSwatchActive(hex);
}

function reapplyCustomAccent() {
  var saved = localStorage.getItem('holm-accent-color');
  if (saved) {
    applyAccentColor(saved);
  }
}

function resetAccentColor() {
  localStorage.removeItem('holm-accent-color');
  // Remove inline overrides so CSS variables revert to theme defaults
  document.documentElement.style.removeProperty('--accent');
  document.documentElement.style.removeProperty('--accent-dim');
  // Update UI to show current theme default
  var isLight = document.body.classList.contains('light-theme');
  var defaultColor = isLight ? ACCENT_DEFAULTS.light : ACCENT_DEFAULTS.dark;
  var preview = document.getElementById('accentSwatchPreview');
  if (preview) preview.style.background = '';
  var colorInput = document.getElementById('accentCustomColor');
  var hexDisplay = document.getElementById('accentHexValue');
  if (colorInput) colorInput.value = defaultColor;
  if (hexDisplay) hexDisplay.textContent = defaultColor;
  updateAccentSwatchActive(null);
}

function updateAccentSwatchActive(activeHex) {
  var swatches = document.querySelectorAll('.accent-swatch');
  swatches.forEach(function(s) {
    if (activeHex && s.dataset.color.toLowerCase() === activeHex.toLowerCase()) {
      s.classList.add('active');
    } else {
      s.classList.remove('active');
    }
  });
}

function initAccentPicker() {
  var wrapper = document.getElementById('accentPickerWrapper');
  var btn = document.getElementById('accentPickerBtn');
  var popover = document.getElementById('accentPopover');
  var swatchesContainer = document.getElementById('accentSwatches');
  var customColorInput = document.getElementById('accentCustomColor');
  var hexDisplay = document.getElementById('accentHexValue');
  var resetBtn = document.getElementById('accentResetBtn');

  if (!wrapper || !btn || !popover) return;

  // Render preset swatches
  ACCENT_PRESETS.forEach(function(preset) {
    var swatch = document.createElement('div');
    swatch.className = 'accent-swatch';
    swatch.style.background = preset.color;
    swatch.dataset.color = preset.color;
    swatch.title = preset.name;
    swatch.addEventListener('click', function() {
      applyAccentColor(preset.color);
      localStorage.setItem('holm-accent-color', preset.color);
    });
    swatchesContainer.appendChild(swatch);
  });

  // Toggle popover
  btn.addEventListener('click', function(e) {
    e.stopPropagation();
    popover.classList.toggle('open');
  });

  // Custom color input
  customColorInput.addEventListener('input', function() {
    var hex = customColorInput.value;
    applyAccentColor(hex);
    localStorage.setItem('holm-accent-color', hex);
    hexDisplay.textContent = hex;
  });

  // Reset button
  resetBtn.addEventListener('click', function() {
    resetAccentColor();
    popover.classList.remove('open');
  });

  // Close popover when clicking outside
  document.addEventListener('click', function(e) {
    if (!wrapper.contains(e.target)) {
      popover.classList.remove('open');
    }
  });

  // Restore saved accent color
  var saved = localStorage.getItem('holm-accent-color');
  if (saved) {
    applyAccentColor(saved);
  } else {
    // Show theme default in the UI
    var isLight = document.body.classList.contains('light-theme');
    var def = isLight ? ACCENT_DEFAULTS.light : ACCENT_DEFAULTS.dark;
    if (customColorInput) customColorInput.value = def;
    if (hexDisplay) hexDisplay.textContent = def;
  }
}

// ─── INIT ───────────────────────────────────────────────────────────────────
document.addEventListener('DOMContentLoaded', init);

async function init() {
  initAccentPicker();
  try {
    const res = await fetch('/api/docs');
    allDocs = await res.json();
    docsById = {};
    allDocs.forEach(d => docsById[d.docId] = d);
    renderSidebar();
    renderWelcomeStats();
    if (backlinksPanelOpen) document.getElementById('backlinksPanel').classList.add('active');
    // Restore pinned tabs from localStorage
    await restorePinnedTabs();
    if (window.location.hash) {
      const hashParts = parseHashWithHighlight(window.location.hash);
      const id = hashParts.docId;
      if (id && docsById[id]) {
        await openDoc(id);
        if (hashParts.highlight) {
          setTimeout(function() { applySharedHighlight(hashParts.highlight); }, 300);
        }
      }
    }
  } catch (err) {
    document.getElementById('sidebarContent').innerHTML =
      '<div style="padding:16px;color:var(--red)">Failed to load docs. Is the API running?</div>';
    showToast('Failed to load docs. Is the API running?', 'error');
  }
}

// Parse hash like #CON-001?highlight=some+text into { docId, highlight }
function parseHashWithHighlight(hash) {
  var raw = hash.startsWith('#') ? hash.slice(1) : hash;
  var qIdx = raw.indexOf('?');
  var docId = qIdx >= 0 ? raw.slice(0, qIdx).toUpperCase() : raw.toUpperCase();
  var highlight = null;
  if (qIdx >= 0) {
    var params = raw.slice(qIdx + 1);
    var match = params.match(/(?:^|&)highlight=([^&]*)/);
    if (match) {
      try { highlight = decodeURIComponent(match[1].replace(/\+/g, ' ')); } catch(e) {}
    }
  }
  return { docId: docId, highlight: highlight };
}

// Find the highlight text in #docBody and wrap it in a <mark>
function applySharedHighlight(text) {
  if (!text) return;
  var docBody = document.getElementById('docBody');
  if (!docBody) return;

  // Remove any previous shared highlights
  docBody.querySelectorAll('mark.shared-highlight').forEach(function(el) {
    var parent = el.parentNode;
    parent.replaceChild(document.createTextNode(el.textContent), el);
    parent.normalize();
  });

  // Walk text nodes to find the first occurrence
  var found = false;
  var walker = document.createTreeWalker(docBody, NodeFilter.SHOW_TEXT, null, false);
  var searchLower = text.toLowerCase();
  var node;

  while ((node = walker.nextNode())) {
    var idx = node.textContent.toLowerCase().indexOf(searchLower);
    if (idx === -1) continue;

    // Split the text node and wrap the matched portion
    var before = node.textContent.slice(0, idx);
    var matched = node.textContent.slice(idx, idx + text.length);
    var after = node.textContent.slice(idx + text.length);

    var mark = document.createElement('mark');
    mark.className = 'shared-highlight';
    mark.textContent = matched;

    var parent = node.parentNode;
    if (after) parent.insertBefore(document.createTextNode(after), node.nextSibling);
    parent.insertBefore(mark, node.nextSibling);
    node.textContent = before;

    // Scroll to the highlight
    var mainContent = document.getElementById('mainContent');
    if (mainContent) {
      var markRect = mark.getBoundingClientRect();
      var containerRect = mainContent.getBoundingClientRect();
      var scrollTarget = mainContent.scrollTop + (markRect.top - containerRect.top) - (containerRect.height / 3);
      mainContent.scrollTo({ top: Math.max(0, scrollTarget), behavior: 'smooth' });
    }

    // After 3 seconds, settle the highlight to a subtle background
    setTimeout(function() { mark.classList.add('settled'); }, 3000);

    found = true;
    break;
  }
}

function renderWelcomeStats() {
  const domains = new Set(allDocs.map(d => d.domain));
  document.getElementById('welcomeStats').innerHTML = `
    <div class="stat"><div class="stat-num">${allDocs.length}</div><div class="stat-label">Documents</div></div>
    <div class="stat"><div class="stat-num">${domains.size}</div><div class="stat-label">Domains</div></div>
  `;
  document.getElementById('statusDocs').textContent = `${allDocs.length} docs`;
}


// ─── SIDEBAR SORT ───────────────────────────────────────────────────────────
const SIDEBAR_SORT_OPTIONS = [
  { key: 'id',     label: 'ID' },
  { key: 'name',   label: 'Name' },
  { key: 'status', label: 'Status' },
  { key: 'date',   label: 'Date' }
];

function setSidebarSort(mode) {
  sidebarSortMode = mode;
  try { localStorage.setItem('holm-sidebar-sort', mode); } catch(e) {}
  renderSidebar();
  if (currentDoc) {
    const activeItem = document.querySelector('.sidebar-item[data-id="' + currentDoc.docId + '"]');
    if (activeItem) { activeItem.classList.add('active'); activeItem.scrollIntoView({ block: 'nearest' }); }
  }
}

function buildSortControlsHtml() {
  var btns = '';
  for (var i = 0; i < SIDEBAR_SORT_OPTIONS.length; i++) {
    var opt = SIDEBAR_SORT_OPTIONS[i];
    var isActive = sidebarSortMode === opt.key;
    var cls = 'sidebar-sort-btn' + (isActive ? ' active' : '');
    var arrow = opt.key === 'date' ? '↓' : '↑';
    btns += '<button class="' + cls + '" onclick="setSidebarSort(\'' + opt.key + '\')">' + opt.label + '<span class="sort-arrow">' + arrow + '</span></button>';
  }
  return '<div class="sidebar-sort-controls"><span class="sort-label">Sort:</span>' + btns + '</div>';
}

// ─── SIDEBAR ────────────────────────────────────────────────────────────────
function renderSidebar() {
  const sourceDocs = activeTagFilter
    ? allDocs.filter(doc => doc.tags && doc.tags.includes(activeTagFilter))
    : allDocs;

  let filterBar = '';
  if (activeTagFilter) {
    filterBar = `<div class="sidebar-filter">Filtered: <span class="filter-tag active">#${escHtml(activeTagFilter)}</span> <span class="clear-filter" onclick="clearTagFilter()">✕</span></div>`;
  }

  const sortControls = buildSortControlsHtml();
  let html = '';

  if (sidebarSortMode === 'status') {
    // ── Sort by Status: group by status instead of domain ──
    const statusGroups = {};
    sourceDocs.forEach(doc => {
      const st = doc.status || 'Unknown';
      if (!statusGroups[st]) statusGroups[st] = [];
      statusGroups[st].push(doc);
    });
    const statusOrder = ['Ratified', 'Active', 'Draft', 'Deprecated'];
    const sortedStatuses = Object.keys(statusGroups).sort((a, b) => {
      const ia = statusOrder.indexOf(a), ib = statusOrder.indexOf(b);
      const pa = ia === -1 ? 999 : ia, pb = ib === -1 ? 999 : ib;
      if (pa !== pb) return pa - pb;
      return a.localeCompare(b);
    });
    for (const st of sortedStatuses) {
      const docs = statusGroups[st].sort((a, b) => a.docId.localeCompare(b.docId));
      const badgeCls = getStatusBadgeClass(st);
      html += `<div class="sidebar-section flat-group" data-domain="status-${st}">
        <div class="sidebar-section-header" onclick="toggleSection(this)">
          <span class="chevron">&#9660;</span><span class="doc-badge-pill ${badgeCls}" style="font-size:10px;padding:1px 6px;margin-right:6px">${escHtml(st)}</span> <span style="margin-left:auto;font-size:10px;opacity:0.6">${docs.length}</span>
        </div>
        <div class="sidebar-items-wrap"><div class="sidebar-items">`;
      for (const doc of docs) {
        const _noteIcon = getHolmNotes()[doc.docId] ? '<span class="note-icon" title="Has personal note">&#9998;</span>' : '';
        html += `<div class="sidebar-item" data-id="${doc.docId}" onclick="openDoc('${doc.docId}')">
          <span class="doc-id">${doc.docId}</span>
          <span class="doc-title">${escHtml(doc.title)}</span>
          ${_noteIcon}
        </div>`;
      }
      html += '</div></div></div>';
    }
  } else if (sidebarSortMode === 'date') {
    // ── Sort by Date: flat list, most recently updated first ──
    const sorted = [...sourceDocs].sort((a, b) => {
      const da = a.updatedAt || a.date || '';
      const db = b.updatedAt || b.date || '';
      if (db > da) return 1;
      if (db < da) return -1;
      return a.docId.localeCompare(b.docId);
    });
    html += `<div class="sidebar-section flat-group" data-domain="all-by-date">
      <div class="sidebar-section-header" onclick="toggleSection(this)">
        <span class="chevron">&#9660;</span>All Documents <span style="margin-left:auto;font-size:10px;opacity:0.6">${sorted.length}</span>
      </div>
      <div class="sidebar-items-wrap"><div class="sidebar-items">`;
    for (const doc of sorted) {
      const dateStr = doc.updatedAt ? new Date(doc.updatedAt).toLocaleDateString() : (doc.date || '');
      const _noteIcon = getHolmNotes()[doc.docId] ? '<span class="note-icon" title="Has personal note">&#9998;</span>' : '';
      html += `<div class="sidebar-item" data-id="${doc.docId}" onclick="openDoc('${doc.docId}')">
        <span class="doc-id">${doc.docId}</span>
        <span class="doc-title">${escHtml(doc.title)}</span>
        ${dateStr ? '<span style="margin-left:auto;font-size:10px;color:var(--text-muted);flex-shrink:0">' + escHtml(dateStr) + '</span>' : ''}
        ${_noteIcon}
      </div>`;
    }
    html += '</div></div></div>';
  } else {
    // ── Sort by ID (default) or by Name: grouped by domain ──
    const groups = {};
    sourceDocs.forEach(doc => {
      const key = doc.domain || 'Other';
      if (!groups[key]) groups[key] = { name: doc.domainName || key, docs: [] };
      groups[key].docs.push(doc);
    });

    // Sort docs within each group
    for (const key of Object.keys(groups)) {
      if (sidebarSortMode === 'name') {
        groups[key].docs.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
      } else {
        groups[key].docs.sort((a, b) => a.docId.localeCompare(b.docId));
      }
    }

    const sortedKeys = Object.keys(groups).sort((a, b) => {
      const na = parseInt(a), nb = parseInt(b);
      if (!isNaN(na) && !isNaN(nb)) return na - nb;
      if (!isNaN(na)) return -1;
      if (!isNaN(nb)) return 1;
      return a.localeCompare(b);
    });

    for (const key of sortedKeys) {
      const g = groups[key];
      const color = DOMAIN_COLORS[key] || 'var(--text-muted)';
      html += `<div class="sidebar-section" data-domain="${key}">
        <div class="sidebar-section-header" onclick="toggleSection(this)" style="color:${color}">
          <span class="chevron">&#9660;</span>D${key} ${g.name} <span style="margin-left:auto;font-size:10px;opacity:0.6">${g.docs.length}</span>
        </div>
        <div class="sidebar-items-wrap"><div class="sidebar-items">`;
      for (const doc of g.docs) {
        const _noteIcon = getHolmNotes()[doc.docId] ? '<span class="note-icon" title="Has personal note">&#9998;</span>' : '';
        html += `<div class="sidebar-item" data-id="${doc.docId}" onclick="openDoc('${doc.docId}')">
          <span class="doc-id">${doc.docId}</span>
          <span class="doc-title">${escHtml(doc.title)}</span>
          ${_noteIcon}
        </div>`;
      }
      html += '</div></div></div>';
    }
  }

  if (activeTagFilter && sourceDocs.length === 0) {
    html = `<div style="padding:16px;color:var(--text-muted);font-size:13px">No documents tagged <strong>#${escHtml(activeTagFilter)}</strong></div>`;
  }

  document.getElementById('sidebarContent').innerHTML = buildFavoritesHtml() + renderRecentSection() + sortControls + filterBar + html;
  document.getElementById('docCount').textContent = activeTagFilter
    ? `${sourceDocs.length} of ${allDocs.length} documents`
    : `${allDocs.length} documents`;

  // Restore collapsed state from localStorage
  applySidebarState();

  // ── A11Y: add accessibility attributes to sidebar items ──
  document.querySelectorAll('.sidebar-section-header').forEach(header => {
    header.setAttribute('tabindex', '0');
    header.setAttribute('role', 'button');
    const section = header.parentElement;
    header.setAttribute('aria-expanded', section.classList.contains('collapsed') ? 'false' : 'true');
    // Allow keyboard activation
    if (!header._a11yKeyHandler) {
      header._a11yKeyHandler = true;
      header.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggleSection(header);
        }
      });
    }
  });
  document.querySelectorAll('.sidebar-item').forEach(item => {
    item.setAttribute('tabindex', '0');
    item.setAttribute('role', 'option');
    if (!item._a11yKeyHandler) {
      item._a11yKeyHandler = true;
      item.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          item.click();
        }
      });
    }
  });
}

// ─── SIDEBAR COLLAPSE STATE PERSISTENCE ─────────────────────────────────────
const SIDEBAR_STATE_KEY = 'holm-sidebar-state';

function getSidebarState() {
  try {
    const raw = localStorage.getItem(SIDEBAR_STATE_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch (e) { return {}; }
}

function saveSidebarState(state) {
  try { localStorage.setItem(SIDEBAR_STATE_KEY, JSON.stringify(state)); } catch (e) {}
}

function applySidebarState() {
  const state = getSidebarState();
  // Determine the active doc's domain so we can force it open
  const activeDomain = currentDoc ? currentDoc.domain : null;

  document.querySelectorAll('.sidebar-section[data-domain]').forEach(section => {
    const domain = section.dataset.domain;
    const wrap = section.querySelector('.sidebar-items-wrap');
    const items = section.querySelector('.sidebar-items');
    if (!wrap || !items) return;

    // If this domain has the active doc, always expand it
    const shouldCollapse = (domain === activeDomain) ? false : (state[domain] === true);

    if (shouldCollapse) {
      section.classList.add('collapsed');
      wrap.style.height = '0px';
    } else {
      section.classList.remove('collapsed');
      wrap.style.height = items.scrollHeight + 'px';
      // After transition ends, set to auto so it can resize naturally
      requestAnimationFrame(() => {
        requestAnimationFrame(() => { wrap.style.height = 'auto'; });
      });
    }
  });
}

function toggleSection(headerEl) {
  const section = headerEl.parentElement;
  const domain = section.dataset.domain;
  const wrap = section.querySelector('.sidebar-items-wrap');
  const items = section.querySelector('.sidebar-items');
  if (!wrap || !items) return;

  const isCollapsed = section.classList.contains('collapsed');

  if (isCollapsed) {
    // Expand: set height from 0 to scrollHeight, then auto
    section.classList.remove('collapsed');
    headerEl.setAttribute('aria-expanded', 'true');
    wrap.style.height = '0px';
    // Force reflow
    void wrap.offsetHeight;
    wrap.style.height = items.scrollHeight + 'px';
    const onEnd = () => {
      wrap.style.height = 'auto';
      wrap.removeEventListener('transitionend', onEnd);
    };
    wrap.addEventListener('transitionend', onEnd);
  } else {
    // Collapse: set explicit height first, then transition to 0
    wrap.style.height = items.scrollHeight + 'px';
    // Force reflow
    void wrap.offsetHeight;
    section.classList.add('collapsed');
    headerEl.setAttribute('aria-expanded', 'false');
    wrap.style.height = '0px';
  }

  // Persist state
  const state = getSidebarState();
  state[domain] = !isCollapsed; // after toggle: collapsed = !wasCollapsed
  saveSidebarState(state);
}

// ─── TAG FILTER ─────────────────────────────────────────────────────────────
function filterByTag(tag) {
  activeTagFilter = tag;
  renderSidebar();
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) { activeItem.classList.add('active'); activeItem.scrollIntoView({ block: 'nearest' }); }
  }
}

function clearTagFilter() {
  activeTagFilter = null;
  renderSidebar();
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) { activeItem.classList.add('active'); activeItem.scrollIntoView({ block: 'nearest' }); }
  }
}

function filterByDomain(domainKey) {
  // Clear any active tag filter first
  activeTagFilter = null;
  renderSidebar();

  // Collapse all sections, then expand only the matching domain
  const filterState = {};
  document.querySelectorAll('.sidebar-section[data-domain]').forEach(section => {
    const d = section.dataset.domain;
    if (d === domainKey) {
      filterState[d] = false;
    } else {
      filterState[d] = true;
    }
  });
  saveSidebarState(filterState);
  applySidebarState();
  const targetSection = document.querySelector(`.sidebar-section[data-domain="${domainKey}"]`);
  if (targetSection) targetSection.scrollIntoView({ block: 'start', behavior: 'smooth' });

  // Re-highlight active doc if any
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) { activeItem.classList.add('active'); activeItem.scrollIntoView({ block: 'nearest' }); }
  }
}

// ─── TABS + DOC OPEN ────────────────────────────────────────────────────────
let _docHasLoaded = false; // tracks whether a doc has been rendered at least once

async function openDoc(id, skipHistory) {
  // Exit split mode when opening a new doc from sidebar/search
  if (splitModeActive) exitSplitMode();
  if (!openTabs.find(t => t.docId === id)) {
    const meta = docsById[id];
    // New (unpinned) tabs go at the end; pinned tabs are always sorted first
    openTabs.push({ docId: id, title: meta ? meta.title : id });
  }
  if (!skipHistory && !navIsTraversing) {
    // Truncate any forward history
    navHistory = navHistory.slice(0, navHistoryPos + 1);
    navHistory.push(id);
    // Cap at max
    if (navHistory.length > NAV_HISTORY_MAX) {
      navHistory = navHistory.slice(navHistory.length - NAV_HISTORY_MAX);
    }
    navHistoryPos = navHistory.length - 1;
    updateNavButtons();
  }
  await switchTab(id);
}

async function switchTab(docId) {
  // If the requested doc is already displayed, just highlight its tab — no animation
  if (currentDoc && currentDoc.docId === docId) {
    renderTabs();
    return;
  }

  try {
    const res = await fetch(`/api/docs/${docId}`);
    if (!res.ok) throw new Error('Not found');
    const newDoc = await res.json();

    const viewer = document.getElementById('docViewer');
    // Only animate on subsequent switches, not the very first doc load
    const shouldAnimate = _docHasLoaded && viewer.classList.contains('active');

    const applyContent = () => {
      currentDoc = newDoc;

      const tab = openTabs.find(t => t.docId === docId);
      if (tab && tab.title === docId) tab.title = currentDoc.title;
      renderTabs();

      // Track in recently viewed
      addToRecent(currentDoc.docId, currentDoc.title);
      renderSidebar();

      window.location.hash = docId;

      document.querySelectorAll('.sidebar-item').forEach(el => el.classList.remove('active'));
      const activeItem = document.querySelector(`.sidebar-item[data-id="${docId}"]`);
      if (activeItem) {
        activeItem.classList.add('active');
        // Ensure the active doc's domain section is expanded
        const parentSection = activeItem.closest('.sidebar-section');
        if (parentSection && parentSection.classList.contains('collapsed')) {
          const header = parentSection.querySelector('.sidebar-section-header');
          if (header) toggleSection(header);
        }
        activeItem.scrollIntoView({ block: 'nearest' });
      }

      document.getElementById('welcome').style.display = 'none';
      viewer.classList.add('active');

      document.getElementById('docTitle').textContent = `${currentDoc.docId} — ${currentDoc.title}`;
      document.getElementById('docMeta').innerHTML = `
        <span class="badge" style="color:${DOMAIN_COLORS[currentDoc.domain] || 'var(--text-muted)'}">Domain ${currentDoc.domain}: ${escHtml(currentDoc.domainName)}</span>
      `;
      renderDocBadges();

      // Breadcrumb
      const bcDomain = document.getElementById('bcDomain');
      const domainLabel = currentDoc.domainName ? `D${currentDoc.domain} ${currentDoc.domainName}` : `Domain ${currentDoc.domain}`;
      bcDomain.textContent = domainLabel;
      bcDomain.style.color = DOMAIN_COLORS[currentDoc.domain] || 'var(--text-secondary)';
      bcDomain.onclick = function() { filterByDomain(currentDoc.domain); };
      document.getElementById('bcDocId').textContent = currentDoc.docId;
      document.getElementById('breadcrumb').classList.add('active');

      updateReadingInfo();
      updateFavoriteBtn();
      setViewMode('preview');
      renderBacklinks();

      document.getElementById('statusDomain').textContent = `Domain ${currentDoc.domain}`;
      document.getElementById('statusUpdated').textContent = `Updated: ${new Date(currentDoc.updatedAt).toLocaleDateString()}`;

      if (window.innerWidth <= 768) {
        document.getElementById('sidebar').classList.remove('open');
        document.getElementById('sidebarOverlay').classList.remove('active');
      }

      // A11Y: move focus to document title heading
      requestAnimationFrame(() => {
        const titleEl = document.getElementById('docTitle');
        if (titleEl) titleEl.focus({ preventScroll: true });
      });

      _docHasLoaded = true;
    };

    if (shouldAnimate) {
      // Fade out (150ms), swap content, then fade in (150ms)
      viewer.classList.add('doc-transitioning');
      setTimeout(() => {
        applyContent();
        // Force reflow so the browser registers opacity:0 before removing the class
        void viewer.offsetHeight;
        viewer.classList.remove('doc-transitioning');
      }, 150);
    } else {
      // First load — no animation, just show content immediately
      applyContent();
    }

  } catch (err) {
    console.error('Failed to open doc:', err);
    showToast('Failed to open document: ' + err.message, 'error');
  }
}

// ─── PINNED TABS PERSISTENCE ─────────────────────────────────────────────
function loadPinnedTabs() {
  try {
    const raw = localStorage.getItem(PINNED_TABS_KEY);
    if (raw) {
      const ids = JSON.parse(raw);
      pinnedTabIds = new Set(ids);
    }
  } catch (e) { pinnedTabIds = new Set(); }
}

function savePinnedTabs() {
  try {
    localStorage.setItem(PINNED_TABS_KEY, JSON.stringify([...pinnedTabIds]));
  } catch (e) {}
}

async function restorePinnedTabs() {
  loadPinnedTabs();
  if (pinnedTabIds.size === 0) return;
  for (const id of pinnedTabIds) {
    if (!openTabs.find(t => t.docId === id)) {
      const meta = docsById[id];
      openTabs.unshift({ docId: id, title: meta ? meta.title : id });
    }
  }
  sortTabsByPinState();
  renderTabs();
}

function sortTabsByPinState() {
  const pinned = openTabs.filter(t => pinnedTabIds.has(t.docId));
  const unpinned = openTabs.filter(t => !pinnedTabIds.has(t.docId));
  openTabs = [...pinned, ...unpinned];
}

function pinTab(docId) {
  pinnedTabIds.add(docId);
  savePinnedTabs();
  sortTabsByPinState();
  renderTabs();
}

function unpinTab(docId) {
  pinnedTabIds.delete(docId);
  savePinnedTabs();
  sortTabsByPinState();
  renderTabs();
}

function togglePinTab(docId) {
  if (pinnedTabIds.has(docId)) {
    unpinTab(docId);
  } else {
    pinTab(docId);
  }
}

// ─── PIN CONTEXT MENU ───────────────────────────────────────────────────────
function showPinContextMenu(event, docId) {
  event.preventDefault();
  event.stopPropagation();
  dismissPinContextMenu();

  const isPinned = pinnedTabIds.has(docId);
  const menu = document.createElement('div');
  menu.className = 'pin-context-menu';
  menu.id = 'pinContextMenu';

  menu.innerHTML = `
    <div class="pin-context-menu-item" onclick="togglePinTab('${escHtml(docId)}'); dismissPinContextMenu();">
      <span>${isPinned ? '&#128204; Unpin tab' : '&#128204; Pin tab'}</span>
    </div>
    ${!isPinned ? `<div class="pin-context-menu-separator"></div>
    <div class="pin-context-menu-item" onclick="closeTab('${escHtml(docId)}'); dismissPinContextMenu();">
      <span>&#10005; Close tab</span>
    </div>` : ''}
  `;

  document.body.appendChild(menu);

  // Position: ensure menu stays within viewport
  const x = Math.min(event.clientX, window.innerWidth - menu.offsetWidth - 8);
  const y = Math.min(event.clientY, window.innerHeight - menu.offsetHeight - 8);
  menu.style.left = x + 'px';
  menu.style.top = y + 'px';

  // Dismiss on click outside or Escape
  setTimeout(() => {
    document.addEventListener('click', dismissPinContextMenu, { once: true });
    document.addEventListener('contextmenu', dismissPinContextMenu, { once: true });
    document.addEventListener('keydown', _pinMenuKeyHandler);
  }, 0);
}

function _pinMenuKeyHandler(e) {
  if (e.key === 'Escape') dismissPinContextMenu();
}

function dismissPinContextMenu() {
  const existing = document.getElementById('pinContextMenu');
  if (existing) existing.remove();
  document.removeEventListener('keydown', _pinMenuKeyHandler);
}

function renderTabs() {
  const bar = document.getElementById('tabBar');
  if (openTabs.length === 0) { bar.innerHTML = ''; return; }
  bar.innerHTML = openTabs.map(tab => {
    const isActive = currentDoc && currentDoc.docId === tab.docId;
    const isPinned = pinnedTabIds.has(tab.docId);
    const classes = ['tab'];
    if (isActive) classes.push('active');
    if (isPinned) classes.push('pinned');
    return `<div class="${classes.join(' ')}" data-tab-id="${escHtml(tab.docId)}"
               role="tab" tabindex="${isActive ? '0' : '-1'}" aria-selected="${isActive ? 'true' : 'false'}"
               draggable="true"
               ondragstart="handleTabDragStart(event)"
               ondragover="handleTabDragOver(event)"
               ondragenter="handleTabDragEnter(event)"
               ondragleave="handleTabDragLeave(event)"
               ondrop="handleTabDrop(event)"
               ondragend="handleTabDragEnd(event)"
               onclick="switchTab('${escHtml(tab.docId)}')"
               oncontextmenu="showPinContextMenu(event, '${escHtml(tab.docId)}')"
               onmousedown="handleTabMousedown(event, '${escHtml(tab.docId)}')"
               ondblclick="handleTabDblClick(event, '${escHtml(tab.docId)}')"
               title="${escHtml(tab.docId)}${isPinned ? ' (pinned)' : ': ' + escHtml(tab.title)}">
      ${isPinned ? '<span class="pin-indicator">&#128204;</span>' : ''}
      <span class="tab-id">${escHtml(tab.docId)}</span>
      <span class="tab-title">${escHtml(tab.title)}</span>
      <span class="tab-close" role="button" tabindex="0" aria-label="Close tab ${escHtml(tab.docId)}" onclick="event.stopPropagation(); closeTab('${escHtml(tab.docId)}')" onkeydown="if(event.key==='Enter'){event.stopPropagation();closeTab('${escHtml(tab.docId)}')}">&#215;</span>
    </div>`;
  }).join('');
  const activeTab = bar.querySelector('.tab.active');
  if (activeTab) activeTab.scrollIntoView({ block: 'nearest', inline: 'nearest' });
}

function closeTab(docId) {
  // Prevent closing pinned tabs
  if (pinnedTabIds.has(docId)) return;
  const idx = openTabs.findIndex(t => t.docId === docId);
  if (idx === -1) return;
  openTabs.splice(idx, 1);
  if (currentDoc && currentDoc.docId === docId) {
    if (openTabs.length === 0) {
      currentDoc = null;
      document.getElementById('docViewer').classList.remove('active');
      document.getElementById('welcome').style.display = '';
      document.querySelectorAll('.sidebar-item').forEach(el => el.classList.remove('active'));
      window.location.hash = '';
      renderTabs();
      if (typeof window.hideMinimap === 'function') window.hideMinimap();
    } else {
      const nextTab = openTabs[Math.min(idx, openTabs.length - 1)];
      switchTab(nextTab.docId);
    }
  } else {
    renderTabs();
  }
}

function handleTabMousedown(event, docId) {
  // Middle-click closes tab (but not pinned)
  if (event.button === 1) {
    event.preventDefault();
    if (!pinnedTabIds.has(docId)) closeTab(docId);
  }
}

function handleTabDblClick(event, docId) {
  // Double-clicking the tab-id area or pin indicator toggles pin
  const target = event.target;
  if (target.classList.contains('tab-id') || target.classList.contains('pin-indicator')) {
    event.stopPropagation();
    togglePinTab(docId);
  }
}

// ─── TAB DRAG AND DROP ────────────────────────────────────────────────────
let draggedTabId = null;

function handleTabDragStart(event) {
  const tabEl = event.target.closest('.tab');
  if (!tabEl) return;
  draggedTabId = tabEl.dataset.tabId;
  tabEl.classList.add('dragging');
  event.dataTransfer.effectAllowed = 'move';
  event.dataTransfer.setData('text/plain', draggedTabId);
}

function handleTabDragOver(event) {
  event.preventDefault();
  event.dataTransfer.dropEffect = 'move';
}

function handleTabDragEnter(event) {
  event.preventDefault();
  const tabEl = event.target.closest('.tab');
  if (!tabEl || tabEl.dataset.tabId === draggedTabId) return;
  tabEl.classList.add('drag-over');
}

function handleTabDragLeave(event) {
  const tabEl = event.target.closest('.tab');
  if (!tabEl) return;
  // Only remove if we actually left the tab element (not just moved to a child)
  const related = event.relatedTarget;
  if (related && tabEl.contains(related)) return;
  tabEl.classList.remove('drag-over');
}

function handleTabDrop(event) {
  event.preventDefault();
  const targetTabEl = event.target.closest('.tab');
  if (!targetTabEl) return;
  const targetTabId = targetTabEl.dataset.tabId;
  targetTabEl.classList.remove('drag-over');

  // Prevent drop on self
  if (!draggedTabId || draggedTabId === targetTabId) return;

  const draggedIsPinned = pinnedTabIds.has(draggedTabId);
  const targetIsPinned = pinnedTabIds.has(targetTabId);

  // Enforce pin boundary: pinned tabs can only be reordered among pinned,
  // unpinned tabs can only be reordered among unpinned
  if (draggedIsPinned !== targetIsPinned) return;

  const fromIdx = openTabs.findIndex(t => t.docId === draggedTabId);
  const toIdx = openTabs.findIndex(t => t.docId === targetTabId);
  if (fromIdx === -1 || toIdx === -1) return;

  // Remove the dragged tab and insert at the new position
  const [movedTab] = openTabs.splice(fromIdx, 1);
  openTabs.splice(toIdx, 0, movedTab);

  renderTabs();
}

function handleTabDragEnd(event) {
  draggedTabId = null;
  // Clean up all drag classes
  document.querySelectorAll('.tab.dragging, .tab.drag-over').forEach(el => {
    el.classList.remove('dragging', 'drag-over');
  });
}

// ─── VIEW MODE ──────────────────────────────────────────────────────────────
function setViewMode(mode) {
  viewMode = mode;
  const body = document.getElementById('docBody');
  const edit = document.getElementById('editArea');
  const saveBar = document.getElementById('saveBar');
  document.querySelectorAll('.doc-toolbar button').forEach(b => b.classList.remove('active'));

  if (mode === 'preview') {
    body.style.display = 'block';
    body.innerHTML = linkifyDocIds(currentDoc.content);
    addCopyButtons();
    highlightCodeBlocks();
    edit.classList.remove('active');
    saveBar.classList.remove('active');
    document.getElementById('btnPreview').classList.add('active');
  } else if (mode === 'edit') {
    body.style.display = 'none';
    edit.value = currentDoc.content;
    edit.classList.add('active');
    saveBar.classList.add('active');
    document.getElementById('btnEdit').classList.add('active');
  } else if (mode === 'raw') {
    body.style.display = 'block';
    body.innerHTML = `<pre><code>${escHtml(currentDoc.content)}</code></pre>`;
    addCopyButtons();
    highlightCodeBlocks();
    edit.classList.remove('active');
    saveBar.classList.remove('active');
    document.getElementById('btnRaw').classList.add('active');
  }

  // Update minimap after content change
  if (mode === 'preview' || mode === 'raw') {
    if (typeof window.updateMinimap === 'function') window.updateMinimap();
  } else {
    if (typeof window.hideMinimap === 'function') window.hideMinimap();
  }

  // Update floating TOC
  if (typeof window.updateFloatingToc === 'function') {
    if (mode === 'preview') {
      window.updateFloatingToc();
    } else {
      window.hideFloatingToc();
    }
  }
}

async function saveDoc() {
  if (!currentDoc) return;
  const content = document.getElementById('editArea').value;
  try {
    const res = await fetch(`/api/docs/${currentDoc.docId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content })
    });
    if (!res.ok) throw new Error('Save failed');
    currentDoc.content = content;
    setViewMode('preview');
    showToast('Document saved successfully', 'success');
  } catch (err) {
    showToast('Failed to save: ' + err.message, 'error');
  }
}

// ─── EXPORT AS MARKDOWN ─────────────────────────────────────────────────────
function htmlToMarkdown(html) {
  let md = html;

  // Fenced code blocks: <pre><code>...</code></pre>
  md = md.replace(/<pre[^>]*>\s*<code[^>]*>([\s\S]*?)<\/code>\s*<\/pre>/gi, function(_, code) {
    const decoded = code.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    return '\n```\n' + decoded.trim() + '\n```\n';
  });

  // Tables
  md = md.replace(/<table[^>]*>([\s\S]*?)<\/table>/gi, function(_, tableHtml) {
    const rows = [];
    const rowRegex = /<tr[^>]*>([\s\S]*?)<\/tr>/gi;
    let rowMatch;
    while ((rowMatch = rowRegex.exec(tableHtml)) !== null) {
      const cells = [];
      const cellRegex = /<(?:td|th)[^>]*>([\s\S]*?)<\/(?:td|th)>/gi;
      let cellMatch;
      while ((cellMatch = cellRegex.exec(rowMatch[1])) !== null) {
        cells.push(cellMatch[1].replace(/<[^>]+>/g, '').trim());
      }
      rows.push(cells);
    }
    if (rows.length === 0) return '';
    let table = '';
    table += '| ' + rows[0].join(' | ') + ' |\n';
    table += '| ' + rows[0].map(() => '---').join(' | ') + ' |\n';
    for (let i = 1; i < rows.length; i++) {
      table += '| ' + rows[i].join(' | ') + ' |\n';
    }
    return '\n' + table + '\n';
  });

  // Blockquotes
  md = md.replace(/<blockquote[^>]*>([\s\S]*?)<\/blockquote>/gi, function(_, content) {
    const text = content.replace(/<[^>]+>/g, '').trim();
    return '\n' + text.split('\n').map(line => '> ' + line.trim()).join('\n') + '\n';
  });

  // Headings
  md = md.replace(/<h1[^>]*>([\s\S]*?)<\/h1>/gi, function(_, t) { return '\n# ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h2[^>]*>([\s\S]*?)<\/h2>/gi, function(_, t) { return '\n## ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h3[^>]*>([\s\S]*?)<\/h3>/gi, function(_, t) { return '\n### ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h4[^>]*>([\s\S]*?)<\/h4>/gi, function(_, t) { return '\n#### ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h5[^>]*>([\s\S]*?)<\/h5>/gi, function(_, t) { return '\n##### ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h6[^>]*>([\s\S]*?)<\/h6>/gi, function(_, t) { return '\n###### ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });

  // Unordered lists
  md = md.replace(/<ul[^>]*>([\s\S]*?)<\/ul>/gi, function(_, listHtml) {
    let result = '\n';
    const liRegex = /<li[^>]*>([\s\S]*?)<\/li>/gi;
    let liMatch;
    while ((liMatch = liRegex.exec(listHtml)) !== null) {
      result += '- ' + liMatch[1].replace(/<[^>]+>/g, '').trim() + '\n';
    }
    return result + '\n';
  });

  // Ordered lists
  md = md.replace(/<ol[^>]*>([\s\S]*?)<\/ol>/gi, function(_, listHtml) {
    let result = '\n';
    let num = 1;
    const liRegex = /<li[^>]*>([\s\S]*?)<\/li>/gi;
    let liMatch;
    while ((liMatch = liRegex.exec(listHtml)) !== null) {
      result += num + '. ' + liMatch[1].replace(/<[^>]+>/g, '').trim() + '\n';
      num++;
    }
    return result + '\n';
  });

  // Links: <a href="...">text</a>
  md = md.replace(/<a[^>]+href="([^"]*)"[^>]*>([\s\S]*?)<\/a>/gi, function(_, href, text) {
    const linkText = text.replace(/<[^>]+>/g, '').trim();
    return '[' + linkText + '](' + href + ')';
  });

  // Bold
  md = md.replace(/<(?:strong|b)[^>]*>([\s\S]*?)<\/(?:strong|b)>/gi, function(_, t) { return '**' + t.replace(/<[^>]+>/g, '').trim() + '**'; });

  // Italic
  md = md.replace(/<(?:em|i)[^>]*>([\s\S]*?)<\/(?:em|i)>/gi, function(_, t) { return '*' + t.replace(/<[^>]+>/g, '').trim() + '*'; });

  // Paragraphs
  md = md.replace(/<p[^>]*>([\s\S]*?)<\/p>/gi, function(_, t) { return '\n' + t.trim() + '\n'; });

  // Line breaks
  md = md.replace(/<br\s*\/?>/gi, '\n');

  // Horizontal rules
  md = md.replace(/<hr\s*\/?>/gi, '\n---\n');

  // Strip all remaining HTML tags
  md = md.replace(/<[^>]+>/g, '');

  // Decode common HTML entities
  md = md.replace(/&amp;/g, '&');
  md = md.replace(/&lt;/g, '<');
  md = md.replace(/&gt;/g, '>');
  md = md.replace(/&quot;/g, '"');
  md = md.replace(/&#39;/g, "'");
  md = md.replace(/&nbsp;/g, ' ');

  // Clean up excessive blank lines (3+ newlines -> 2)
  md = md.replace(/\n{3,}/g, '\n\n');

  return md.trim() + '\n';
}

function exportAsMarkdown() {
  if (!currentDoc) return;

  const doc = currentDoc;

  // Build YAML front matter
  let frontMatter = '---\n';
  frontMatter += 'docId: "' + (doc.docId || '') + '"\n';
  frontMatter += 'title: "' + (doc.title || '').replace(/"/g, '\\"') + '"\n';
  frontMatter += 'domain: ' + (doc.domain != null ? doc.domain : '') + '\n';
  frontMatter += 'tags: [' + (Array.isArray(doc.tags) ? doc.tags.map(function(t) { return '"' + t + '"'; }).join(', ') : '') + ']\n';
  frontMatter += 'version: "' + (doc.version || '') + '"\n';
  frontMatter += 'status: "' + (doc.status || '') + '"\n';
  frontMatter += 'date: "' + (doc.date || '') + '"\n';
  frontMatter += '---\n\n';

  // Convert HTML content to Markdown
  const markdownBody = htmlToMarkdown(doc.content || '');

  const fullMarkdown = frontMatter + markdownBody;

  // Download via Blob + object URL + programmatic anchor click
  const blob = new Blob([fullMarkdown], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (doc.docId || 'export') + '.md';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ─── LINKIFY DOC IDS ────────────────────────────────────────────────────────
function linkifyDocIds(html) {
  const DOC_ID_RE = /\b([A-Z]{1,10}-\d{1,4}|D\d{1,2}-\d{1,4}|DOMAIN-\d{1,2}|APPENDIX-[A-Z](?:-\d)?)\b/g;
  const ANCHOR_RE = /(<a[\s\S]*?<\/a>)/gi;
  const parts = html.split(ANCHOR_RE);
  return parts.map((part, i) => {
    if (i % 2 === 1) return part;
    const TAG_RE = /(<[^>]+>)/g;
    const subParts = part.split(TAG_RE);
    return subParts.map((sub, j) => {
      if (j % 2 === 1) return sub;
      return sub.replace(DOC_ID_RE, (match) =>
        `<a class="doc-link" onclick="openDoc('${match}')" title="Open ${match}">${match}</a>`
      );
    }).join('');
  }).join('');
}

// ─── BACKLINKS + TOC + LOCAL GRAPH ──────────────────────────────────────────
function renderBacklinks() {
  if (!currentDoc) return;

  renderLocalGraph();
  renderTOC();

  // Depends On
  const depOn = document.getElementById('dependsOnList');
  if (currentDoc.dependsOn && currentDoc.dependsOn.length > 0) {
    depOn.innerHTML = currentDoc.dependsOn.map(id => {
      const ref = docsById[id];
      const title = ref ? ref.title : id;
      return `<a class="backlink-item" onclick="openDoc('${id}')">${id}: ${escHtml(title)}</a>`;
    }).join('');
  } else {
    depOn.innerHTML = '<span style="color:var(--text-muted);font-size:12px">None</span>';
  }

  // Depended Upon By
  const depBy = document.getElementById('dependedByList');
  if (currentDoc.dependedBy && currentDoc.dependedBy.length > 0) {
    depBy.innerHTML = currentDoc.dependedBy.map(id => {
      const ref = docsById[id];
      const title = ref ? ref.title : id;
      return `<a class="backlink-item" onclick="openDoc('${id}')">${id}: ${escHtml(title)}</a>`;
    }).join('');
  } else {
    depBy.innerHTML = '<span style="color:var(--text-muted);font-size:12px">None</span>';
  }

  // Tags (clickable for filtering)
  const tags = document.getElementById('tagsList');
  if (currentDoc.tags && currentDoc.tags.length > 0) {
    tags.innerHTML = currentDoc.tags.map(t =>
      `<span class="tag-item" onclick="filterByTag('${escHtml(t)}')">#${escHtml(t)}</span>`
    ).join('');
  } else {
    tags.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No tags</span>';
  }

  // Related Documents
  renderRelatedDocs();

  // Personal Notes
  renderNotes();
}

function renderRelatedDocs() {
  var header = document.getElementById('relatedHeader');
  var list = document.getElementById('relatedList');
  if (!currentDoc || !currentDoc.tags || currentDoc.tags.length === 0) {
    header.textContent = 'Related (0)';
    list.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No related documents</span>';
    return;
  }

  var excludeIds = new Set();
  excludeIds.add(currentDoc.docId);
  if (currentDoc.dependsOn) currentDoc.dependsOn.forEach(function(id) { excludeIds.add(id); });
  if (currentDoc.dependedBy) currentDoc.dependedBy.forEach(function(id) { excludeIds.add(id); });

  var currentTags = new Set(currentDoc.tags);

  var scored = [];
  allDocs.forEach(function(doc) {
    if (excludeIds.has(doc.docId)) return;
    if (!doc.tags || doc.tags.length === 0) return;
    var shared = 0;
    doc.tags.forEach(function(t) { if (currentTags.has(t)) shared++; });
    if (shared > 0) scored.push({ doc: doc, shared: shared });
  });

  scored.sort(function(a, b) { return b.shared - a.shared || a.doc.docId.localeCompare(b.doc.docId); });

  var top = scored.slice(0, 5);

  header.textContent = 'Related (' + top.length + ')';

  if (top.length === 0) {
    list.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No related documents</span>';
    return;
  }

  list.innerHTML = top.map(function(item) {
    var doc = item.doc, shared = item.shared;
    return '<div class="related-item">' +
      '<a class="related-item-link" onclick="openDoc(\'' + doc.docId + '\')">' + doc.docId + '</a>' +
      '<div class="related-item-title">' + escHtml(doc.title) + '</div>' +
      '<div class="related-item-score">' + shared + ' tag' + (shared !== 1 ? 's' : '') + ' in common</div>' +
    '</div>';
  }).join('');
}

// ─── PERSONAL ANNOTATIONS/NOTES ──────────────────────────────────────────────
const HOLM_NOTES_KEY = 'holm-notes';
let _noteSaveTimer = null;
let _noteSavedTimeout = null;

function getHolmNotes() {
  try {
    const raw = localStorage.getItem(HOLM_NOTES_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch (e) { return {}; }
}

function saveHolmNotes(notes) {
  try {
    localStorage.setItem(HOLM_NOTES_KEY, JSON.stringify(notes));
  } catch (e) { console.error('Failed to save notes:', e); }
}

function getNotesCount() {
  const notes = getHolmNotes();
  return Object.keys(notes).filter(k => notes[k] && notes[k].trim()).length;
}

function renderNotes() {
  const textarea = document.getElementById('notesTextarea');
  const countEl = document.getElementById('notesCount');
  const clearBtn = document.getElementById('notesClearBtn');
  const savedIndicator = document.getElementById('notesSavedIndicator');
  if (!textarea || !countEl) return;

  // Update count
  const count = getNotesCount();
  countEl.textContent = count > 0 ? '(' + count + ' doc' + (count !== 1 ? 's' : '') + ')' : '';

  // Load note for current doc
  if (currentDoc) {
    const notes = getHolmNotes();
    textarea.value = notes[currentDoc.docId] || '';
    textarea.disabled = false;
    clearBtn.style.display = textarea.value.trim() ? 'inline-block' : 'none';
  } else {
    textarea.value = '';
    textarea.disabled = true;
    clearBtn.style.display = 'none';
  }

  // Hide saved indicator
  savedIndicator.classList.remove('visible');

  // Remove old listener and attach new one
  textarea.removeEventListener('input', _handleNoteInput);
  textarea.addEventListener('input', _handleNoteInput);
}

function _handleNoteInput() {
  if (!currentDoc) return;
  const textarea = document.getElementById('notesTextarea');
  const clearBtn = document.getElementById('notesClearBtn');
  if (!textarea) return;

  clearBtn.style.display = textarea.value.trim() ? 'inline-block' : 'none';

  // Debounce save (500ms)
  if (_noteSaveTimer) clearTimeout(_noteSaveTimer);
  _noteSaveTimer = setTimeout(function() {
    _saveCurrentNote(textarea.value);
  }, 500);
}

function _saveCurrentNote(text) {
  if (!currentDoc) return;
  const notes = getHolmNotes();
  if (text && text.trim()) {
    notes[currentDoc.docId] = text;
  } else {
    delete notes[currentDoc.docId];
  }
  saveHolmNotes(notes);

  // Update count display
  const countEl = document.getElementById('notesCount');
  if (countEl) {
    const count = getNotesCount();
    countEl.textContent = count > 0 ? '(' + count + ' doc' + (count !== 1 ? 's' : '') + ')' : '';
  }

  // Show "Saved" indicator briefly
  _showSavedIndicator();

  // Update sidebar note icons
  _updateSidebarNoteIcons();
}

function _showSavedIndicator() {
  const el = document.getElementById('notesSavedIndicator');
  if (!el) return;
  el.classList.add('visible');
  if (_noteSavedTimeout) clearTimeout(_noteSavedTimeout);
  _noteSavedTimeout = setTimeout(function() {
    el.classList.remove('visible');
  }, 1500);
}

function clearCurrentNote() {
  if (!currentDoc) return;
  const notes = getHolmNotes();
  delete notes[currentDoc.docId];
  saveHolmNotes(notes);

  const textarea = document.getElementById('notesTextarea');
  if (textarea) textarea.value = '';

  const clearBtn = document.getElementById('notesClearBtn');
  if (clearBtn) clearBtn.style.display = 'none';

  // Update count
  const countEl = document.getElementById('notesCount');
  if (countEl) {
    const count = getNotesCount();
    countEl.textContent = count > 0 ? '(' + count + ' doc' + (count !== 1 ? 's' : '') + ')' : '';
  }

  _showSavedIndicator();
  _updateSidebarNoteIcons();
}

function _updateSidebarNoteIcons() {
  const notes = getHolmNotes();
  document.querySelectorAll('.sidebar-item[data-id]').forEach(function(item) {
    const docId = item.getAttribute('data-id');
    let icon = item.querySelector('.note-icon');
    if (notes[docId] && notes[docId].trim()) {
      if (!icon) {
        icon = document.createElement('span');
        icon.className = 'note-icon';
        icon.title = 'Has personal note';
        icon.innerHTML = '&#9998;';
        item.appendChild(icon);
      }
    } else {
      if (icon) icon.remove();
    }
  });
}

// ─── TABLE OF CONTENTS ──────────────────────────────────────────────────────
function slugify(text) {
  return text.toLowerCase().replace(/[^\w\s-]/g, '').trim().replace(/[\s_]+/g, '-').replace(/-+/g, '-');
}

function renderTOC() {
  const tocList = document.getElementById('tocList');
  if (!currentDoc || !currentDoc.content) {
    tocList.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No headings</span>';
    return;
  }
  const headings = [];
  const regex = /<h([23])[^>]*>(.*?)<\/h\1>/gi;
  let match;
  while ((match = regex.exec(currentDoc.content)) !== null) {
    const level = match[1];
    const rawText = match[2].replace(/<[^>]+>/g, '').trim();
    const id = slugify(rawText);
    headings.push({ level, text: rawText, id });
  }
  if (headings.length === 0) {
    tocList.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No headings</span>';
    return;
  }
  const docBody = document.getElementById('docBody');
  if (docBody) {
    const domHeadings = docBody.querySelectorAll('h2, h3');
    let tocIndex = 0;
    domHeadings.forEach(el => { if (tocIndex < headings.length) { el.id = headings[tocIndex].id; tocIndex++; } });
  }
  tocList.innerHTML = headings.map(h =>
    `<span class="toc-item toc-h${h.level}" onclick="scrollToHeading('${h.id}')">${escHtml(h.text)}</span>`
  ).join('');
}

function scrollToHeading(id) {
  const target = document.getElementById(id);
  const mainContent = document.getElementById('mainContent');
  if (target && mainContent) {
    const offset = target.offsetTop - mainContent.offsetTop;
    mainContent.scrollTo({ top: offset - 16, behavior: 'smooth' });
  }
}

// ─── LOCAL GRAPH ────────────────────────────────────────────────────────────
function renderLocalGraph() {
  const container = document.getElementById('localGraphContainer');
  const tooltip = document.getElementById('localGraphTooltip');
  const oldCanvas = container.querySelector('canvas');
  const canvas = document.createElement('canvas');
  canvas.id = 'localGraphCanvas';
  if (oldCanvas) container.replaceChild(canvas, oldCanvas);
  else container.appendChild(canvas);

  const W = container.clientWidth || 240;
  const H = container.clientHeight || 200;
  const DPR = window.devicePixelRatio || 1;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  const ctx = canvas.getContext('2d');
  ctx.scale(DPR, DPR);

  if (!currentDoc) return;

  const dependsOn = Array.isArray(currentDoc.dependsOn) ? currentDoc.dependsOn : [];
  const dependedBy = Array.isArray(currentDoc.dependedBy) ? currentDoc.dependedBy : [];
  const neighborIds = [...new Set([...dependsOn, ...dependedBy])];

  const nodes = [
    { id: currentDoc.docId, isCenter: true, domain: currentDoc.domain, x: W/2, y: H/2, vx: 0, vy: 0, fx: 0, fy: 0 },
    ...neighborIds.map((id, i) => {
      const doc = docsById[id];
      const angle = (2 * Math.PI * i) / Math.max(neighborIds.length, 1);
      const r = Math.min(W, H) * 0.30;
      return { id, isCenter: false, domain: doc ? doc.domain : null, x: W/2 + r * Math.cos(angle), y: H/2 + r * Math.sin(angle), vx: 0, vy: 0, fx: 0, fy: 0 };
    })
  ];
  const nodeIndex = {};
  nodes.forEach((n, i) => nodeIndex[n.id] = i);

  const edgeSet = new Set();
  const edges = [];
  function addEdge(a, b) {
    const key = [a, b].sort().join('||');
    if (!edgeSet.has(key) && nodeIndex[a] !== undefined && nodeIndex[b] !== undefined) {
      edgeSet.add(key);
      edges.push({ a, b });
    }
  }
  dependsOn.forEach(id => addEdge(currentDoc.docId, id));
  dependedBy.forEach(id => addEdge(id, currentDoc.docId));

  // Force simulation
  const cx = W/2, cy = H/2;
  for (let iter = 0; iter < 120; iter++) {
    nodes.forEach(n => { n.fx = 0; n.fy = 0; });
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const a = nodes[i], b = nodes[j];
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist2 = dx * dx + dy * dy + 0.01;
        const dist = Math.sqrt(dist2);
        const force = 2800 / dist2;
        const ffx = (dx / dist) * force, ffy = (dy / dist) * force;
        a.fx -= ffx; a.fy -= ffy; b.fx += ffx; b.fy += ffy;
      }
    }
    edges.forEach(({ a: aId, b: bId }) => {
      const a = nodes[nodeIndex[aId]], b = nodes[nodeIndex[bId]];
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
      const delta = (dist - 72) * 0.12;
      const ffx = (dx / dist) * delta, ffy = (dy / dist) * delta;
      a.fx += ffx; a.fy += ffy; b.fx -= ffx; b.fy -= ffy;
    });
    nodes.forEach(n => { n.fx += (cx - n.x) * 0.06; n.fy += (cy - n.y) * 0.06; });
    nodes.forEach(n => {
      if (n.isCenter) { n.x = cx; n.y = cy; return; }
      n.vx = (n.vx + n.fx) * 0.82; n.vy = (n.vy + n.fy) * 0.82;
      n.x += n.vx; n.y += n.vy;
      n.x = Math.max(20, Math.min(W - 20, n.x));
      n.y = Math.max(20, Math.min(H - 20, n.y));
    });
  }

  function nodeColor(domain) { return DOMAIN_COLORS[domain] || '#6c7086'; }

  // Draw
  ctx.fillStyle = '#181825'; ctx.fillRect(0, 0, W, H);
  edges.forEach(({ a: aId, b: bId }) => {
    const a = nodes[nodeIndex[aId]], b = nodes[nodeIndex[bId]];
    ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y);
    ctx.strokeStyle = '#45475a'; ctx.lineWidth = 1.2; ctx.stroke();
  });
  nodes.forEach(n => {
    const radius = n.isCenter ? 9 : 6;
    const color = nodeColor(n.domain);
    if (n.isCenter) { ctx.beginPath(); ctx.arc(n.x, n.y, radius + 4, 0, 2 * Math.PI); ctx.fillStyle = color + '33'; ctx.fill(); }
    ctx.beginPath(); ctx.arc(n.x, n.y, radius, 0, 2 * Math.PI); ctx.fillStyle = color; ctx.fill();
    if (n.isCenter) { ctx.strokeStyle = '#cdd6f4'; ctx.lineWidth = 1.5; ctx.stroke(); }
  });

  // Interaction
  function hitTest(px, py) {
    for (let i = nodes.length - 1; i >= 0; i--) {
      const n = nodes[i], r = n.isCenter ? 9 : 6;
      const dx = px - n.x, dy = py - n.y;
      if (dx * dx + dy * dy <= (r + 3) * (r + 3)) return n;
    }
    return null;
  }
  function eventPos(e) { const rect = canvas.getBoundingClientRect(); return { px: e.clientX - rect.left, py: e.clientY - rect.top }; }

  canvas.addEventListener('mousemove', function(e) {
    const { px, py } = eventPos(e);
    const hit = hitTest(px, py);
    if (hit) {
      this.style.cursor = hit.isCenter ? 'default' : 'pointer';
      tooltip.style.display = 'block';
      tooltip.textContent = hit.id;
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top = (e.clientY - 6) + 'px';
    } else {
      this.style.cursor = 'default';
      tooltip.style.display = 'none';
    }
  });
  canvas.addEventListener('mouseleave', function() { tooltip.style.display = 'none'; });
  canvas.addEventListener('click', function(e) {
    const { px, py } = eventPos(e);
    const hit = hitTest(px, py);
    if (hit && !hit.isCenter) openDoc(hit.id);
  });
}

// ─── SEARCH ─────────────────────────────────────────────────────────────────
let searchTimeout;
let searchHistorySelectedIndex = -1;
let searchHistoryFilteredItems = [];

// Search history helpers
function getSearchHistory() {
  try {
    const raw = localStorage.getItem('holm-search-history');
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}

function saveSearchHistory(history) {
  try { localStorage.setItem('holm-search-history', JSON.stringify(history)); } catch (e) {}
}

function addToSearchHistory(query) {
  const q = query.trim();
  if (!q || q.length < 2) return;
  let history = getSearchHistory();
  // Remove duplicate if exists (case-insensitive match)
  history = history.filter(h => h.toLowerCase() !== q.toLowerCase());
  // Add to front
  history.unshift(q);
  // Keep only last 20
  if (history.length > 20) history = history.slice(0, 20);
  saveSearchHistory(history);
}

function removeFromSearchHistory(query) {
  let history = getSearchHistory();
  history = history.filter(h => h !== query);
  saveSearchHistory(history);
  renderSearchHistoryDropdown();
}

function clearSearchHistory() {
  saveSearchHistory([]);
  hideSearchHistoryDropdown();
}

function showSearchHistoryDropdown() {
  const dropdown = document.getElementById('searchHistoryDropdown');
  const searchResults = document.getElementById('searchResults');
  // Don't show if search results are showing
  if (searchResults.classList.contains('active')) return;
  renderSearchHistoryDropdown();
  // Use rAF to trigger CSS transition
  dropdown.style.display = 'block';
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      dropdown.classList.add('visible');
    });
  });
}

function hideSearchHistoryDropdown() {
  const dropdown = document.getElementById('searchHistoryDropdown');
  dropdown.classList.remove('visible');
  searchHistorySelectedIndex = -1;
  // Wait for fade-out transition before hiding
  setTimeout(() => {
    if (!dropdown.classList.contains('visible')) {
      dropdown.style.display = 'none';
    }
  }, 160);
}

function renderSearchHistoryDropdown() {
  const dropdown = document.getElementById('searchHistoryDropdown');
  const input = document.getElementById('searchInput');
  const filterText = input.value.trim().toLowerCase();
  const history = getSearchHistory();

  if (history.length === 0) {
    dropdown.innerHTML = '<div class="search-history-empty">No recent searches</div>';
    searchHistoryFilteredItems = [];
    searchHistorySelectedIndex = -1;
    return;
  }

  // Filter history if user has typed something
  searchHistoryFilteredItems = filterText.length > 0
    ? history.filter(h => h.toLowerCase().includes(filterText))
    : history;

  if (searchHistoryFilteredItems.length === 0) {
    dropdown.innerHTML = '<div class="search-history-empty">No matching history</div>';
    searchHistorySelectedIndex = -1;
    return;
  }

  const headerLabel = filterText.length > 0 ? 'Suggestions' : 'Recent Searches';

  let html = `<div class="search-history-header">${headerLabel}</div>`;
  html += searchHistoryFilteredItems.map((item, i) => `
    <div class="search-history-item${i === searchHistorySelectedIndex ? ' selected' : ''}" data-index="${i}">
      <span class="sh-icon">${filterText.length > 0 ? '&#x2197;' : '&#x29D6;'}</span>
      <span class="sh-text">${escHtml(item)}</span>
      <span class="sh-remove" data-query="${escHtml(item)}" title="Remove">&times;</span>
    </div>
  `).join('');
  html += '<div class="search-history-clear">Clear history</div>';
  dropdown.innerHTML = html;
}

function selectSearchHistoryItem(query) {
  const input = document.getElementById('searchInput');
  input.value = query;
  hideSearchHistoryDropdown();
  doSearch(query);
}

function updateSearchHistorySelection() {
  const dropdown = document.getElementById('searchHistoryDropdown');
  const items = dropdown.querySelectorAll('.search-history-item');
  items.forEach((el, i) => {
    el.classList.toggle('selected', i === searchHistorySelectedIndex);
  });
  // Scroll selected item into view
  if (searchHistorySelectedIndex >= 0 && items[searchHistorySelectedIndex]) {
    items[searchHistorySelectedIndex].scrollIntoView({ block: 'nearest' });
  }
}

// Search input event listeners
document.getElementById('searchInput').addEventListener('input', function() {
  clearTimeout(searchTimeout);
  const q = this.value.trim();
  searchHistorySelectedIndex = -1;

  if (q.length < 2) {
    document.getElementById('searchResults').classList.remove('active');
    // Show filtered history dropdown when typing but below threshold
    if (q.length > 0) {
      renderSearchHistoryDropdown();
      const dropdown = document.getElementById('searchHistoryDropdown');
      dropdown.style.display = 'block';
      requestAnimationFrame(() => dropdown.classList.add('visible'));
    } else {
      showSearchHistoryDropdown();
    }
    return;
  }

  // Hide history dropdown, show search results instead
  hideSearchHistoryDropdown();
  searchTimeout = setTimeout(() => doSearch(q), 250);
});

document.getElementById('searchInput').addEventListener('focus', function() {
  const q = this.value.trim();
  if (q.length >= 2) {
    document.getElementById('searchResults').classList.add('active');
  } else {
    showSearchHistoryDropdown();
  }
});

document.getElementById('searchInput').addEventListener('keydown', function(e) {
  const dropdown = document.getElementById('searchHistoryDropdown');
  if (!dropdown.classList.contains('visible') || searchHistoryFilteredItems.length === 0) return;

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    searchHistorySelectedIndex = Math.min(searchHistorySelectedIndex + 1, searchHistoryFilteredItems.length - 1);
    updateSearchHistorySelection();
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    searchHistorySelectedIndex = Math.max(searchHistorySelectedIndex - 1, -1);
    updateSearchHistorySelection();
  } else if (e.key === 'Enter') {
    if (searchHistorySelectedIndex >= 0 && searchHistorySelectedIndex < searchHistoryFilteredItems.length) {
      e.preventDefault();
      selectSearchHistoryItem(searchHistoryFilteredItems[searchHistorySelectedIndex]);
    }
  } else if (e.key === 'Escape') {
    e.preventDefault();
    hideSearchHistoryDropdown();
  }
});

// Event delegation for history dropdown clicks
document.getElementById('searchHistoryDropdown').addEventListener('mousedown', function(e) {
  // Prevent input blur so dropdown stays interactive
  e.preventDefault();

  const removeBtn = e.target.closest('.sh-remove');
  if (removeBtn) {
    const query = removeBtn.getAttribute('data-query');
    removeFromSearchHistory(query);
    return;
  }

  const item = e.target.closest('.search-history-item');
  if (item) {
    const idx = parseInt(item.getAttribute('data-index'), 10);
    if (idx >= 0 && idx < searchHistoryFilteredItems.length) {
      selectSearchHistoryItem(searchHistoryFilteredItems[idx]);
    }
    return;
  }

  const clearBtn = e.target.closest('.search-history-clear');
  if (clearBtn) {
    clearSearchHistory();
    return;
  }
});

// Dismiss on click outside
document.addEventListener('click', function(e) {
  if (!e.target.closest('.search-box')) {
    document.getElementById('searchResults').classList.remove('active');
    hideSearchHistoryDropdown();
  }
});

async function doSearch(q) {
  try {
    const res = await fetch(`/api/search?q=${encodeURIComponent(q)}`);
    const results = await res.json();
    const container = document.getElementById('searchResults');
    if (results.length === 0) {
      container.innerHTML = '<div class="search-result-item" style="color:var(--text-muted)">No results found</div>';
      showToast('No results found', 'warning');
    } else {
      // Save to history on successful search with results
      addToSearchHistory(q);
      container.innerHTML = results.map(r => `
        <div class="search-result-item" onclick="openDoc('${r.docId}');document.getElementById('searchResults').classList.remove('active');">
          <div class="sr-id">${r.docId}</div>
          <div class="sr-title">${escHtml(r.title)}</div>
          ${r.snippet ? `<div class="sr-snippet">${r.snippet}</div>` : ''}
        </div>
      `).join('');
    }
    container.classList.add('active');
    hideSearchHistoryDropdown();
  } catch (err) {
    console.error('Search failed:', err);
    showToast('Search failed: ' + err.message, 'error');
  }
}

// ─── QUICK OPEN ─────────────────────────────────────────────────────────────
let quickOpenSelectedIndex = -1;
let quickOpenFilteredDocs = [];

// ─── A11Y: FOCUS TRAP UTILITY ────────────────────────────────────────────────
let _a11yTriggerElement = null;
let _a11yTrapHandler = null;

function _a11yTrapFocus(containerEl) {
  if (_a11yTrapHandler) document.removeEventListener('keydown', _a11yTrapHandler);
  _a11yTrapHandler = function(e) {
    if (e.key !== 'Tab') return;
    const focusable = containerEl.querySelectorAll(
      'a[href], button:not([disabled]), input:not([disabled]), textarea:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])'
    );
    if (focusable.length === 0) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    if (e.shiftKey) {
      if (document.activeElement === first) { e.preventDefault(); last.focus(); }
    } else {
      if (document.activeElement === last) { e.preventDefault(); first.focus(); }
    }
  };
  document.addEventListener('keydown', _a11yTrapHandler);
}

function _a11yReleaseTrap() {
  if (_a11yTrapHandler) {
    document.removeEventListener('keydown', _a11yTrapHandler);
    _a11yTrapHandler = null;
  }
  if (_a11yTriggerElement) {
    try { _a11yTriggerElement.focus(); } catch(e) {}
    _a11yTriggerElement = null;
  }
}

function openQuickOpen() {
  _a11yTriggerElement = document.activeElement;
  const overlay = document.getElementById('quickOpen');
  const input = document.getElementById('quickOpenInput');
  overlay.style.display = 'flex';
  input.value = '';
  quickOpenSelectedIndex = -1;
  renderQuickOpenResults('');
  requestAnimationFrame(() => {
    input.focus();
    _a11yTrapFocus(overlay);
  });
}

function closeQuickOpen() {
  document.getElementById('quickOpen').style.display = 'none';
  quickOpenSelectedIndex = -1;
  quickOpenFilteredDocs = [];
  _a11yReleaseTrap();
}

function renderQuickOpenResults(query) {
  const term = query.trim().toLowerCase();
  const container = document.getElementById('quickOpenResults');
  quickOpenFilteredDocs = term.length === 0
    ? allDocs.slice(0, 15)
    : allDocs.filter(d => d.docId.toLowerCase().includes(term) || d.title.toLowerCase().includes(term)).slice(0, 15);

  if (quickOpenFilteredDocs.length === 0) {
    container.innerHTML = `<div class="quick-open-empty">No documents match "${escHtml(query)}"</div>`;
    return;
  }
  container.innerHTML = quickOpenFilteredDocs.map((doc, i) => `
    <div class="quick-open-item${i === quickOpenSelectedIndex ? ' selected' : ''}" data-index="${i}"
         onmousedown="quickOpenSelectDoc('${escHtml(doc.docId)}')">
      <span class="qo-id">${escHtml(doc.docId)}</span>
      <span class="qo-title">${escHtml(doc.title)}</span>
    </div>
  `).join('');
}

function quickOpenSetSelected(index) {
  const items = document.querySelectorAll('.quick-open-item');
  items.forEach(el => el.classList.remove('selected'));
  if (index >= 0 && index < items.length) {
    items[index].classList.add('selected');
    items[index].scrollIntoView({ block: 'nearest' });
  }
  quickOpenSelectedIndex = index;
}

function quickOpenSelectDoc(docId) { closeQuickOpen(); openDoc(docId); }

document.getElementById('quickOpenInput').addEventListener('input', function() {
  quickOpenSelectedIndex = -1;
  renderQuickOpenResults(this.value);
});
document.getElementById('quickOpenInput').addEventListener('keydown', function(e) {
  const total = quickOpenFilteredDocs.length;
  if (e.key === 'ArrowDown') { e.preventDefault(); quickOpenSetSelected(quickOpenSelectedIndex < total - 1 ? quickOpenSelectedIndex + 1 : 0); }
  else if (e.key === 'ArrowUp') { e.preventDefault(); quickOpenSetSelected(quickOpenSelectedIndex > 0 ? quickOpenSelectedIndex - 1 : total - 1); }
  else if (e.key === 'Enter') { e.preventDefault(); const idx = quickOpenSelectedIndex >= 0 ? quickOpenSelectedIndex : 0; const doc = quickOpenFilteredDocs[idx]; if (doc) quickOpenSelectDoc(doc.docId); }
  else if (e.key === 'Escape') { closeQuickOpen(); }
});
document.getElementById('quickOpen').addEventListener('mousedown', function(e) { if (e.target === this) closeQuickOpen(); });

// ─── TOGGLE FUNCTIONS ───────────────────────────────────────────────────────
function toggleSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('sidebarOverlay');
  sidebar.classList.toggle('open');
  overlay.classList.toggle('active');
}

function toggleBacklinks() {
  backlinksPanelOpen = !backlinksPanelOpen;
  document.getElementById('backlinksPanel').classList.toggle('active', backlinksPanelOpen);
  document.getElementById('backlinkToggle').classList.toggle('active', backlinksPanelOpen);
}


// ─── SPLIT PANE VIEW ────────────────────────────────────────────────────────
let splitModeActive = false;
let splitLeftDoc = null;
let splitRightDoc = null;

function isSplitAvailable() {
  return window.innerWidth > 900;
}

function openSplitPicker() {
  if (!currentDoc) { showToast('Open a document first', 'error'); return; }
  if (!isSplitAvailable()) { showToast('Split view requires a wider screen (>900px)', 'error'); return; }
  const overlay = document.getElementById('splitPickerOverlay');
  overlay.classList.add('active');
  const searchInput = document.getElementById('splitPickerSearch');
  searchInput.value = '';
  renderSplitPickerList('');
  setTimeout(function() { searchInput.focus(); }, 50);
}

function closeSplitPicker() {
  document.getElementById('splitPickerOverlay').classList.remove('active');
}

function closeSplitPickerOnOverlay(e) {
  if (e.target === document.getElementById('splitPickerOverlay')) closeSplitPicker();
}

function renderSplitPickerList(query) {
  var body = document.getElementById('splitPickerBody');
  var html = '';
  var lowerQ = query.toLowerCase().trim();

  // Linked docs (dependsOn + dependedBy)
  var linked = [];
  if (currentDoc) {
    var depOn = Array.isArray(currentDoc.dependsOn) ? currentDoc.dependsOn : [];
    var depBy = Array.isArray(currentDoc.dependedBy) ? currentDoc.dependedBy : [];
    var linkIds = new Set([...depOn, ...depBy]);
    linkIds.forEach(function(id) {
      if (id === (currentDoc && currentDoc.docId)) return;
      var meta = docsById[id];
      if (meta) linked.push(meta);
    });
  }

  // Recent docs
  var recent = [];
  try { recent = JSON.parse(localStorage.getItem('holm-recent')) || []; } catch(e) {}
  var recentDocs = recent.filter(function(r) { return r.id !== (currentDoc && currentDoc.docId); })
    .map(function(r) { return docsById[r.id]; }).filter(Boolean).slice(0, 8);

  // Filter
  function matchesQuery(doc) {
    if (!lowerQ) return true;
    return doc.docId.toLowerCase().includes(lowerQ) || doc.title.toLowerCase().includes(lowerQ);
  }

  var filteredLinked = linked.filter(matchesQuery);
  var filteredRecent = recentDocs.filter(matchesQuery);

  // All docs for search fallback
  var filteredAll = [];
  if (lowerQ) {
    var shownIds = new Set();
    filteredLinked.forEach(function(d) { shownIds.add(d.docId); });
    filteredRecent.forEach(function(d) { shownIds.add(d.docId); });
    if (currentDoc) shownIds.add(currentDoc.docId);
    filteredAll = allDocs.filter(function(d) {
      return !shownIds.has(d.docId) && matchesQuery(d);
    }).slice(0, 20);
  }

  if (filteredLinked.length > 0) {
    html += '<div class="split-picker-group-label">Linked Documents</div>';
    filteredLinked.forEach(function(doc) {
      html += '<div class="split-picker-item" onclick="selectSplitDoc(\'' + escHtml(doc.docId) + '\')">';
      html += '<span class="spi-id">' + escHtml(doc.docId) + '</span>';
      html += '<span class="spi-title">' + escHtml(doc.title) + '</span>';
      html += '</div>';
    });
  }

  if (filteredRecent.length > 0) {
    html += '<div class="split-picker-group-label">Recently Viewed</div>';
    filteredRecent.forEach(function(doc) {
      html += '<div class="split-picker-item" onclick="selectSplitDoc(\'' + escHtml(doc.docId) + '\')">';
      html += '<span class="spi-id">' + escHtml(doc.docId) + '</span>';
      html += '<span class="spi-title">' + escHtml(doc.title) + '</span>';
      html += '</div>';
    });
  }

  if (filteredAll.length > 0) {
    html += '<div class="split-picker-group-label">Search Results</div>';
    filteredAll.forEach(function(doc) {
      html += '<div class="split-picker-item" onclick="selectSplitDoc(\'' + escHtml(doc.docId) + '\')">';
      html += '<span class="spi-id">' + escHtml(doc.docId) + '</span>';
      html += '<span class="spi-title">' + escHtml(doc.title) + '</span>';
      html += '</div>';
    });
  }

  if (!html) {
    html = '<div class="split-picker-empty">No documents found</div>';
  }

  body.innerHTML = html;
}

document.getElementById('splitPickerSearch').addEventListener('input', function() {
  renderSplitPickerList(this.value);
});

document.getElementById('splitPickerSearch').addEventListener('keydown', function(e) {
  if (e.key === 'Escape') { closeSplitPicker(); e.stopPropagation(); return; }
  if (e.key === 'Enter') {
    var firstItem = document.querySelector('.split-picker-item');
    if (firstItem) firstItem.click();
    e.preventDefault();
  }
});

async function selectSplitDoc(docId) {
  closeSplitPicker();
  if (!currentDoc) return;
  try {
    var res = await fetch('/api/docs/' + docId);
    if (!res.ok) throw new Error('Not found');
    var rightDoc = await res.json();
    enterSplitMode(currentDoc, rightDoc);
  } catch(err) {
    showToast('Failed to load document: ' + err.message, 'error');
  }
}

function enterSplitMode(leftDoc, rightDoc) {
  splitLeftDoc = leftDoc;
  splitRightDoc = rightDoc;
  splitModeActive = true;

  // Populate left pane
  document.getElementById('splitLeftTitle').textContent = leftDoc.docId + ' — ' + leftDoc.title;
  document.getElementById('splitLeftBody').innerHTML = linkifyDocIds(leftDoc.content);

  // Populate right pane
  document.getElementById('splitRightTitle').textContent = rightDoc.docId + ' — ' + rightDoc.title;
  document.getElementById('splitRightBody').innerHTML = linkifyDocIds(rightDoc.content);

  // Activate split wrapper (hides mainContent via CSS sibling selector)
  document.getElementById('splitPaneWrapper').classList.add('active');

  // Update split button state
  var splitBtn = document.getElementById('splitBtn');
  if (splitBtn) splitBtn.classList.add('active');

  // Scroll both panes to top
  document.getElementById('splitPaneLeft').scrollTop = 0;
  document.getElementById('splitPaneRight').scrollTop = 0;
}

function exitSplitMode() {
  if (!splitModeActive) return;
  splitModeActive = false;
  splitLeftDoc = null;
  splitRightDoc = null;

  document.getElementById('splitPaneWrapper').classList.remove('active');
  var splitBtn = document.getElementById('splitBtn');
  if (splitBtn) splitBtn.classList.remove('active');
}

function closeSplitPane(side) {
  if (side === 'right' && splitLeftDoc) {
    // Close right pane, navigate to left doc
    var leftId = splitLeftDoc.docId;
    exitSplitMode();
    openDoc(leftId, true);
  } else if (side === 'left' && splitRightDoc) {
    // Close left pane, navigate to right doc
    var rightId = splitRightDoc.docId;
    exitSplitMode();
    openDoc(rightId, true);
  } else {
    exitSplitMode();
  }
}

function toggleSplitMode() {
  if (splitModeActive) {
    exitSplitMode();
  } else {
    openSplitPicker();
  }
}

// Split divider drag to resize
(function() {
  var divider = document.getElementById('splitDivider');
  var wrapper = document.getElementById('splitPaneWrapper');
  var leftPane = document.getElementById('splitPaneLeft');
  var rightPane = document.getElementById('splitPaneRight');
  var isDragging = false;

  divider.addEventListener('mousedown', function(e) {
    isDragging = true;
    divider.classList.add('dragging');
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', function(e) {
    if (!isDragging) return;
    var rect = wrapper.getBoundingClientRect();
    var x = e.clientX - rect.left;
    var totalWidth = rect.width;
    var ratio = Math.max(0.2, Math.min(0.8, x / totalWidth));
    leftPane.style.flex = 'none';
    rightPane.style.flex = 'none';
    leftPane.style.width = (ratio * 100) + '%';
    rightPane.style.width = ((1 - ratio) * 100) + '%';
  });

  document.addEventListener('mouseup', function() {
    if (!isDragging) return;
    isDragging = false;
    divider.classList.remove('dragging');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });
})();

// ─── FULLSCREEN / FOCUS MODE ────────────────────────────────────────────────
let fullscreenMode = false;
let _backlinksPanelWasOpen = false;

function toggleFullscreen() {
  fullscreenMode = !fullscreenMode;
  document.body.classList.toggle('fullscreen-mode', fullscreenMode);

  if (fullscreenMode) {
    // Remember backlinks state before hiding
    _backlinksPanelWasOpen = backlinksPanelOpen;
  } else {
    // Restore backlinks panel if it was open before entering fullscreen
    if (_backlinksPanelWasOpen && !backlinksPanelOpen) {
      backlinksPanelOpen = true;
      document.getElementById('backlinksPanel').classList.add('active');
      document.getElementById('backlinkToggle').classList.add('active');
    }
  }
}


// ─── ZEN MODE ────────────────────────────────────────────────────────────
let zenMode = false;
let _zenScrollPos = 0;
let _zenMouseTimer = null;

function toggleZenMode() {
  if (!zenMode && !currentDoc) return;
  zenMode = !zenMode;

  const mainContent = document.getElementById('mainContent');
  const zenExitBtn = document.getElementById('zenExitBtn');

  if (zenMode) {
    _zenScrollPos = mainContent.scrollTop;
    document.body.classList.add('zen-mode');
    requestAnimationFrame(() => { mainContent.scrollTop = _zenScrollPos; });
    zenExitBtn.classList.add('visible');
    _startZenMouseTimer();
    document.addEventListener('mousemove', _onZenMouseMove);
  } else {
    _zenScrollPos = mainContent.scrollTop;
    document.body.classList.remove('zen-mode');
    requestAnimationFrame(() => { mainContent.scrollTop = _zenScrollPos; });
    zenExitBtn.classList.remove('visible');
    document.removeEventListener('mousemove', _onZenMouseMove);
    if (_zenMouseTimer) { clearTimeout(_zenMouseTimer); _zenMouseTimer = null; }
  }
}

function _onZenMouseMove() {
  const zenExitBtn = document.getElementById('zenExitBtn');
  zenExitBtn.classList.add('visible');
  _startZenMouseTimer();
}

function _startZenMouseTimer() {
  if (_zenMouseTimer) clearTimeout(_zenMouseTimer);
  _zenMouseTimer = setTimeout(() => {
    const zenExitBtn = document.getElementById('zenExitBtn');
    zenExitBtn.classList.remove('visible');
  }, 2000);
}

// ─── SHORTCUTS MODAL ────────────────────────────────────────────────────────
function showShortcutsModal() {
  _a11yTriggerElement = document.activeElement;
  const modal = document.getElementById('shortcutsModal');
  modal.classList.add('active');
  requestAnimationFrame(() => {
    const closeBtn = modal.querySelector('.shortcuts-modal-close');
    if (closeBtn) closeBtn.focus();
    _a11yTrapFocus(modal);
  });
}
function hideShortcutsModal() {
  document.getElementById('shortcutsModal').classList.remove('active');
  _a11yReleaseTrap();
}
function closeShortcutsModal(event) { if (event.target === document.getElementById('shortcutsModal')) hideShortcutsModal(); }

// ─── CODE BLOCK COPY BUTTONS ────────────────────────────────────────────────
function addCopyButtons() {
  const docBody = document.getElementById('docBody');
  if (!docBody) return;
  docBody.querySelectorAll('pre').forEach(pre => {
    if (pre.querySelector('.code-copy-btn')) return;
    const btn = document.createElement('button');
    btn.className = 'code-copy-btn';
    btn.textContent = 'Copy';
    btn.addEventListener('click', function() {
      const code = pre.querySelector('code');
      const text = code ? code.textContent : pre.textContent;
      navigator.clipboard.writeText(text).then(() => {
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        showToast('Copied to clipboard', 'success');
        setTimeout(() => {
          btn.textContent = 'Copy';
          btn.classList.remove('copied');
        }, 1500);
      });
    });
    pre.appendChild(btn);
  });
}


// ─── SYNTAX HIGHLIGHTING FOR CODE BLOCKS ────────────────────────────────────
function highlightCodeBlocks() {
  const docBody = document.getElementById('docBody');
  if (!docBody) return;
  docBody.querySelectorAll('pre > code').forEach(codeEl => {
    if (codeEl.dataset.synHighlighted) return;
    codeEl.dataset.synHighlighted = '1';
    const raw = codeEl.innerHTML;
    const rules = [
      // Block comments: /* ... */
      { re: /(\/\*[\s\S]*?\*\/)/g, cls: 'syn-comment' },
      // Line comments: // ...
      { re: /(\/\/[^\n]*)/g, cls: 'syn-comment' },
      // Template literals
      { re: /(`(?:[^`\\]|\\.)*`)/g, cls: 'syn-string' },
      // Double-quoted strings
      { re: /("(?:[^"\\]|\\.)*")/g, cls: 'syn-string' },
      // Single-quoted strings
      { re: /('(?:[^'\\]|\\.)*')/g, cls: 'syn-string' },
      // HTML tags: <tagname ...> and </tagname>
      { re: /(&lt;\/?)([\w-]+)([\s\S]*?)(&gt;)/g, cls: null, handler: function(m) {
        return '<span class="syn-tag">' + m[1] + m[2] + '</span>' +
               m[3].replace(/([\w-]+)(=)/g, '<span class="syn-attr">$1</span>$2') +
               '<span class="syn-tag">' + m[4] + '</span>';
      }},
      // Keywords (whole word)
      { re: /\b(function|const|let|var|return|if|else|for|while|class|import|export|async|await|try|catch|throw|new|this|true|false|null|undefined)\b/g, cls: 'syn-keyword' },
      // Numbers (integers, floats, hex, binary, octal)
      { re: /\b(0[xXbBoO][\da-fA-F_]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/g, cls: 'syn-number' }
    ];
    // Gather all matches with their positions
    const allMatches = [];
    for (let ri = 0; ri < rules.length; ri++) {
      const rule = rules[ri];
      const re = new RegExp(rule.re.source, rule.re.flags);
      let m;
      while ((m = re.exec(raw)) !== null) {
        allMatches.push({ index: m.index, length: m[0].length, match: m, rule: rule });
      }
    }
    // Sort by position; if same position, longer match wins
    allMatches.sort((a, b) => a.index - b.index || b.length - a.length);
    let result = '';
    let pos = 0;
    for (let i = 0; i < allMatches.length; i++) {
      const tok = allMatches[i];
      if (tok.index < pos) continue; // skip overlapping
      result += raw.slice(pos, tok.index);
      if (tok.rule.handler) {
        result += tok.rule.handler(tok.match);
      } else {
        result += '<span class="' + tok.rule.cls + '">' + tok.match[0] + '</span>';
      }
      pos = tok.index + tok.length;
    }
    result += raw.slice(pos);
    codeEl.innerHTML = result;
  });
}
// ─── WORD COUNT & READING TIME ──────────────────────────────────────────────
function updateReadingInfo() {
  const el = document.getElementById('docReadingInfo');
  if (!currentDoc || !currentDoc.content) { el.textContent = ''; return; }
  const plainText = currentDoc.content.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
  const words = plainText ? plainText.split(/\s+/).length : 0;
  const minutes = Math.max(1, Math.ceil(words / 200));
  const formatted = words.toLocaleString();
  el.textContent = `${formatted} words \u00b7 ${minutes} min read`;
}

// ─── FAVORITES / BOOKMARKS ──────────────────────────────────────────────────
const FAVORITES_KEY = 'holm-favorites';

function getFavorites() {
  try {
    const raw = localStorage.getItem(FAVORITES_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) {
    return [];
  }
}

function saveFavorites(favs) {
  localStorage.setItem(FAVORITES_KEY, JSON.stringify(favs));
}

function isFavorite(docId) {
  return getFavorites().includes(docId);
}

function toggleFavorite() {
  if (!currentDoc) return;
  const favs = getFavorites();
  const idx = favs.indexOf(currentDoc.docId);
  const wasAdded = idx === -1;
  if (wasAdded) {
    favs.push(currentDoc.docId);
  } else {
    favs.splice(idx, 1);
  }
  saveFavorites(favs);
  updateFavoriteBtn();
  renderSidebar();
  showToast(wasAdded ? 'Added to favorites' : 'Removed from favorites', 'info');
  // Re-highlight the active sidebar item after re-render
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) activeItem.classList.add('active');
  }
}

function removeFavorite(docId, event) {
  if (event) { event.stopPropagation(); }
  const favs = getFavorites();
  const idx = favs.indexOf(docId);
  if (idx !== -1) {
    favs.splice(idx, 1);
    saveFavorites(favs);
    updateFavoriteBtn();
    renderSidebar();
    if (currentDoc) {
      const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
      if (activeItem) activeItem.classList.add('active');
    }
  }
}

function updateFavoriteBtn() {
  const btn = document.getElementById('favoriteBtn');
  if (!btn || !currentDoc) return;
  const faved = isFavorite(currentDoc.docId);
  btn.classList.toggle('favorited', faved);
  btn.innerHTML = faved ? '&#9733;' : '&#9734;';
  btn.title = faved ? 'Remove from favorites' : 'Add to favorites';
}

function buildFavoritesHtml() {
  const favs = getFavorites();
  if (favs.length === 0) {
    return '<div class="sidebar-section favorites-section">' +
      '<div class="sidebar-section-header" onclick="toggleSection(this)">' +
      '<span class="chevron">\u25BC</span>\u2605 Favorites <span style="margin-left:auto;font-size:10px;opacity:0.6">0</span>' +
      '</div>' +
      '<div class="sidebar-items-wrap" style="height:auto"><div class="sidebar-items">' +
      '<div class="sidebar-items-empty">No favorites yet</div>' +
      '</div></div></div>';
  }
  let items = '';
  for (const docId of favs) {
    const doc = docsById[docId];
    const title = doc ? doc.title : docId;
    items += '<div class="sidebar-item" data-id="' + docId + '" onclick="openDoc(\'' + docId + '\')">' +
      '<span class="doc-id">' + docId + '</span>' +
      '<span class="doc-title">' + escHtml(title) + '</span>' +
      '<span class="fav-remove" onclick="removeFavorite(\'' + docId + '\', event)" title="Remove favorite">\u2715</span>' +
      '</div>';
  }
  return '<div class="sidebar-section favorites-section">' +
    '<div class="sidebar-section-header" onclick="toggleSection(this)">' +
    '<span class="chevron">\u25BC</span>\u2605 Favorites <span style="margin-left:auto;font-size:10px;opacity:0.6">' + favs.length + '</span>' +
    '</div>' +
    '<div class="sidebar-items-wrap" style="height:auto"><div class="sidebar-items">' + items + '</div></div></div>';
}

// ─── DOC BADGES ──────────────────────────────────────────────────────────
function getStatusBadgeClass(status) {
  if (!status) return 'badge-status-other';
  const s = status.toLowerCase().trim();
  if (s === 'ratified') return 'badge-status-ratified';
  if (s === 'draft') return 'badge-status-draft';
  if (s === 'active') return 'badge-status-active';
  if (s === 'deprecated') return 'badge-status-deprecated';
  return 'badge-status-other';
}

function renderDocBadges() {
  const el = document.getElementById('docBadges');
  if (!currentDoc) { el.innerHTML = ''; return; }
  let html = '';
  if (currentDoc.version) {
    html += '<span class="doc-badge-pill badge-version">v' + escHtml(currentDoc.version) + '</span>';
  }
  if (currentDoc.status) {
    const cls = getStatusBadgeClass(currentDoc.status);
    html += '<span class="doc-badge-pill ' + cls + '">' + escHtml(currentDoc.status) + '</span>';
  }
  if (currentDoc.date) {
    html += '<span class="doc-badge-pill badge-date">' + escHtml(currentDoc.date) + '</span>';
  }
  el.innerHTML = html;
}

// ─── UTILITY ────────────────────────────────────────────────────────────────
function escHtml(s) {
  if (!s) return '';
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function navigateDoc(direction) {
  if (!allDocs.length) return;
  if (!currentDoc) { openDoc(direction === 'next' ? allDocs[0].docId : allDocs[allDocs.length - 1].docId); return; }
  const idx = allDocs.findIndex(d => d.docId === currentDoc.docId);
  if (idx === -1) return;
  const target = direction === 'prev' ? idx - 1 : idx + 1;
  if (target < 0 || target >= allDocs.length) return;
  openDoc(allDocs[target].docId);
}

function navBack() {
  if (navHistoryPos <= 0) return;
  navHistoryPos--;
  navIsTraversing = true;
  openDoc(navHistory[navHistoryPos], true).then(() => {
    navIsTraversing = false;
    updateNavButtons();
  });
}

function navForward() {
  if (navHistoryPos >= navHistory.length - 1) return;
  navHistoryPos++;
  navIsTraversing = true;
  openDoc(navHistory[navHistoryPos], true).then(() => {
    navIsTraversing = false;
    updateNavButtons();
  });
}

function updateNavButtons() {
  const backBtn = document.getElementById('btnNavBack');
  const fwdBtn = document.getElementById('btnNavForward');
  if (backBtn) backBtn.disabled = navHistoryPos <= 0;
  if (fwdBtn) fwdBtn.disabled = navHistoryPos >= navHistory.length - 1;
}

// ─── KEYBOARD NAVIGATION ───────────────────────────────────────────────────
function isTypingTarget() {
  const el = document.activeElement;
  return el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || el.isContentEditable);
}

document.addEventListener('keydown', function(e) {
  const mod = (navigator.platform.toUpperCase().includes('MAC') ? e.metaKey : e.ctrlKey);

  if (mod && e.key === 'k') { e.preventDefault(); const o = document.getElementById('quickOpen'); if (o.style.display === 'none') openQuickOpen(); else closeQuickOpen(); return; }
  if (mod && e.key === 'e') { e.preventDefault(); if (currentDoc) setViewMode(viewMode === 'edit' ? 'preview' : 'edit'); return; }
  if (mod && e.shiftKey && (e.key === 's' || e.key === 'S')) { e.preventDefault(); toggleSplitMode(); return; }
  if (mod && e.key === 's') { e.preventDefault(); if (currentDoc && viewMode === 'edit') saveDoc(); return; }
  if (mod && e.key === 'g') { e.preventDefault(); window.open('/graph.html', '_blank'); return; }
  if (mod && e.key === 'b') { e.preventDefault(); toggleBacklinks(); return; }
  if (mod && e.shiftKey && (e.key === 'f' || e.key === 'F')) { e.preventDefault(); toggleFullscreen(); return; }
  if (mod && !e.shiftKey && e.key === 'f') { if (currentDoc && viewMode !== 'edit') { e.preventDefault(); window.findInDoc.open(); return; } }
  if (mod && e.shiftKey && (e.key === 't' || e.key === 'T')) { e.preventDefault(); if (typeof toggleFloatingToc === 'function') toggleFloatingToc(); return; }
  if (mod && e.shiftKey && (e.key === 'z' || e.key === 'Z')) { e.preventDefault(); toggleZenMode(); return; }
  if (mod && e.key === '\\') { e.preventDefault(); toggleSidebar(); return; }
  if (mod && e.key === '[') { e.preventDefault(); window.history.back(); return; }
  if (mod && e.key === ']') { e.preventDefault(); window.history.forward(); return; }
  if (e.altKey && e.key === 'ArrowUp') { e.preventDefault(); navigateDoc('prev'); return; }
  if (e.altKey && e.key === 'ArrowDown') { e.preventDefault(); navigateDoc('next'); return; }
  if (e.altKey && e.key === 'ArrowLeft') { e.preventDefault(); navBack(); return; }
  if (e.altKey && e.key === 'ArrowRight') { e.preventDefault(); navForward(); return; }

  if (e.key === 'Escape') {
    if (window.findInDoc && window.findInDoc.isOpen()) { window.findInDoc.close(); return; }
    const wco = document.getElementById('wordcloudOverlay');
    if (wco && wco.classList.contains('active')) { closeWordCloud(); return; }
    const sp = document.getElementById('splitPickerOverlay');
    if (sp && sp.classList.contains('active')) { closeSplitPicker(); return; }
    if (splitModeActive) { exitSplitMode(); return; }
    const so = document.getElementById('statsOverlay');
    if (so && so.classList.contains('active')) { closeStatsDashboard(); return; }
    const sm = document.getElementById('shortcutsModal');
    if (sm && sm.classList.contains('active')) { hideShortcutsModal(); return; }
    const qo = document.getElementById('quickOpen');
    if (qo && qo.style.display !== 'none') { closeQuickOpen(); return; }
    if (zenMode) { toggleZenMode(); return; }
    if (fullscreenMode) { toggleFullscreen(); return; }
    if (currentDoc && viewMode === 'edit') { setViewMode('preview'); return; }
  }

  if (e.key === '?' && !mod && !e.altKey && !isTypingTarget()) { e.preventDefault(); showShortcutsModal(); }
});


// ─── RECENTLY VIEWED ────────────────────────────────────────────────────────
const RECENT_KEY = 'holm-recent';
const RECENT_MAX = 10;

function getRecentDocs() {
  try {
    return JSON.parse(localStorage.getItem(RECENT_KEY)) || [];
  } catch { return []; }
}

function addToRecent(docId, title) {
  let recent = getRecentDocs();
  // Remove existing entry for this docId (dedup)
  recent = recent.filter(r => r.id !== docId);
  // Add to front
  recent.unshift({ id: docId, title: title });
  // Cap at max
  if (recent.length > RECENT_MAX) recent = recent.slice(0, RECENT_MAX);
  localStorage.setItem(RECENT_KEY, JSON.stringify(recent));
}

function clearRecentHistory() {
  localStorage.removeItem(RECENT_KEY);
  renderSidebar();
  // Re-highlight active doc
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) { activeItem.classList.add('active'); }
  }
}

function toggleRecentSection(el) {
  el.closest('.recent-section').classList.toggle('collapsed');
}

function renderRecentSection() {
  const recent = getRecentDocs();
  if (recent.length === 0) return '';
  let items = '';
  for (const r of recent) {
    const safeId = escHtml(r.id);
    const safeTitle = escHtml(r.title);
    items += `<div class="sidebar-item" data-id="${safeId}" onclick="openDoc('${safeId}')">
      <span class="doc-id">${safeId}</span>
      <span class="doc-title">${safeTitle}</span>
    </div>`;
  }
  return `<div class="recent-section">
    <div class="recent-section-header" onclick="toggleRecentSection(this)">
      <span class="chevron">&#9660;</span>Recent
      <button class="recent-clear-btn" onclick="event.stopPropagation(); clearRecentHistory();" title="Clear history">clear</button>
    </div>
    <div class="recent-items">${items}</div>
  </div>`;
}

// ─── DOC LINK PREVIEW TOOLTIPS ──────────────────────────────────────────
const docContentCache = {};
let tooltipTimer = null;
let tooltipActiveLink = null;

function stripHtmlToPlainText(html) {
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  return (tmp.textContent || tmp.innerText || '').replace(/\s+/g, ' ').trim();
}

function positionTooltipEl(el, mouseX, mouseY) {
  const tw = 320, th = el.offsetHeight || 180, pad = 12;
  let left = mouseX + pad, top = mouseY + pad;
  if (left + tw > window.innerWidth - pad) left = mouseX - tw - pad;
  if (left < pad) left = pad;
  if (top + th > window.innerHeight - pad) top = mouseY - th - pad;
  if (top < pad) top = pad;
  el.style.left = left + 'px';
  el.style.top = top + 'px';
}

async function getDocContentForTooltip(docId) {
  if (docContentCache[docId]) return docContentCache[docId];
  if (currentDoc && currentDoc.docId === docId && currentDoc.content) {
    docContentCache[docId] = currentDoc;
    return currentDoc;
  }
  const basicInfo = docsById[docId];
  if (!basicInfo) return null;
  try {
    const res = await fetch('/api/docs/' + docId);
    if (!res.ok) return basicInfo;
    const fullDoc = await res.json();
    docContentCache[docId] = fullDoc;
    return fullDoc;
  } catch (err) {
    return basicInfo;
  }
}

function showDocLinkTooltip(docId, mx, my) {
  const tip = document.getElementById('docLinkTooltip');
  getDocContentForTooltip(docId).then(function(doc) {
    if (!doc || tooltipActiveLink === null) return;
    document.getElementById('tooltipDocId').textContent = doc.docId;
    document.getElementById('tooltipTitle').textContent = doc.title || doc.docId;
    const dEl = document.getElementById('tooltipDomain');
    dEl.textContent = doc.domainName ? 'Domain ' + doc.domain + ': ' + doc.domainName : (doc.domain ? 'Domain ' + doc.domain : '');
    dEl.style.color = DOMAIN_COLORS[doc.domain] || 'var(--text-muted)';
    const exEl = document.getElementById('tooltipExcerpt');
    if (doc.content) {
      const plain = stripHtmlToPlainText(doc.content);
      exEl.textContent = plain.length > 150 ? plain.slice(0, 150) + '...' : plain;
      exEl.style.display = '';
    } else {
      exEl.textContent = '';
      exEl.style.display = 'none';
    }
    const tEl = document.getElementById('tooltipTags');
    if (doc.tags && doc.tags.length > 0) {
      tEl.innerHTML = doc.tags.map(function(t) { return '<span class="doc-link-tooltip-tag">#' + escHtml(t) + '</span>'; }).join('');
      tEl.style.display = '';
    } else {
      tEl.innerHTML = '';
      tEl.style.display = 'none';
    }
    positionTooltipEl(tip, mx, my);
    tip.classList.add('visible');
  });
}

function hideDocLinkTooltip() {
  clearTimeout(tooltipTimer);
  tooltipTimer = null;
  tooltipActiveLink = null;
  document.getElementById('docLinkTooltip').classList.remove('visible');
}

document.getElementById('docBody').addEventListener('mouseenter', function(e) {
  const link = e.target.closest('a.doc-link');
  if (!link) return;
  const docId = link.textContent.trim();
  if (currentDoc && currentDoc.docId === docId) return;
  if (!docsById[docId]) return;
  tooltipActiveLink = link;
  clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(function() {
    if (tooltipActiveLink === link) {
      const rect = link.getBoundingClientRect();
      showDocLinkTooltip(docId, rect.left + rect.width / 2, rect.bottom);
    }
  }, 300);
}, true);

document.getElementById('docBody').addEventListener('mouseleave', function(e) {
  const link = e.target.closest('a.doc-link');
  if (!link) return;
  hideDocLinkTooltip();
}, true);

document.getElementById('mainContent').addEventListener('scroll', function() {
  if (tooltipActiveLink) hideDocLinkTooltip();
}, { passive: true });

// ─── HASH ROUTING ───────────────────────────────────────────────────────────
window.addEventListener('hashchange', () => {
  const hashParts = parseHashWithHighlight(window.location.hash);
  const id = hashParts.docId;
  if (id && docsById[id] && (!currentDoc || currentDoc.docId !== id)) {
    openDoc(id).then(function() {
      if (hashParts.highlight) {
        setTimeout(function() { applySharedHighlight(hashParts.highlight); }, 300);
      }
    });
  }
});


// ─── TEXT SHARE LINK ─────────────────────────────────────────────────────────
(function() {
  var shareBtn = document.getElementById('textShareBtn');
  if (!shareBtn) return;
  var hideTimer = null;

  function getSelectedTextInDocBody() {
    var sel = document.getSelection();
    if (!sel || sel.isCollapsed || !sel.rangeCount) return '';
    var range = sel.getRangeAt(0);
    var docBody = document.getElementById('docBody');
    if (!docBody || !docBody.contains(range.commonAncestorContainer)) return '';
    return sel.toString().trim();
  }

  function showShareButton() {
    var sel = document.getSelection();
    if (!sel || !sel.rangeCount) return;
    var range = sel.getRangeAt(0);
    var rect = range.getBoundingClientRect();
    if (!rect.width && !rect.height) return;

    var mainContent = document.getElementById('mainContent');
    var containerRect = mainContent ? mainContent.getBoundingClientRect() : document.body.getBoundingClientRect();

    // Position above the selection
    var left = rect.left + (rect.width / 2) - 40;
    var top = rect.top - 36;

    // If too close to top, show below instead
    if (top < containerRect.top + 4) {
      top = rect.bottom + 6;
    }

    // Clamp to viewport
    if (left < 4) left = 4;
    if (left + 80 > window.innerWidth - 4) left = window.innerWidth - 84;

    shareBtn.style.left = left + 'px';
    shareBtn.style.top = top + 'px';
    shareBtn.classList.add('visible');
  }

  function hideShareButton() {
    shareBtn.classList.remove('visible');
  }

  // Listen for selection changes
  document.addEventListener('selectionchange', function() {
    clearTimeout(hideTimer);
    var text = getSelectedTextInDocBody();
    if (text.length > 0) {
      showShareButton();
    } else {
      // Small delay before hiding to allow clicking the button
      hideTimer = setTimeout(hideShareButton, 200);
    }
  });

  // Handle share button click
  shareBtn.addEventListener('mousedown', function(e) {
    // Prevent the selection from being cleared
    e.preventDefault();
    e.stopPropagation();
  });

  shareBtn.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    var text = getSelectedTextInDocBody();
    if (!text || !currentDoc) return;

    // Truncate to 100 chars
    var truncated = text.substring(0, 100);
    var encoded = encodeURIComponent(truncated).replace(/%20/g, '+');
    var url = window.location.origin + window.location.pathname + '#' + currentDoc.docId + '?highlight=' + encoded;

    navigator.clipboard.writeText(url).then(function() {
      showToast('Link copied!', 'success');
    }).catch(function() {
      // Fallback: create a temporary input
      var tmp = document.createElement('input');
      tmp.value = url;
      document.body.appendChild(tmp);
      tmp.select();
      document.execCommand('copy');
      document.body.removeChild(tmp);
      showToast('Link copied!', 'success');
    });

    // Clear selection and hide button
    document.getSelection().removeAllRanges();
    hideShareButton();
  });

  // Hide share button on scroll
  var mainContent = document.getElementById('mainContent');
  if (mainContent) {
    mainContent.addEventListener('scroll', function() {
      if (shareBtn.classList.contains('visible')) {
        var text = getSelectedTextInDocBody();
        if (text.length > 0) {
          showShareButton(); // Reposition
        } else {
          hideShareButton();
        }
      }
    }, { passive: true });
  }
})();

// ─── SCROLL TO TOP ──────────────────────────────────────────────────────────
(function() {
  const mainContent = document.getElementById('mainContent');
  const scrollBtn = document.getElementById('scrollToTop');
  if (!mainContent || !scrollBtn) return;

  mainContent.addEventListener('scroll', function() {
    if (mainContent.scrollTop > 300) {
      scrollBtn.classList.add('visible');
    } else {
      scrollBtn.classList.remove('visible');
    }
  });

  scrollBtn.addEventListener('click', function() {
    mainContent.scrollTo({ top: 0, behavior: 'smooth' });
  });
})();

// ─── READING PROGRESS BAR ───────────────────────────────────────────────────
(function() {
  const mainContent = document.getElementById('mainContent');
  const progressBar = document.getElementById('readingProgressBar');
  if (\!mainContent || \!progressBar) return;

  function updateProgressBar() {
    const docViewer = document.getElementById('docViewer');
    const isDocOpen = docViewer && docViewer.classList.contains('active');
    const scrollHeight = mainContent.scrollHeight;
    const clientHeight = mainContent.clientHeight;
    const isScrollable = scrollHeight > clientHeight + 10;

    if (\!isDocOpen || \!isScrollable) {
      progressBar.classList.remove('visible');
      progressBar.style.width = '0%';
      return;
    }

    progressBar.classList.add('visible');
    const scrollTop = mainContent.scrollTop;
    const maxScroll = scrollHeight - clientHeight;
    const pct = Math.min(100, Math.max(0, (scrollTop / maxScroll) * 100));
    progressBar.style.width = pct + '%';
  }

  mainContent.addEventListener('scroll', updateProgressBar, { passive: true });

  // Observe class changes on docViewer to detect open/close
  const docViewer = document.getElementById('docViewer');
  if (docViewer) {
    const observer = new MutationObserver(updateProgressBar);
    observer.observe(docViewer, { attributes: true, attributeFilter: ['class'] });
  }

  // Also update on window resize (content may become scrollable/non-scrollable)
  window.addEventListener('resize', updateProgressBar, { passive: true });
})();

// ─── STATS DASHBOARD ────────────────────────────────────────────────────────
async function openStatsDashboard() {
  _a11yTriggerElement = document.activeElement;
  const overlay = document.getElementById('statsOverlay');
  overlay.classList.add('active');
  await renderStatsDashboard();
  requestAnimationFrame(() => {
    const closeBtn = overlay.querySelector('.stats-close-btn');
    if (closeBtn) closeBtn.focus();
    _a11yTrapFocus(overlay);
  });
}

function closeStatsDashboard() {
  document.getElementById('statsOverlay').classList.remove('active');
  _a11yReleaseTrap();
}

async function renderStatsDashboard() {
  const container = document.getElementById('statsDashboardContent');

  // Compute domain groups
  const domainMap = {};
  let totalEdges = 0;
  const connectionCounts = {};

  allDocs.forEach(doc => {
    const key = doc.domain || 'Other';
    const name = doc.domainName || key;
    if (!domainMap[key]) domainMap[key] = { name, count: 0 };
    domainMap[key].count++;

    const depOn = Array.isArray(doc.dependsOn) ? doc.dependsOn.length : 0;
    const depBy = Array.isArray(doc.dependedBy) ? doc.dependedBy.length : 0;
    totalEdges += depOn;
    connectionCounts[doc.docId] = {
      total: depOn + depBy,
      dependsOn: depOn,
      dependedBy: depBy,
      title: doc.title
    };
  });

  // Sort domains
  const domainKeys = Object.keys(domainMap).sort((a, b) => {
    const na = parseInt(a), nb = parseInt(b);
    if (!isNaN(na) && !isNaN(nb)) return na - nb;
    if (!isNaN(na)) return -1;
    if (!isNaN(nb)) return 1;
    return a.localeCompare(b);
  });

  const maxDomainCount = Math.max(...domainKeys.map(k => domainMap[k].count), 1);
  const domainCount = domainKeys.length;

  // Top 10 most connected docs
  const topConnected = Object.entries(connectionCounts)
    .sort((a, b) => b[1].total - a[1].total)
    .slice(0, 10);

  // Fetch tags from API
  let tagData = [];
  try {
    const tagRes = await fetch('/api/tags');
    if (tagRes.ok) {
      tagData = await tagRes.json();
    }
  } catch (e) {
    // Fallback: compute tags from allDocs
  }

  // If API didn't return tags, compute from allDocs
  if (!tagData || tagData.length === 0) {
    const tagCounts = {};
    allDocs.forEach(doc => {
      if (doc.tags && Array.isArray(doc.tags)) {
        doc.tags.forEach(t => {
          tagCounts[t] = (tagCounts[t] || 0) + 1;
        });
      }
    });
    tagData = Object.entries(tagCounts)
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count);
  }

  // If tagData is an object with tag->count, normalize
  if (tagData && !Array.isArray(tagData)) {
    tagData = Object.entries(tagData)
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count);
  }

  const topTags = (tagData || []).slice(0, 10);
  const maxTagCount = topTags.length > 0 ? Math.max(...topTags.map(t => t.count), 1) : 1;

  // Build HTML
  let html = '';

  // Summary cards
  html += '<div class="stats-summary">';
  html += '<div class="stats-card"><div class="stats-card-num">' + allDocs.length + '</div><div class="stats-card-label">Total Documents</div></div>';
  html += '<div class="stats-card"><div class="stats-card-num">' + domainCount + '</div><div class="stats-card-label">Domains</div></div>';
  html += '<div class="stats-card"><div class="stats-card-num">' + totalEdges + '</div><div class="stats-card-label">Dependency Edges</div></div>';
  html += '<div class="stats-card"><div class="stats-card-num">' + topTags.length + '</div><div class="stats-card-label">Unique Tags</div></div>';
  html += '</div>';

  // Domain bar chart
  html += '<div class="stats-section"><h3>Documents per Domain</h3><div class="stats-bar-chart">';
  domainKeys.forEach(key => {
    const d = domainMap[key];
    const pct = (d.count / maxDomainCount * 100).toFixed(1);
    const color = DOMAIN_COLORS[key] || '#6c7086';
    html += '<div class="stats-bar-row">';
    html += '<div class="stats-bar-label" title="D' + escHtml(key) + ' ' + escHtml(d.name) + '">D' + escHtml(key) + ' ' + escHtml(d.name) + '</div>';
    html += '<div class="stats-bar-track"><div class="stats-bar-fill" style="width:' + pct + '%;background:' + color + '"></div></div>';
    html += '<div class="stats-bar-value">' + d.count + '</div>';
    html += '</div>';
  });
  html += '</div></div>';

  // Two-column layout for tables
  html += '<div class="stats-columns">';

  // Top 10 most connected
  html += '<div class="stats-section"><h3>Top 10 Most Connected Documents</h3>';
  html += '<table class="stats-table"><thead><tr><th>Document</th><th style="text-align:right">Links</th></tr></thead><tbody>';
  topConnected.forEach(([docId, info]) => {
    html += '<tr>';
    html += '<td><span class="st-docid" onclick="closeStatsDashboard();openDoc(\'' + escHtml(docId) + '\')">' + escHtml(docId) + '</span><br><span style="font-size:11px;color:var(--text-muted)">' + escHtml(info.title) + '</span></td>';
    html += '<td class="st-num">' + info.total + '<br><span style="font-size:10px;color:var(--text-muted)">' + info.dependsOn + ' out / ' + info.dependedBy + ' in</span></td>';
    html += '</tr>';
  });
  html += '</tbody></table></div>';

  // Top 10 tags
  html += '<div class="stats-section"><h3>Top 10 Tags</h3>';
  if (topTags.length > 0) {
    html += '<div class="stats-bar-chart">';
    topTags.forEach(t => {
      const pct = (t.count / maxTagCount * 100).toFixed(1);
      html += '<div class="stats-bar-row">';
      html += '<div class="stats-bar-label" style="min-width:100px;max-width:140px;cursor:pointer" onclick="closeStatsDashboard();filterByTag(\'' + escHtml(t.tag) + '\')">#' + escHtml(t.tag) + '</div>';
      html += '<div class="stats-bar-track"><div class="stats-bar-fill" style="width:' + pct + '%;background:var(--mauve)"></div></div>';
      html += '<div class="stats-bar-value">' + t.count + '</div>';
      html += '</div>';
    });
    html += '</div>';
  } else {
    html += '<span style="color:var(--text-muted);font-size:13px">No tags available</span>';
  }
  html += '</div>';

  html += '</div>'; // close stats-columns

  container.innerHTML = html;
}

</script>

<!-- STATS DASHBOARD OVERLAY -->
<div class="stats-overlay" id="statsOverlay" onclick="if(event.target===this)closeStatsDashboard()" role="dialog" aria-label="Domain statistics dashboard" aria-modal="true">
  <div class="stats-dashboard">
    <div class="stats-dashboard-header">
      <h2>Domain Statistics Dashboard</h2>
      <button class="stats-close-btn" onclick="closeStatsDashboard()" aria-label="Close statistics dashboard">&times;</button>
    </div>
    <div id="statsDashboardContent">
      <div class="loading"><div class="spinner"></div>Loading statistics...</div>
    </div>
  </div>
</div>


<!-- IMAGE ZOOM LIGHTBOX -->
<div class="lightbox-overlay" id="lightboxOverlay" role="dialog" aria-label="Image viewer" aria-modal="true">
  <button class="lightbox-close" id="lightboxClose" title="Close (Esc)" aria-label="Close image viewer">&times;</button>
  <div class="lightbox-img-wrapper" id="lightboxWrapper">
    <img id="lightboxImg" src="" alt="">
  </div>
  <div class="lightbox-caption" id="lightboxCaption"></div>
  <div class="lightbox-zoom-hint" id="lightboxZoomHint">Scroll to zoom &middot; Drag to pan</div>
</div>
<script>
// ─── IMAGE ZOOM LIGHTBOX ─────────────────────────────────────────────────────
(function() {
  const overlay = document.getElementById('lightboxOverlay');
  const wrapper = document.getElementById('lightboxWrapper');
  const lbImg = document.getElementById('lightboxImg');
  const caption = document.getElementById('lightboxCaption');
  const closeBtn = document.getElementById('lightboxClose');
  const zoomHint = document.getElementById('lightboxZoomHint');

  let currentScale = 1;
  let panX = 0, panY = 0;
  let isDragging = false;
  let dragStartX = 0, dragStartY = 0;
  let panStartX = 0, panStartY = 0;
  const MIN_SCALE = 1;
  const MAX_SCALE = 5;

  function openLightbox(imgEl) {
    lbImg.src = imgEl.src;
    lbImg.alt = imgEl.alt || '';
    if (imgEl.alt) {
      caption.textContent = imgEl.alt;
      caption.style.display = '';
    } else {
      caption.textContent = '';
      caption.style.display = 'none';
    }
    resetZoom();
    zoomHint.classList.remove('faded');
    overlay.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeLightbox() {
    overlay.classList.remove('active');
    document.body.style.overflow = '';
    setTimeout(function() {
      lbImg.src = '';
      resetZoom();
    }, 250);
  }

  function resetZoom() {
    currentScale = 1;
    panX = 0;
    panY = 0;
    applyTransform();
    wrapper.classList.remove('zoomed', 'dragging');
  }

  function applyTransform() {
    if (currentScale <= 1) {
      lbImg.style.transform = 'scale(1)';
      wrapper.classList.remove('zoomed');
    } else {
      lbImg.style.transform = 'scale(' + currentScale + ') translate(' + (panX / currentScale) + 'px, ' + (panY / currentScale) + 'px)';
      wrapper.classList.add('zoomed');
    }
  }

  // Click on images inside #docBody
  document.getElementById('docBody').addEventListener('click', function(e) {
    var target = e.target;
    if (target.tagName === 'IMG') {
      e.preventDefault();
      e.stopPropagation();
      openLightbox(target);
    }
  });

  // Close button
  closeBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    closeLightbox();
  });

  // Click on backdrop to close (but not on image or wrapper)
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) {
      closeLightbox();
    }
  });

  // Escape key
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && overlay.classList.contains('active')) {
      closeLightbox();
    }
  });

  // Scroll wheel zoom
  overlay.addEventListener('wheel', function(e) {
    if (!overlay.classList.contains('active')) return;
    e.preventDefault();
    zoomHint.classList.add('faded');

    var delta = e.deltaY > 0 ? -0.15 : 0.15;
    var newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, currentScale + delta));

    // If zooming back to 1, reset pan
    if (newScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      panX = 0;
      panY = 0;
    } else {
      currentScale = newScale;
    }

    applyTransform();
  }, { passive: false });

  // Drag to pan when zoomed
  wrapper.addEventListener('mousedown', function(e) {
    if (currentScale <= 1) return;
    e.preventDefault();
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    panStartX = panX;
    panStartY = panY;
    wrapper.classList.add('dragging');
  });

  document.addEventListener('mousemove', function(e) {
    if (!isDragging) return;
    e.preventDefault();
    panX = panStartX + (e.clientX - dragStartX);
    panY = panStartY + (e.clientY - dragStartY);
    applyTransform();
  });

  document.addEventListener('mouseup', function() {
    if (isDragging) {
      isDragging = false;
      wrapper.classList.remove('dragging');
    }
  });

  // Touch support for pan
  var touchStartX = 0, touchStartY = 0;
  var touchPanStartX = 0, touchPanStartY = 0;
  var isTouchDragging = false;

  wrapper.addEventListener('touchstart', function(e) {
    if (currentScale <= 1 || e.touches.length !== 1) return;
    isTouchDragging = true;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchPanStartX = panX;
    touchPanStartY = panY;
    wrapper.classList.add('dragging');
  }, { passive: true });

  wrapper.addEventListener('touchmove', function(e) {
    if (!isTouchDragging || e.touches.length !== 1) return;
    e.preventDefault();
    panX = touchPanStartX + (e.touches[0].clientX - touchStartX);
    panY = touchPanStartY + (e.touches[0].clientY - touchStartY);
    applyTransform();
  }, { passive: false });

  wrapper.addEventListener('touchend', function() {
    if (isTouchDragging) {
      isTouchDragging = false;
      wrapper.classList.remove('dragging');
    }
  });
})();

// ─── DOCUMENT OUTLINE MINIMAP ────────────────────────────────────────────────
(function() {
  var mainContent = document.getElementById('mainContent');
  var minimapContainer = document.getElementById('minimapContainer');
  var minimapCanvas = document.getElementById('minimapCanvas');
  var minimapViewport = document.getElementById('minimapViewport');
  if (!mainContent || !minimapContainer || !minimapCanvas || !minimapViewport) return;

  var ctx = minimapCanvas.getContext('2d');
  var minimapElements = [];
  var minimapVisible = false;
  var rafPending = false;

  var MM_COLORS = {
    h1: 'rgba(137, 180, 250, 0.7)',
    h2: 'rgba(137, 180, 250, 0.5)',
    h3: 'rgba(250, 179, 135, 0.5)',
    p: 'rgba(108, 112, 134, 0.35)',
    pre: 'rgba(166, 227, 161, 0.35)',
    blockquote: 'rgba(203, 166, 247, 0.3)',
    table: 'rgba(148, 226, 213, 0.3)',
    li: 'rgba(108, 112, 134, 0.25)'
  };

  var MM_WIDTHS = {
    h1: 28, h2: 22, h3: 16,
    p: 3, pre: 30, blockquote: 26, table: 30, li: 2
  };

  var MM_BAR_H = { h1: 3, h2: 2.5, h3: 2, p: 2, li: 2 };

  function scanStructure() {
    var docBody = document.getElementById('docBody');
    if (!docBody || docBody.style.display === 'none') return [];

    var elems = [];
    var scrollH = mainContent.scrollHeight;
    if (scrollH <= 0) return [];

    var nodes = docBody.querySelectorAll('h1, h2, h3, p, pre, blockquote, table, li');
    var mainRect = mainContent.getBoundingClientRect();
    var st = mainContent.scrollTop;

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var tag = node.tagName.toLowerCase();
      if (tag === 'p' && node.closest('blockquote')) continue;
      if (tag === 'li' && node.querySelector('p')) continue;

      var rect = node.getBoundingClientRect();
      var topInDoc = rect.top - mainRect.top + st;

      elems.push({
        tag: tag,
        top: topInDoc,
        height: rect.height,
        color: MM_COLORS[tag] || MM_COLORS.p,
        width: MM_WIDTHS[tag] || 3,
        barH: MM_BAR_H[tag] || 0
      });
    }
    return elems;
  }

  function shouldShow() {
    var dv = document.getElementById('docViewer');
    if (!dv || !dv.classList.contains('active')) return false;
    var db = document.getElementById('docBody');
    if (!db || db.style.display === 'none') return false;
    if (mainContent.scrollHeight <= mainContent.clientHeight + 50) return false;
    if (window.innerWidth <= 768) return false;
    return true;
  }

  function renderMinimap() {
    if (!shouldShow()) {
      if (minimapVisible) {
        minimapContainer.classList.remove('visible');
        minimapVisible = false;
      }
      return;
    }
    if (!minimapVisible) {
      minimapContainer.classList.add('visible');
      minimapVisible = true;
    }

    var dpr = window.devicePixelRatio || 1;
    var cw = minimapContainer.clientWidth;
    var ch = minimapContainer.clientHeight;
    if (cw === 0 || ch === 0) return;

    minimapCanvas.width = cw * dpr;
    minimapCanvas.height = ch * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, cw, ch);

    ctx.fillStyle = 'rgba(17, 17, 27, 0.4)';
    ctx.fillRect(0, 0, cw, ch);

    var scrollH = mainContent.scrollHeight;
    if (scrollH <= 0) return;
    var scale = ch / scrollH;

    for (var i = 0; i < minimapElements.length; i++) {
      var el = minimapElements[i];
      var y = el.top * scale;
      var w = el.width;
      var x = (cw - w) / 2;

      ctx.fillStyle = el.color;

      if (el.tag === 'p' || el.tag === 'li') {
        ctx.beginPath();
        ctx.arc(cw / 2, y + 1, el.tag === 'p' ? 1.2 : 0.8, 0, Math.PI * 2);
        ctx.fill();
      } else if (el.tag === 'pre' || el.tag === 'blockquote' || el.tag === 'table') {
        var h = Math.max(2, el.height * scale);
        var r = Math.min(1.5, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.fill();
      } else {
        ctx.fillRect(x, y, w, el.barH);
      }
    }
    updateVP();
  }

  function updateVP() {
    if (!minimapVisible) return;
    var scrollH = mainContent.scrollHeight;
    var clientH = mainContent.clientHeight;
    var ch = minimapContainer.clientHeight;
    if (scrollH <= 0 || ch <= 0) return;
    var scale = ch / scrollH;
    var top = mainContent.scrollTop * scale;
    var h = Math.max(8, clientH * scale);
    minimapViewport.style.top = top + 'px';
    minimapViewport.style.height = h + 'px';
  }

  minimapCanvas.addEventListener('click', function(e) {
    var rect = minimapCanvas.getBoundingClientRect();
    var clickY = e.clientY - rect.top;
    var ch = rect.height;
    var scrollH = mainContent.scrollHeight;
    var clientH = mainContent.clientHeight;
    if (ch <= 0 || scrollH <= 0) return;
    var ratio = clickY / ch;
    var target = (ratio * scrollH) - (clientH / 2);
    mainContent.scrollTo({ top: Math.max(0, target), behavior: 'smooth' });
  });

  var isDragging = false;
  minimapCanvas.addEventListener('mousedown', function(e) {
    isDragging = true;
    e.preventDefault();
  });
  document.addEventListener('mousemove', function(e) {
    if (!isDragging || !minimapVisible) return;
    var rect = minimapCanvas.getBoundingClientRect();
    var clickY = e.clientY - rect.top;
    var ch = rect.height;
    var scrollH = mainContent.scrollHeight;
    var clientH = mainContent.clientHeight;
    if (ch <= 0) return;
    var ratio = clickY / ch;
    var target = (ratio * scrollH) - (clientH / 2);
    mainContent.scrollTo({ top: Math.max(0, Math.min(target, scrollH - clientH)) });
  });
  document.addEventListener('mouseup', function() { isDragging = false; });

  mainContent.addEventListener('scroll', function() {
    if (!minimapVisible) return;
    if (!rafPending) {
      rafPending = true;
      requestAnimationFrame(function() {
        updateVP();
        rafPending = false;
      });
    }
  }, { passive: true });

  var resizeTimer = null;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(function() {
      minimapElements = scanStructure();
      renderMinimap();
    }, 200);
  });

  window.updateMinimap = function() {
    setTimeout(function() {
      minimapElements = scanStructure();
      renderMinimap();
    }, 120);
  };

  window.hideMinimap = function() {
    minimapContainer.classList.remove('visible');
    minimapVisible = false;
  };
})();
</script>



<script>
// ─── FLOATING TABLE OF CONTENTS ─────────────────────────────────────────────
(function() {
  var floatingToc = document.getElementById('floatingToc');
  var floatingTocList = document.getElementById('floatingTocList');
  var floatingTocToggle = document.getElementById('floatingTocToggle');
  if (!floatingToc || !floatingTocList || !floatingTocToggle) return;

  var floatingTocVisible = false;
  var floatingTocUserDismissed = false;
  var floatingTocHeadings = [];
  var floatingTocObserver = null;
  var scrollCleanupFn = null;
  var isNarrowViewport = window.innerWidth < 1200;

  // Preference persistence
  var FTOC_KEY = 'holm-floating-toc-visible';
  try {
    var savedPref = localStorage.getItem(FTOC_KEY);
    if (savedPref === 'false') floatingTocUserDismissed = true;
  } catch(e) {}

  function getIsNarrow() {
    return window.innerWidth < 1200;
  }

  function showPanel() {
    floatingTocVisible = true;
    floatingTocUserDismissed = false;
    try { localStorage.setItem(FTOC_KEY, 'true'); } catch(e) {}

    if (getIsNarrow()) {
      floatingToc.classList.add('visible');
      floatingTocToggle.classList.add('visible');
      floatingTocToggle.classList.add('active');
    } else {
      floatingToc.classList.add('visible');
      floatingTocToggle.classList.remove('visible');
      floatingTocToggle.classList.remove('active');
    }
  }

  function hidePanel() {
    floatingTocVisible = false;
    floatingTocUserDismissed = true;
    try { localStorage.setItem(FTOC_KEY, 'false'); } catch(e) {}
    floatingToc.classList.remove('visible');
    floatingTocToggle.classList.remove('active');
    if (floatingTocHeadings.length >= 3) {
      floatingTocToggle.classList.add('visible');
    }
  }

  window.toggleFloatingToc = function() {
    if (floatingTocVisible) {
      hidePanel();
    } else {
      if (floatingTocHeadings.length >= 3) {
        showPanel();
      }
    }
  };

  window.hideFloatingToc = function() {
    floatingToc.classList.remove('visible');
    floatingTocToggle.classList.remove('visible');
    floatingTocToggle.classList.remove('active');
    floatingTocVisible = false;
    cleanupObserver();
  };

  function cleanupObserver() {
    if (scrollCleanupFn) {
      scrollCleanupFn();
      scrollCleanupFn = null;
    }
    if (floatingTocObserver) {
      floatingTocObserver.disconnect();
      floatingTocObserver = null;
    }
  }

  function scrollToHeading(id) {
    var target = document.getElementById(id);
    var mainContent = document.getElementById('mainContent');
    if (target && mainContent) {
      var offset = target.offsetTop - mainContent.offsetTop;
      mainContent.scrollTo({ top: offset - 16, behavior: 'smooth' });
    }
  }

  window.updateFloatingToc = function() {
    setTimeout(function() { buildFloatingToc(); }, 80);
  };

  function buildFloatingToc() {
    cleanupObserver();

    var docBody = document.getElementById('docBody');
    if (!docBody || docBody.style.display === 'none') {
      window.hideFloatingToc();
      return;
    }

    var domHeadings = docBody.querySelectorAll('h1, h2, h3, h4');
    floatingTocHeadings = [];

    domHeadings.forEach(function(el, i) {
      if (!el.id) {
        var text = el.textContent.trim();
        var slug = text.toLowerCase().replace(/[^\w\s-]/g, '').trim().replace(/[\s_]+/g, '-').replace(/-+/g, '-');
        var baseSlug = slug || 'heading';
        var counter = 1;
        while (document.getElementById(slug) || !slug) {
          slug = baseSlug + '-' + counter;
          counter++;
        }
        el.id = slug;
      }

      var level = parseInt(el.tagName.charAt(1));
      floatingTocHeadings.push({
        id: el.id,
        text: el.textContent.trim(),
        level: level,
        element: el
      });
    });

    if (floatingTocHeadings.length < 3) {
      window.hideFloatingToc();
      return;
    }

    var html = '';
    floatingTocHeadings.forEach(function(h) {
      var escaped = h.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      html += '<div class="floating-toc-item" data-level="' + h.level + '" data-target="' + h.id + '" title="' + escaped + '">' + escaped + '</div>';
    });
    floatingTocList.innerHTML = html;

    floatingTocList.querySelectorAll('.floating-toc-item').forEach(function(item) {
      item.addEventListener('click', function() {
        scrollToHeading(this.getAttribute('data-target'));
      });
    });

    if (!floatingTocUserDismissed) {
      if (getIsNarrow()) {
        floatingTocToggle.classList.add('visible');
        floatingToc.classList.remove('visible');
        floatingTocVisible = false;
      } else {
        showPanel();
      }
    } else {
      floatingTocToggle.classList.add('visible');
      floatingToc.classList.remove('visible');
      floatingTocVisible = false;
    }

    setupScrollTracking();
  }

  function setupScrollTracking() {
    var mainContent = document.getElementById('mainContent');
    if (!mainContent || floatingTocHeadings.length === 0) return;

    var currentActiveId = null;

    // IntersectionObserver for detecting which heading is near the top
    floatingTocObserver = new IntersectionObserver(function(entries) {
      var visibleEntries = [];
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          visibleEntries.push(entry);
        }
      });

      if (visibleEntries.length > 0) {
        var topEntry = visibleEntries.reduce(function(best, entry) {
          return entry.boundingClientRect.top < best.boundingClientRect.top ? entry : best;
        });
        var newId = topEntry.target.id;
        if (newId !== currentActiveId) {
          currentActiveId = newId;
          highlightItem(newId);
        }
      }
    }, {
      root: mainContent,
      rootMargin: '-10% 0px -70% 0px',
      threshold: 0
    });

    floatingTocHeadings.forEach(function(h) {
      if (h.element) floatingTocObserver.observe(h.element);
    });

    // Scroll fallback for edge cases
    var scrollTimer = null;
    function onScroll() {
      if (scrollTimer) return;
      scrollTimer = setTimeout(function() {
        scrollTimer = null;
        var scrollTop = mainContent.scrollTop;
        var bestHeading = null;
        var bestDistance = Infinity;
        floatingTocHeadings.forEach(function(h) {
          if (h.element) {
            var top = h.element.offsetTop - mainContent.offsetTop;
            var distance = scrollTop - top + 20;
            if (distance >= 0 && distance < bestDistance) {
              bestDistance = distance;
              bestHeading = h;
            }
          }
        });
        if (bestHeading && bestHeading.id !== currentActiveId) {
          currentActiveId = bestHeading.id;
          highlightItem(bestHeading.id);
        }
      }, 80);
    }

    mainContent.addEventListener('scroll', onScroll, { passive: true });
    scrollCleanupFn = function() {
      mainContent.removeEventListener('scroll', onScroll);
    };
  }

  function highlightItem(activeId) {
    var items = floatingTocList.querySelectorAll('.floating-toc-item');
    items.forEach(function(item) {
      if (item.getAttribute('data-target') === activeId) {
        item.classList.add('active');
        var tocRect = floatingToc.getBoundingClientRect();
        var itemRect = item.getBoundingClientRect();
        if (itemRect.top < tocRect.top + 50 || itemRect.bottom > tocRect.bottom - 10) {
          item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      } else {
        item.classList.remove('active');
      }
    });
  }

  // Handle viewport resize
  var resizeTimer = null;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(function() {
      var wasNarrow = isNarrowViewport;
      isNarrowViewport = getIsNarrow();
      if (floatingTocHeadings.length < 3) return;
      if (wasNarrow && !isNarrowViewport && !floatingTocUserDismissed) {
        showPanel();
      } else if (!wasNarrow && isNarrowViewport && floatingTocVisible) {
        floatingToc.classList.remove('visible');
        floatingTocToggle.classList.add('visible');
        floatingTocToggle.classList.add('active');
      }
    }, 200);
  });
})();
</script>

<!-- BATCH SELECT ACTION BAR -->
<div class="batch-action-bar" id="batchActionBar">
  <span class="batch-count" id="batchCount"><span class="count-num">0</span> documents selected</span>
  <div class="batch-separator"></div>
  <button onclick="batchSelectAll()">Select All</button>
  <button onclick="batchDeselectAll()">Deselect All</button>
  <div class="batch-separator"></div>
  <button class="batch-export-btn" onclick="batchExportMarkdown()">&#x2913; Export Markdown</button>
  <button class="batch-export-btn" onclick="batchExportJSON()" style="background:var(--green);border-color:var(--green)">&#x2913; Export JSON</button>
  <div class="batch-separator"></div>
  <button class="batch-cancel-btn" onclick="exitBatchMode()">Cancel</button>
</div>

<script>
// ─── BATCH SELECT MODE ──────────────────────────────────────────────────────
(function() {
  var batchMode = false;
  var batchSelected = new Set();

  window.toggleBatchMode = function() {
    if (batchMode) {
      exitBatchMode();
    } else {
      enterBatchMode();
    }
  };

  function enterBatchMode() {
    batchMode = true;
    batchSelected.clear();
    document.body.classList.add('batch-mode');
    injectBatchCheckboxes();
    updateBatchUI();
  }

  window.exitBatchMode = function() {
    batchMode = false;
    batchSelected.clear();
    document.body.classList.remove('batch-mode');
    // Remove selected highlights
    document.querySelectorAll('.sidebar-item.batch-selected').forEach(function(el) {
      el.classList.remove('batch-selected');
    });
    // Remove checkbox checked states
    document.querySelectorAll('.batch-checkbox.checked').forEach(function(el) {
      el.classList.remove('checked');
    });
    document.querySelectorAll('.batch-domain-checkbox.checked, .batch-domain-checkbox.partial').forEach(function(el) {
      el.classList.remove('checked', 'partial');
    });
    updateBatchUI();
  };

  function injectBatchCheckboxes() {
    // Add checkboxes to sidebar items that don't already have one
    document.querySelectorAll('.sidebar-item[data-id]').forEach(function(item) {
      if (item.querySelector('.batch-checkbox')) return;
      var cb = document.createElement('span');
      cb.className = 'batch-checkbox';
      var docId = item.dataset.id;
      if (batchSelected.has(docId)) {
        cb.classList.add('checked');
        item.classList.add('batch-selected');
      }
      cb.addEventListener('click', function(e) {
        e.stopPropagation();
        toggleBatchItem(docId);
      });
      item.insertBefore(cb, item.firstChild);
    });

    // Add domain-level checkboxes to section headers
    document.querySelectorAll('.sidebar-section[data-domain]').forEach(function(section) {
      var header = section.querySelector('.sidebar-section-header');
      if (!header || header.querySelector('.batch-domain-checkbox')) return;
      var dcb = document.createElement('span');
      dcb.className = 'batch-domain-checkbox';
      var domain = section.dataset.domain;
      dcb.addEventListener('click', function(e) {
        e.stopPropagation();
        toggleBatchDomain(domain);
      });
      // Insert after the chevron
      var chevron = header.querySelector('.chevron');
      if (chevron && chevron.nextSibling) {
        header.insertBefore(dcb, chevron.nextSibling);
      } else {
        header.insertBefore(dcb, header.firstChild);
      }
    });
    updateDomainCheckboxStates();
  }

  function toggleBatchItem(docId) {
    if (batchSelected.has(docId)) {
      batchSelected.delete(docId);
    } else {
      batchSelected.add(docId);
    }
    // Update this item's UI
    var item = document.querySelector('.sidebar-item[data-id="' + docId + '"]');
    if (item) {
      var cb = item.querySelector('.batch-checkbox');
      if (batchSelected.has(docId)) {
        if (cb) cb.classList.add('checked');
        item.classList.add('batch-selected');
      } else {
        if (cb) cb.classList.remove('checked');
        item.classList.remove('batch-selected');
      }
    }
    updateDomainCheckboxStates();
    updateBatchUI();
  }

  function toggleBatchDomain(domain) {
    var section = document.querySelector('.sidebar-section[data-domain="' + domain + '"]');
    if (!section) return;
    var items = section.querySelectorAll('.sidebar-item[data-id]');
    var docIds = [];
    items.forEach(function(item) { docIds.push(item.dataset.id); });

    // Check if all are selected
    var allSelected = docIds.length > 0 && docIds.every(function(id) { return batchSelected.has(id); });

    if (allSelected) {
      // Deselect all in this domain
      docIds.forEach(function(id) { batchSelected.delete(id); });
    } else {
      // Select all in this domain
      docIds.forEach(function(id) { batchSelected.add(id); });
    }

    // Update individual item UIs
    items.forEach(function(item) {
      var docId = item.dataset.id;
      var cb = item.querySelector('.batch-checkbox');
      if (batchSelected.has(docId)) {
        if (cb) cb.classList.add('checked');
        item.classList.add('batch-selected');
      } else {
        if (cb) cb.classList.remove('checked');
        item.classList.remove('batch-selected');
      }
    });

    updateDomainCheckboxStates();
    updateBatchUI();
  }

  function updateDomainCheckboxStates() {
    document.querySelectorAll('.sidebar-section[data-domain]').forEach(function(section) {
      var dcb = section.querySelector('.batch-domain-checkbox');
      if (!dcb) return;
      var items = section.querySelectorAll('.sidebar-item[data-id]');
      var total = items.length;
      if (total === 0) {
        dcb.classList.remove('checked', 'partial');
        return;
      }
      var selected = 0;
      items.forEach(function(item) {
        if (batchSelected.has(item.dataset.id)) selected++;
      });
      dcb.classList.remove('checked', 'partial');
      if (selected === total) {
        dcb.classList.add('checked');
      } else if (selected > 0) {
        dcb.classList.add('partial');
      }
    });
  }

  function updateBatchUI() {
    var countEl = document.getElementById('batchCount');
    if (countEl) {
      var n = batchSelected.size;
      countEl.innerHTML = '<span class="count-num">' + n + '</span> document' + (n !== 1 ? 's' : '') + ' selected';
    }
  }

  window.batchSelectAll = function() {
    document.querySelectorAll('.sidebar-item[data-id]').forEach(function(item) {
      var docId = item.dataset.id;
      batchSelected.add(docId);
      var cb = item.querySelector('.batch-checkbox');
      if (cb) cb.classList.add('checked');
      item.classList.add('batch-selected');
    });
    updateDomainCheckboxStates();
    updateBatchUI();
  };

  window.batchDeselectAll = function() {
    batchSelected.clear();
    document.querySelectorAll('.sidebar-item .batch-checkbox.checked').forEach(function(cb) {
      cb.classList.remove('checked');
    });
    document.querySelectorAll('.sidebar-item.batch-selected').forEach(function(el) {
      el.classList.remove('batch-selected');
    });
    updateDomainCheckboxStates();
    updateBatchUI();
  };

  window.batchExportMarkdown = function() {
    if (batchSelected.size === 0) {
      if (typeof showToast === 'function') showToast('No documents selected', 'warning');
      return;
    }
    var output = '';
    var count = 0;
    batchSelected.forEach(function(docId) {
      var doc = typeof docsById !== 'undefined' ? docsById[docId] : null;
      if (!doc) return;
      if (count > 0) {
        output += '\n\n---\n\n';
        output += '<!-- ═══ ' + docId + ' ═══ -->\n\n';
      }
      // YAML front matter
      var fm = '---\n';
      fm += 'docId: "' + (doc.docId || '') + '"\n';
      fm += 'title: "' + (doc.title || '').replace(/"/g, '\\"') + '"\n';
      fm += 'domain: ' + (doc.domain != null ? doc.domain : '') + '\n';
      fm += 'tags: [' + (Array.isArray(doc.tags) ? doc.tags.map(function(t) { return '"' + t + '"'; }).join(', ') : '') + ']\n';
      fm += 'version: "' + (doc.version || '') + '"\n';
      fm += 'status: "' + (doc.status || '') + '"\n';
      fm += 'date: "' + (doc.date || '') + '"\n';
      fm += '---\n\n';
      var mdBody = typeof htmlToMarkdown === 'function' ? htmlToMarkdown(doc.content || '') : (doc.content || '');
      output += fm + mdBody;
      count++;
    });
    if (count === 0) {
      if (typeof showToast === 'function') showToast('No valid documents to export', 'warning');
      return;
    }
    var blob = new Blob([output], { type: 'text/markdown;charset=utf-8' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'holm-export-' + count + '-docs.md';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    if (typeof showToast === 'function') showToast('Exported ' + count + ' documents as Markdown', 'success');
  };

  window.batchExportJSON = function() {
    if (batchSelected.size === 0) {
      if (typeof showToast === 'function') showToast('No documents selected', 'warning');
      return;
    }
    var arr = [];
    batchSelected.forEach(function(docId) {
      var doc = typeof docsById !== 'undefined' ? docsById[docId] : null;
      if (!doc) return;
      arr.push({
        docId: doc.docId,
        title: doc.title || '',
        domain: doc.domain != null ? doc.domain : '',
        tags: Array.isArray(doc.tags) ? doc.tags : [],
        content: doc.content || ''
      });
    });
    if (arr.length === 0) {
      if (typeof showToast === 'function') showToast('No valid documents to export', 'warning');
      return;
    }
    var jsonStr = JSON.stringify(arr, null, 2);
    var blob = new Blob([jsonStr], { type: 'application/json;charset=utf-8' });
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'holm-export-' + arr.length + '-docs.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    if (typeof showToast === 'function') showToast('Exported ' + arr.length + ' documents as JSON', 'success');
  };

  // Hook into Escape key to exit batch mode
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && batchMode) {
      exitBatchMode();
      e.stopPropagation();
      return;
    }
  }, true); // Use capture phase so it fires before other handlers

  // Re-inject checkboxes when sidebar is re-rendered (MutationObserver)
  var sidebarContent = document.getElementById('sidebarContent');
  if (sidebarContent) {
    var batchObserver = new MutationObserver(function() {
      if (batchMode) {
        // Debounce slightly to avoid rapid re-injection
        clearTimeout(batchObserver._timer);
        batchObserver._timer = setTimeout(function() {
          injectBatchCheckboxes();
        }, 50);
      }
    });
    batchObserver.observe(sidebarContent, { childList: true, subtree: false });
  }
})();
</script>


<!-- WORD CLOUD MODAL -->
<div class="wordcloud-overlay" id="wordcloudOverlay" onclick="if(event.target===this)closeWordCloud()">
  <div class="wordcloud-panel">
    <div class="wordcloud-header">
      <h2 id="wordcloudTitle">Word Cloud</h2>
      <div class="wordcloud-header-actions">
        <button class="wordcloud-scope-toggle" id="wordcloudScopeBtn" onclick="toggleWordCloudScope()" title="Toggle: single doc vs entire domain">Domain</button>
        <button class="wordcloud-close" onclick="closeWordCloud()">&times;</button>
      </div>
    </div>
    <div class="wordcloud-body" id="wordcloudBody">
      <canvas class="wordcloud-canvas" id="wordcloudCanvas" width="600" height="400"></canvas>
    </div>
  </div>
</div>
<div class="wordcloud-tooltip" id="wordcloudTooltip"></div>

<script>
// ─── WORD CLOUD ──────────────────────────────────────────────────────────────
(function() {
  var wcScope = 'doc'; // 'doc' or 'domain'

  var STOP_WORDS = new Set([
    'the','a','an','is','are','was','were','in','on','at','to','for','of','and','or',
    'but','not','this','that','with','from','by','as','it','be','has','have','had',
    'will','would','can','could','shall','should','do','does','did','may','might',
    'must','am','been','being','he','she','they','we','you','i','me','my','your',
    'his','her','its','our','their','them','us','who','which','what','when','where',
    'how','why','if','then','than','so','no','yes','all','any','both','each','few',
    'more','most','other','some','such','very','just','also','into','over','after',
    'before','between','through','about','up','out','only','own','same','too','here',
    'there','these','those','one','two','three','first','new','now','way','well',
    'also','back','much','even','made','after','many','set','get','like','see',
    'make','know','take','come','go','say','said','need','use','used','using',
    'based','within','while','during','per','via','etc','above','below','under',
    'upon','across','along','among','around','every','still','already','however',
    'rather','yet','able','given','since','until','whether','either','neither',
    'nor','ii','iii','iv','de','el','la','en','les','des','le','du','un','une'
  ]);

  var WC_COLORS;

  function getWcColors() {
    var style = getComputedStyle(document.documentElement);
    return [
      style.getPropertyValue('--accent').trim(),
      style.getPropertyValue('--green').trim(),
      style.getPropertyValue('--mauve').trim(),
      style.getPropertyValue('--peach').trim(),
      style.getPropertyValue('--teal').trim(),
      style.getPropertyValue('--yellow').trim(),
      style.getPropertyValue('--pink').trim()
    ];
  }

  function stripHtml(html) {
    var tmp = document.createElement('div');
    tmp.innerHTML = html;
    return tmp.textContent || tmp.innerText || '';
  }

  function extractWords(text) {
    var words = text.toLowerCase().replace(/[^a-z0-9\s'-]/g, ' ').split(/\s+/);
    var freq = {};
    for (var i = 0; i < words.length; i++) {
      var w = words[i].replace(/^['-]+|['-]+$/g, '');
      if (w.length < 3 || STOP_WORDS.has(w) || /^\d+$/.test(w)) continue;
      freq[w] = (freq[w] || 0) + 1;
    }
    var sorted = Object.keys(freq).map(function(k) { return { word: k, count: freq[k] }; });
    sorted.sort(function(a, b) { return b.count - a.count; });
    return sorted.slice(0, 60);
  }

  function renderWordCloud(words) {
    var canvas = document.getElementById('wordcloudCanvas');
    var body = document.getElementById('wordcloudBody');
    if (!canvas || words.length === 0) {
      body.innerHTML = '<div class="wordcloud-empty">No words to display</div>';
      return;
    }
    // Ensure canvas is in body
    if (!body.contains(canvas)) {
      body.innerHTML = '';
      body.appendChild(canvas);
    }

    // Responsive sizing
    var panelWidth = canvas.parentElement.clientWidth || 600;
    var cw = Math.min(panelWidth - 10, 632);
    var ch = Math.round(cw * 0.6667);
    canvas.width = cw;
    canvas.height = ch;
    canvas.style.width = cw + 'px';
    canvas.style.height = ch + 'px';

    var ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, cw, ch);

    WC_COLORS = getWcColors();

    var maxCount = words[0].count;
    var minCount = words[words.length - 1].count;
    var minFont = 11;
    var maxFont = Math.min(56, cw / 8);

    // Placed words (bounding boxes for hit-testing + collision)
    var placed = [];

    function fontSize(count) {
      if (maxCount === minCount) return (minFont + maxFont) / 2;
      return minFont + (count - minCount) / (maxCount - minCount) * (maxFont - minFont);
    }

    function measureWord(word, size, angle) {
      ctx.save();
      ctx.font = '600 ' + size + 'px -apple-system, BlinkMacSystemFont, Inter, sans-serif';
      var metrics = ctx.measureText(word);
      ctx.restore();
      var tw = metrics.width + 6;
      var th = size * 1.2 + 4;
      // Account for rotation
      var rad = angle * Math.PI / 180;
      var cosA = Math.abs(Math.cos(rad));
      var sinA = Math.abs(Math.sin(rad));
      var bw = tw * cosA + th * sinA;
      var bh = tw * sinA + th * cosA;
      return { tw: tw, th: th, bw: bw, bh: bh };
    }

    function overlaps(x, y, bw, bh) {
      for (var i = 0; i < placed.length; i++) {
        var p = placed[i];
        if (!(x + bw / 2 < p.x - p.bw / 2 ||
              x - bw / 2 > p.x + p.bw / 2 ||
              y + bh / 2 < p.y - p.bh / 2 ||
              y - bh / 2 > p.y + p.bh / 2)) {
          return true;
        }
      }
      return false;
    }

    function inBounds(x, y, bw, bh) {
      return x - bw / 2 >= 2 && x + bw / 2 <= cw - 2 &&
             y - bh / 2 >= 2 && y + bh / 2 <= ch - 2;
    }

    // Spiral placement
    for (var wi = 0; wi < words.length; wi++) {
      var word = words[wi].word;
      var count = words[wi].count;
      var size = fontSize(count);
      var angle = (Math.random() - 0.5) * 30; // -15 to +15 degrees
      var m = measureWord(word, size, angle);
      var didPlace = false;

      // Spiral from center
      var cx = cw / 2;
      var cy = ch / 2;
      for (var r = 0; r < Math.max(cw, ch); r += 3) {
        var angleStep = (r < 10) ? Math.PI / 2 : 4 / r;
        for (var a = 0; a < 2 * Math.PI; a += angleStep) {
          var px = cx + r * Math.cos(a);
          var py = cy + r * Math.sin(a);
          if (inBounds(px, py, m.bw, m.bh) && !overlaps(px, py, m.bw, m.bh)) {
            // Draw the word
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(angle * Math.PI / 180);
            ctx.font = '600 ' + size + 'px -apple-system, BlinkMacSystemFont, Inter, sans-serif';
            ctx.fillStyle = WC_COLORS[wi % WC_COLORS.length];
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(word, 0, 0);
            ctx.restore();

            placed.push({
              word: word,
              count: count,
              x: px,
              y: py,
              bw: m.bw,
              bh: m.bh,
              size: size,
              color: WC_COLORS[wi % WC_COLORS.length]
            });
            didPlace = true;
            break;
          }
        }
        if (didPlace) break;
      }
    }

    // Store placed words for interactivity
    canvas._wcPlaced = placed;
  }

  // ── Canvas interactivity ──────────────────────────────────────────────────
  function hitTestCanvas(e) {
    var canvas = document.getElementById('wordcloudCanvas');
    if (!canvas || !canvas._wcPlaced) return null;
    var rect = canvas.getBoundingClientRect();
    var mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    var my = (e.clientY - rect.top) * (canvas.height / rect.height);
    var placed = canvas._wcPlaced;
    for (var i = 0; i < placed.length; i++) {
      var p = placed[i];
      if (mx >= p.x - p.bw / 2 && mx <= p.x + p.bw / 2 &&
          my >= p.y - p.bh / 2 && my <= p.y + p.bh / 2) {
        return p;
      }
    }
    return null;
  }

  function attachCanvasListeners() {
    var canvas = document.getElementById('wordcloudCanvas');
    if (!canvas) return;
    // Remove old listeners by replacing node (safe since we call this after innerHTML)
    canvas.addEventListener('click', function(e) {
      var hit = hitTestCanvas(e);
      if (hit) {
        closeWordCloud();
        var searchInput = document.getElementById('searchInput');
        if (searchInput) {
          searchInput.value = hit.word;
          searchInput.dispatchEvent(new Event('input'));
          searchInput.focus();
        }
      }
    });
  }

  document.addEventListener('mousemove', function(e) {
    var overlay = document.getElementById('wordcloudOverlay');
    if (!overlay || !overlay.classList.contains('active')) return;
    var tooltip = document.getElementById('wordcloudTooltip');
    var hit = hitTestCanvas(e);
    if (hit) {
      tooltip.style.display = 'block';
      tooltip.textContent = '"' + hit.word + '" \u2014 ' + hit.count + ' occurrence' + (hit.count !== 1 ? 's' : '');
      tooltip.style.left = (e.clientX + 14) + 'px';
      tooltip.style.top = (e.clientY - 28) + 'px';
      document.getElementById('wordcloudCanvas').style.cursor = 'pointer';
    } else {
      tooltip.style.display = 'none';
      var cv = document.getElementById('wordcloudCanvas');
      if (cv) cv.style.cursor = 'default';
    }
  });

  // Attach initial listeners
  attachCanvasListeners();

  // ── Public API ────────────────────────────────────────────────────────────
  window.openWordCloud = function() {
    if (typeof currentDoc === 'undefined' || !currentDoc) return;
    wcScope = 'doc';
    var scopeBtn = document.getElementById('wordcloudScopeBtn');
    if (scopeBtn) { scopeBtn.classList.remove('active'); scopeBtn.textContent = 'Domain'; }
    generateAndShowCloud();
  };

  window.closeWordCloud = function() {
    var overlay = document.getElementById('wordcloudOverlay');
    if (overlay) overlay.classList.remove('active');
    var tooltip = document.getElementById('wordcloudTooltip');
    if (tooltip) tooltip.style.display = 'none';
  };

  window.toggleWordCloudScope = function() {
    if (wcScope === 'doc') {
      wcScope = 'domain';
    } else {
      wcScope = 'doc';
    }
    var scopeBtn = document.getElementById('wordcloudScopeBtn');
    if (scopeBtn) {
      scopeBtn.classList.toggle('active', wcScope === 'domain');
      scopeBtn.textContent = wcScope === 'domain' ? 'Domain (active)' : 'Domain';
    }
    generateAndShowCloud();
  };

  function generateAndShowCloud() {
    var title = document.getElementById('wordcloudTitle');
    var overlay = document.getElementById('wordcloudOverlay');
    var body = document.getElementById('wordcloudBody');

    if (wcScope === 'domain' && typeof allDocs !== 'undefined' && typeof currentDoc !== 'undefined' && currentDoc) {
      // Gather all docs in current domain
      var domainDocs = allDocs.filter(function(d) { return d.domain === currentDoc.domain; });
      title.textContent = 'Word Cloud \u2014 Domain ' + currentDoc.domain + (currentDoc.domainName ? ': ' + currentDoc.domainName : '');
      // Fetch content for all domain docs
      var promises = domainDocs.map(function(d) {
        return fetch('/api/docs/' + d.docId).then(function(r) { return r.json(); }).then(function(doc) { return doc.content || ''; }).catch(function() { return ''; });
      });
      overlay.classList.add('active');
      body.innerHTML = '<div class="wordcloud-empty">Loading domain docs...</div>';
      Promise.all(promises).then(function(contents) {
        var allText = contents.map(function(c) { return stripHtml(c); }).join(' ');
        var words = extractWords(allText);
        body.innerHTML = '<canvas class="wordcloud-canvas" id="wordcloudCanvas" width="600" height="400"></canvas>';
        renderWordCloud(words);
        attachCanvasListeners();
      });
    } else {
      title.textContent = 'Word Cloud \u2014 ' + (currentDoc ? currentDoc.title : 'Document');
      var content = '';
      if (typeof currentDoc !== 'undefined' && currentDoc && currentDoc.content) {
        content = currentDoc.content;
      }
      var text = stripHtml(content);
      var words = extractWords(text);
      // Reset canvas
      body.innerHTML = '<canvas class="wordcloud-canvas" id="wordcloudCanvas" width="600" height="400"></canvas>';
      overlay.classList.add('active');
      renderWordCloud(words);
      attachCanvasListeners();
    }
  }
})();
</script>

<!-- FIND IN DOCUMENT -->
<script>
(function() {
  var findBar = document.getElementById('findBar');
  var findInput = document.getElementById('findInput');
  var findCount = document.getElementById('findCount');
  var findPrevBtn = document.getElementById('findPrev');
  var findNextBtn = document.getElementById('findNext');
  var findCloseBtn = document.getElementById('findClose');
  var docBody = document.getElementById('docBody');

  var isActive = false;
  var matches = [];
  var currentIndex = -1;
  var originalHTML = '';
  var debounceTimer = null;

  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function openFindBar() {
    if (isActive) {
      findInput.focus();
      findInput.select();
      return;
    }
    isActive = true;
    originalHTML = docBody.innerHTML;
    findBar.classList.remove('hidden');
    findInput.value = '';
    findCount.textContent = '';
    findCount.classList.remove('no-results');
    findPrevBtn.disabled = true;
    findNextBtn.disabled = true;
    matches = [];
    currentIndex = -1;
    findInput.focus();
  }

  function closeFindBar() {
    if (!isActive) return;
    isActive = false;
    findBar.classList.add('hidden');
    clearHighlights();
    findInput.value = '';
    findCount.textContent = '';
    findCount.classList.remove('no-results');
    findPrevBtn.disabled = true;
    findNextBtn.disabled = true;
    matches = [];
    currentIndex = -1;
  }

  function clearHighlights() {
    if (originalHTML) {
      docBody.innerHTML = originalHTML;
      originalHTML = '';
      if (typeof addCopyButtons === 'function') addCopyButtons();
      if (typeof highlightCodeBlocks === 'function') highlightCodeBlocks();
    }
  }

  function performSearch(query) {
    if (!query || query.length === 0) {
      if (originalHTML) {
        docBody.innerHTML = originalHTML;
        if (typeof addCopyButtons === 'function') addCopyButtons();
        if (typeof highlightCodeBlocks === 'function') highlightCodeBlocks();
      }
      matches = [];
      currentIndex = -1;
      findCount.textContent = '';
      findCount.classList.remove('no-results');
      findPrevBtn.disabled = true;
      findNextBtn.disabled = true;
      return;
    }

    // Restore original HTML before re-highlighting
    if (originalHTML) {
      docBody.innerHTML = originalHTML;
    }

    // Walk text nodes and collect them
    var textNodes = [];
    var walker = document.createTreeWalker(docBody, NodeFilter.SHOW_TEXT, null, false);
    var node;
    while (node = walker.nextNode()) {
      var parent = node.parentNode;
      if (parent && (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE')) continue;
      textNodes.push(node);
    }

    var regex = new RegExp(escapeRegExp(query), 'gi');

    // Process text nodes in reverse to preserve DOM offsets
    for (var i = textNodes.length - 1; i >= 0; i--) {
      var textNode = textNodes[i];
      var text = textNode.nodeValue;
      var nodeMatches = [];
      var m;

      regex.lastIndex = 0;
      while ((m = regex.exec(text)) !== null) {
        nodeMatches.push({ index: m.index, length: m[0].length });
      }

      if (nodeMatches.length === 0) continue;

      // Split text node and wrap matches with mark elements
      var fragment = document.createDocumentFragment();
      var lastEnd = 0;

      for (var j = 0; j < nodeMatches.length; j++) {
        var match = nodeMatches[j];
        if (match.index > lastEnd) {
          fragment.appendChild(document.createTextNode(text.substring(lastEnd, match.index)));
        }
        var mark = document.createElement('mark');
        mark.className = 'find-match';
        mark.textContent = text.substring(match.index, match.index + match.length);
        fragment.appendChild(mark);
        lastEnd = match.index + match.length;
      }
      if (lastEnd < text.length) {
        fragment.appendChild(document.createTextNode(text.substring(lastEnd)));
      }

      textNode.parentNode.replaceChild(fragment, textNode);
    }

    // Gather all mark elements in document order
    matches = Array.from(docBody.querySelectorAll('mark.find-match'));

    if (matches.length > 0) {
      currentIndex = 0;
      updateCurrentHighlight();
      findPrevBtn.disabled = false;
      findNextBtn.disabled = false;
      findCount.classList.remove('no-results');
    } else {
      currentIndex = -1;
      findPrevBtn.disabled = true;
      findNextBtn.disabled = true;
      findCount.textContent = query.length > 0 ? 'No results' : '';
      findCount.classList.toggle('no-results', query.length > 0);
    }
  }

  function updateCurrentHighlight() {
    for (var i = 0; i < matches.length; i++) {
      matches[i].className = 'find-match';
    }
    if (currentIndex >= 0 && currentIndex < matches.length) {
      matches[currentIndex].className = 'find-match-current';
      findCount.textContent = (currentIndex + 1) + ' of ' + matches.length;
      findCount.classList.remove('no-results');
      matches[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  function goToNext() {
    if (matches.length === 0) return;
    currentIndex = (currentIndex + 1) % matches.length;
    updateCurrentHighlight();
  }

  function goToPrev() {
    if (matches.length === 0) return;
    currentIndex = (currentIndex - 1 + matches.length) % matches.length;
    updateCurrentHighlight();
  }

  // Debounced input handler (200ms)
  findInput.addEventListener('input', function() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(function() {
      performSearch(findInput.value);
    }, 200);
  });

  // Keyboard shortcuts within the find input
  findInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (e.shiftKey) { goToPrev(); } else { goToNext(); }
    }
    if (e.key === 'Escape') {
      e.preventDefault();
      e.stopPropagation();
      closeFindBar();
    }
  });

  findNextBtn.addEventListener('click', function() { goToNext(); });
  findPrevBtn.addEventListener('click', function() { goToPrev(); });
  findCloseBtn.addEventListener('click', function() { closeFindBar(); });

  // Public API for keyboard shortcut handler
  window.findInDoc = {
    open: openFindBar,
    close: closeFindBar,
    isOpen: function() { return isActive; }
  };
})();
</script>

</body>
</html>
