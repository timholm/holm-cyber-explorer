<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HOLM VAULT</title>
<style>
:root {
  --bg-primary: #1e1e2e;
  --bg-secondary: #181825;
  --bg-tertiary: #11111b;
  --bg-surface: #313244;
  --bg-hover: #45475a;
  --text-primary: #cdd6f4;
  --text-secondary: #a6adc8;
  --text-muted: #6c7086;
  --accent: #89b4fa;
  --accent-dim: #2a3a5c;
  --green: #a6e3a1;
  --red: #f38ba8;
  --yellow: #f9e2af;
  --peach: #fab387;
  --mauve: #cba6f7;
  --teal: #94e2d5;
  --pink: #f5c2e7;
  --border: #313244;
  --sidebar-width: 260px;
  --backlinks-width: 240px;
  --header-height: 48px;
}

/* LIGHT THEME OVERRIDES */
body.light-theme {
  --bg-primary: #ffffff;
  --bg-secondary: #f5f5f5;
  --bg-tertiary: #e8e8e8;
  --bg-surface: #e0e0e0;
  --bg-hover: #d4d4d4;
  --text-primary: #1e1e2e;
  --text-secondary: #4c4f69;
  --text-muted: #6c6f85;
  --accent: #2563eb;
  --accent-dim: #dbeafe;
  --green: #16a34a;
  --red: #dc2626;
  --yellow: #ca8a04;
  --peach: #ea580c;
  --mauve: #9333ea;
  --teal: #0d9488;
  --pink: #db2777;
  --border: #d1d5db;
}

/* Light theme: element-specific overrides for hardcoded colors */
body.light-theme .search-result-item mark { background: rgba(202, 138, 4, 0.2); color: #92400e; }
body.light-theme .code-copy-btn { background: rgba(224, 224, 224, 0.9); }
body.light-theme .scroll-to-top { background: rgba(224, 224, 224, 0.95); box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12); }
body.light-theme .scroll-to-top:hover { background: rgba(212, 212, 212, 0.98); }
body.light-theme .quick-open-overlay { background: rgba(0, 0, 0, 0.3); }
body.light-theme .quick-open-panel { box-shadow: 0 24px 64px rgba(0, 0, 0, 0.2); }
body.light-theme .quick-open-item { border-bottom: 1px solid rgba(209, 213, 219, 0.5); }
body.light-theme .shortcuts-modal-overlay { background: rgba(0, 0, 0, 0.35); }
body.light-theme .shortcuts-modal { box-shadow: 0 24px 64px rgba(0, 0, 0, 0.2); }
body.light-theme .stats-overlay { background: rgba(0, 0, 0, 0.4); }
body.light-theme .stats-dashboard { box-shadow: 0 24px 64px rgba(0, 0, 0, 0.15); }
body.light-theme .doc-link-tooltip { box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1); }
body.light-theme .sidebar.open { box-shadow: 6px 0 32px rgba(0, 0, 0, 0.15); }
body.light-theme .doc-badge-pill.badge-version { background: rgba(37, 99, 235, 0.1); border-color: rgba(37, 99, 235, 0.3); }
body.light-theme .doc-badge-pill.badge-status-ratified { background: rgba(22, 163, 74, 0.1); border-color: rgba(22, 163, 74, 0.3); }
body.light-theme .doc-badge-pill.badge-status-draft { background: rgba(202, 138, 4, 0.1); border-color: rgba(202, 138, 4, 0.3); }
body.light-theme .doc-badge-pill.badge-status-active { background: rgba(37, 99, 235, 0.1); border-color: rgba(37, 99, 235, 0.3); }
body.light-theme .doc-badge-pill.badge-status-deprecated { background: rgba(220, 38, 38, 0.1); border-color: rgba(220, 38, 38, 0.3); }
body.light-theme .doc-badge-pill.badge-status-other { background: rgba(108, 111, 133, 0.1); border-color: rgba(108, 111, 133, 0.3); }
body.light-theme .doc-badge-pill.badge-date { background: rgba(108, 111, 133, 0.08); border-color: rgba(108, 111, 133, 0.2); }
body.light-theme .stats-table td { border-bottom: 1px solid rgba(209, 213, 219, 0.5); }
body.light-theme .fullscreen-exit-hint { box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1); }
body.light-theme .doc-body em { color: #92400e; }
body.light-theme .filter-tag.active { color: #ffffff; }

/* Theme toggle button */
.theme-toggle {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 14px;
  cursor: pointer;
  white-space: nowrap;
  line-height: 1;
  transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
}
.theme-toggle:hover { background: var(--bg-hover); }

* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  height: 100vh;
  overflow: hidden;
  transition: background-color 0.2s ease, color 0.2s ease;
}
a { color: var(--accent); text-decoration: none; }
a:hover { text-decoration: underline; }

/* HEADER */
.header {
  height: var(--header-height);
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  gap: 12px;
  z-index: 100;
}
.header-brand {
  font-weight: 700;
  font-size: 14px;
  color: var(--accent);
  letter-spacing: 1px;
  white-space: nowrap;
}
.hamburger {
  display: none;
  background: none;
  border: none;
  color: var(--text-primary);
  font-size: 20px;
  cursor: pointer;
  padding: 4px 8px;
}
.search-box {
  flex: 1;
  max-width: 400px;
  position: relative;
}
.search-box input {
  width: 100%;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text-primary);
  padding: 6px 12px 6px 32px;
  font-size: 13px;
  outline: none;
}
.search-box input:focus { border-color: var(--accent); }
.search-box::before {
  content: '⌕';
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--text-muted);
  font-size: 14px;
}
.search-results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 6px;
  margin-top: 4px;
  max-height: 400px;
  overflow-y: auto;
  display: none;
  z-index: 200;
}
.search-results.active { display: block; }
.search-result-item {
  padding: 8px 12px;
  cursor: pointer;
  border-bottom: 1px solid var(--border);
}
.search-result-item:hover { background: var(--bg-hover); }
.search-result-item .sr-id { color: var(--accent); font-size: 11px; font-weight: 600; }
.search-result-item .sr-title { font-size: 13px; }
.sr-snippet { font-size: 12px; color: var(--text-muted); margin-top: 2px; max-height: 36px; overflow: hidden; }
.search-result-item mark { background: rgba(249,226,175,0.3); color: var(--yellow); padding: 0 2px; border-radius: 2px; }
.header-actions { display: flex; gap: 8px; margin-left: auto; }
.header-btn {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 5px 12px;
  border-radius: 6px;
  font-size: 12px;
  cursor: pointer;
  white-space: nowrap;
}
.header-btn:hover { background: var(--bg-hover); }
.header-btn.active { background: var(--accent-dim); border-color: var(--accent); }

/* TAB BAR */
.tab-bar {
  display: flex;
  background: var(--bg-tertiary);
  border-bottom: 1px solid var(--border);
  overflow-x: auto;
  min-height: 0;
  scrollbar-width: none;
  flex-shrink: 0;
}
.tab-bar::-webkit-scrollbar { display: none; }
.tab-bar:empty { min-height: 0; border: none; }
.tab {
  display: flex;
  align-items: center;
  padding: 4px 12px;
  font-size: 12px;
  cursor: pointer;
  border-right: 1px solid var(--border);
  white-space: nowrap;
  color: var(--text-muted);
  gap: 6px;
  max-width: 180px;
  min-width: 0;
  user-select: none;
}
.tab:hover { background: var(--bg-surface); }
.tab.active { background: var(--bg-primary); color: var(--text-primary); border-bottom: 2px solid var(--accent); }
.tab-close { font-size: 14px; opacity: 0.5; line-height: 1; flex-shrink: 0; border-radius: 3px; padding: 0 2px; }
.tab-close:hover { opacity: 1; background: var(--bg-hover); }
.tab-title { overflow: hidden; text-overflow: ellipsis; min-width: 0; }
.tab-id { font-family: 'SF Mono', 'Fira Code', monospace; font-size: 10px; color: var(--accent); opacity: 0.8; flex-shrink: 0; }
.tab.active .tab-id { opacity: 1; }
.tab.dragging { opacity: 0.4; transform: scale(0.95); }
.tab.drag-over { box-shadow: inset 3px 0 0 var(--accent); }

/* LAYOUT */
.layout {
  display: flex;
  height: calc(100vh - var(--header-height));
}

/* SIDEBAR */
.sidebar {
  width: var(--sidebar-width);
  min-width: var(--sidebar-width);
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  overflow-y: auto;
  overflow-x: hidden;
  padding: 8px 0;
  transition: transform 0.2s;
}
.sidebar-filter {
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
}
.filter-tag {
  display: inline-block;
  background: var(--accent-dim);
  color: var(--accent);
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 11px;
  margin: 2px;
  cursor: pointer;
}
.filter-tag:hover { background: var(--bg-hover); }
.filter-tag.active { background: var(--accent); color: var(--bg-tertiary); }
.clear-filter { font-size: 11px; color: var(--text-muted); cursor: pointer; margin-left: 4px; }
.clear-filter:hover { color: var(--red); }
.sidebar-section { margin-bottom: 2px; }
.sidebar-section-header {
  display: flex;
  align-items: center;
  padding: 6px 12px;
  cursor: pointer;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  user-select: none;
}
.sidebar-section-header:hover { color: var(--text-primary); }
.sidebar-section-header .chevron {
  margin-right: 6px;
  font-size: 8px;
  transition: transform 0.2s ease;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 12px;
  flex-shrink: 0;
}
.sidebar-section.collapsed .chevron { transform: rotate(-90deg); }
.sidebar-items-wrap {
  overflow: hidden;
  transition: height 0.2s ease;
}
.sidebar-item {
  display: flex;
  align-items: center;
  padding: 4px 12px 4px 28px;
  cursor: pointer;
  font-size: 13px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.sidebar-item:hover { background: var(--bg-hover); color: var(--text-primary); }
.sidebar-item.active { background: var(--accent-dim); color: var(--accent); }
.sidebar-item .doc-id {
  color: var(--text-muted);
  font-size: 11px;
  font-family: monospace;
  margin-right: 8px;
  min-width: 56px;
}
.sidebar-item .doc-title { overflow: hidden; text-overflow: ellipsis; }
.doc-count {
  padding: 8px 12px;
  font-size: 11px;
  color: var(--text-muted);
  border-top: 1px solid var(--border);
}

/* MAIN CONTENT */
.main-content {
  flex: 1;
  overflow-y: auto;
  padding: 32px 48px;
  min-width: 0;
  position: relative;
}

/* READING PROGRESS BAR */
.reading-progress-bar {
  position: sticky;
  top: 0;
  left: 0;
  width: 0%;
  height: 3px;
  background: linear-gradient(90deg, var(--accent), var(--mauve));
  z-index: 50;
  transition: width 0.15s ease-out;
  pointer-events: none;
  opacity: 0;
  margin: -32px -48px 32px -48px;
}
.reading-progress-bar.visible {
  opacity: 1;
}

.welcome {
  max-width: 600px;
  margin: 80px auto;
  text-align: center;
}
.welcome h1 { font-size: 28px; margin-bottom: 12px; color: var(--accent); }
.welcome p { color: var(--text-secondary); font-size: 14px; line-height: 1.6; }
.welcome .stats { margin-top: 24px; display: flex; gap: 24px; justify-content: center; }
.welcome .stat { text-align: center; }
.welcome .stat-num { font-size: 28px; font-weight: 700; color: var(--accent); }
.welcome .stat-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; }

/* BREADCRUMB */
.breadcrumb {
  display: none;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: var(--text-muted);
  margin-bottom: 12px;
  user-select: none;
}
.breadcrumb.active { display: flex; }
.breadcrumb .bc-separator { color: var(--text-muted); opacity: 0.5; font-size: 10px; }
.breadcrumb .bc-vault { color: var(--text-muted); }
.breadcrumb .bc-domain {
  color: var(--text-secondary);
  cursor: pointer;
  border-radius: 3px;
  padding: 1px 4px;
  transition: color 0.15s, background 0.15s;
}
.breadcrumb .bc-domain:hover { color: var(--accent); background: var(--accent-dim); }
.breadcrumb .bc-current { color: var(--text-muted); font-family: 'SF Mono', 'Fira Code', monospace; font-size: 11px; }

/* DOC VIEWER */
.doc-viewer { display: none; max-width: 860px; opacity: 1; transition: opacity 0.15s ease; }
.doc-viewer.active { display: block; }
.doc-viewer.doc-transitioning { opacity: 0; }
.doc-header { margin-bottom: 24px; }
.doc-header h1 { font-size: 24px; line-height: 1.3; margin-bottom: 8px; }
.doc-badges { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
.doc-badge-pill { display: inline-flex; align-items: center; font-size: 11px; font-weight: 600; padding: 2px 10px; border-radius: 9999px; line-height: 1.6; letter-spacing: 0.2px; white-space: nowrap; border: 1px solid transparent; }
.doc-badge-pill.badge-version { background: rgba(137,180,250,0.15); color: var(--accent); border-color: rgba(137,180,250,0.3); }
.doc-badge-pill.badge-status-ratified { background: rgba(166,227,161,0.15); color: var(--green); border-color: rgba(166,227,161,0.3); }
.doc-badge-pill.badge-status-draft { background: rgba(249,226,175,0.15); color: var(--yellow); border-color: rgba(249,226,175,0.3); }
.doc-badge-pill.badge-status-active { background: rgba(137,180,250,0.15); color: var(--accent); border-color: rgba(137,180,250,0.3); }
.doc-badge-pill.badge-status-deprecated { background: rgba(243,139,168,0.15); color: var(--red); border-color: rgba(243,139,168,0.3); }
.doc-badge-pill.badge-status-other { background: rgba(108,112,134,0.15); color: var(--text-muted); border-color: rgba(108,112,134,0.3); }
.doc-badge-pill.badge-date { background: rgba(108,112,134,0.10); color: var(--text-muted); border-color: rgba(108,112,134,0.2); font-weight: 500; }
.doc-meta { display: flex; gap: 12px; flex-wrap: wrap; font-size: 12px; color: var(--text-muted); }
.doc-meta .badge { background: var(--bg-surface); padding: 2px 8px; border-radius: 4px; }
.doc-reading-info { font-size: 12px; color: var(--text-muted); margin-top: 6px; letter-spacing: 0.2px; }
.doc-toolbar {
  display: flex;
  gap: 8px;
  margin-bottom: 20px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 12px;
}
.doc-toolbar button {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 4px 12px;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
}
.doc-toolbar button:hover { color: var(--text-primary); background: var(--bg-surface); }
.doc-toolbar button:disabled { color: var(--text-muted); opacity: 0.4; cursor: default; pointer-events: none; }
.doc-toolbar button.active { color: var(--accent); border-color: var(--accent); }
.doc-toolbar .nav-btn { font-size: 14px; padding: 4px 8px; min-width: 28px; display: inline-flex; align-items: center; justify-content: center; }
.doc-toolbar .nav-separator { width: 1px; background: var(--border); align-self: stretch; margin: 2px 4px; }
.doc-body { font-size: 15px; line-height: 1.7; color: var(--text-primary); }
.doc-body h1 { font-size: 22px; margin: 24px 0 12px; color: var(--text-primary); }
.doc-body h2 { font-size: 18px; margin: 20px 0 10px; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 4px; }
.doc-body h3 { font-size: 15px; margin: 16px 0 8px; color: var(--peach); }
.doc-body p { margin: 8px 0; }
.doc-body ul, .doc-body ol { margin: 8px 0 8px 24px; }
.doc-body li { margin: 4px 0; }
.doc-body em { color: var(--yellow); font-style: italic; }
.doc-body strong { color: var(--text-primary); font-weight: 700; }
.doc-body blockquote {
  border-left: 3px solid var(--accent);
  padding: 8px 16px;
  margin: 12px 0;
  background: var(--bg-secondary);
  border-radius: 0 4px 4px 0;
}
.doc-body code { background: var(--bg-surface); padding: 1px 5px; border-radius: 3px; font-size: 13px; font-family: 'SF Mono', 'Fira Code', monospace; }
.doc-body pre { background: var(--bg-tertiary); padding: 16px; border-radius: 6px; overflow-x: auto; margin: 12px 0; position: relative; }
.doc-body pre code { background: none; padding: 0; }

/* CODE BLOCK COPY BUTTON */
.code-copy-btn {
  position: absolute;
  top: 6px;
  right: 6px;
  background: rgba(49, 50, 68, 0.8);
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 11px;
  font-family: inherit;
  padding: 2px 8px;
  border-radius: 4px;
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.15s, background 0.15s, color 0.15s;
  z-index: 1;
  line-height: 1.4;
}
.doc-body pre:hover .code-copy-btn { opacity: 1; }
.code-copy-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
.code-copy-btn.copied { color: var(--green); border-color: var(--green); }
.doc-body table { border-collapse: collapse; margin: 12px 0; width: 100%; }
.doc-body th, .doc-body td { border: 1px solid var(--border); padding: 8px 12px; font-size: 13px; text-align: left; }
.doc-body th { background: var(--bg-surface); font-weight: 600; }
.doc-body .metadata { display: none; }
.doc-body aside.metadata { display: none; }

/* Doc ID inline links */
a.doc-link { color: var(--accent); cursor: pointer; text-decoration: underline dotted; text-underline-offset: 3px; }

/* Doc link preview tooltip */
.doc-link-tooltip {
  position: fixed;
  z-index: 500;
  display: none;
  width: 320px;
  max-width: calc(100vw - 32px);
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 2px 8px rgba(0, 0, 0, 0.3);
  padding: 12px 14px;
  pointer-events: none;
  font-size: 13px;
  line-height: 1.5;
}
.doc-link-tooltip.visible { display: block; }
.doc-link-tooltip-id {
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 11px;
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 4px;
}
.doc-link-tooltip-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 6px;
  line-height: 1.3;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}
.doc-link-tooltip-domain {
  font-size: 11px;
  color: var(--text-muted);
  margin-bottom: 6px;
}
.doc-link-tooltip-excerpt {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.5;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  margin-bottom: 6px;
}
.doc-link-tooltip-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
}
.doc-link-tooltip-tag {
  display: inline-block;
  background: var(--accent-dim);
  color: var(--accent);
  padding: 1px 6px;
  border-radius: 3px;
  font-size: 10px;
}

/* Edit mode */
.edit-area {
  display: none;
  width: 100%;
  min-height: 500px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 14px;
  line-height: 1.6;
  padding: 16px;
  border-radius: 6px;
  resize: vertical;
}
.edit-area.active { display: block; }
.save-bar { display: none; margin-top: 12px; gap: 8px; }
.save-bar.active { display: flex; }
.save-bar button { padding: 6px 16px; border-radius: 6px; font-size: 13px; cursor: pointer; border: none; }
.save-btn { background: var(--accent); color: var(--bg-tertiary); font-weight: 600; }
.cancel-btn { background: var(--bg-surface); color: var(--text-secondary); border: 1px solid var(--border) !important; }

/* TABLE OF CONTENTS */
.toc-section { margin-bottom: 20px; }
.toc-item { display: block; padding: 2px 0; font-size: 13px; color: var(--text-secondary); cursor: pointer; }
.toc-item:hover { color: var(--text-primary); }
.toc-item.toc-h2 { padding-left: 0; }
.toc-item.toc-h3 { padding-left: 12px; font-size: 12px; }

/* LOCAL GRAPH */
.local-graph { width: 100%; height: 200px; border-bottom: 1px solid var(--border); margin-bottom: 12px; position: relative; }
.local-graph canvas { display: block; width: 100%; height: 100%; cursor: default; }
#localGraphTooltip {
  position: fixed;
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-size: 11px;
  font-family: 'SF Mono', 'Fira Code', monospace;
  padding: 4px 8px;
  border-radius: 4px;
  pointer-events: none;
  white-space: nowrap;
  z-index: 999;
  display: none;
}

/* BACKLINKS PANEL */
.backlinks-panel {
  width: var(--backlinks-width);
  min-width: var(--backlinks-width);
  background: var(--bg-secondary);
  border-left: 1px solid var(--border);
  overflow-y: auto;
  padding: 16px;
  display: none;
}
.backlinks-panel.active { display: block; }
.backlinks-section { margin-bottom: 20px; }
.backlinks-section h3 {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-muted);
  margin-bottom: 8px;
}
.backlink-item { display: block; padding: 4px 0; font-size: 13px; color: var(--accent); cursor: pointer; }
.backlink-item:hover { color: var(--text-primary); }
.tag-item {
  display: inline-block;
  background: var(--accent-dim);
  color: var(--accent);
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 11px;
  margin: 2px 4px 2px 0;
  cursor: pointer;
}
.tag-item:hover { background: var(--bg-hover); }

/* PERSONAL NOTES */
.notes-section { margin-bottom: 20px; }
.notes-section h3 {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-muted);
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.notes-section h3 .notes-count {
  font-size: 10px;
  color: var(--text-secondary);
  font-weight: 400;
}
.notes-textarea {
  width: 100%;
  background: var(--bg-tertiary);
  color: var(--text-primary);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 8px;
  font-size: 12px;
  font-family: inherit;
  resize: vertical;
  outline: none;
  line-height: 1.4;
}
.notes-textarea:focus {
  border-color: var(--accent);
}
.notes-textarea::placeholder {
  color: var(--text-muted);
  font-style: italic;
}
.notes-actions {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 6px;
  min-height: 20px;
}
.notes-clear-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 4px;
  cursor: pointer;
}
.notes-clear-btn:hover {
  color: var(--red);
  border-color: var(--red);
}
.notes-saved-indicator {
  font-size: 11px;
  color: var(--green);
  opacity: 0;
  transition: opacity 0.3s ease;
}
.notes-saved-indicator.visible {
  opacity: 1;
}
.sidebar-item .note-icon {
  font-size: 10px;
  color: var(--yellow);
  margin-left: auto;
  flex-shrink: 0;
  opacity: 0.8;
  padding-left: 4px;
}

/* RELATED DOCS SECTION */
.related-section h3 { cursor: pointer; user-select: none; display: flex; align-items: center; gap: 4px; }
.related-section h3 .related-chevron {
  display: inline-block;
  font-size: 8px;
  transition: transform 0.2s ease;
}
.related-section.collapsed h3 .related-chevron { transform: rotate(-90deg); }
.related-section.collapsed .related-list { display: none; }
.related-item {
  display: block;
  padding: 5px 0;
  border-bottom: 1px solid var(--border);
}
.related-item:last-child { border-bottom: none; }
.related-item-link {
  display: block;
  font-size: 13px;
  color: var(--accent);
  cursor: pointer;
}
.related-item-link:hover { color: var(--text-primary); }
.related-item-title {
  font-size: 12px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.related-item-score {
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 1px;
}

/* LOADING */
.loading { display: flex; align-items: center; justify-content: center; height: 200px; color: var(--text-muted); }
.spinner {
  width: 24px;
  height: 24px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
  margin-right: 12px;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* STATUS BAR */
.status-bar {
  height: 24px;
  background: var(--bg-tertiary);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 16px;
  font-size: 11px;
  color: var(--text-muted);
  gap: 16px;
}

/* QUICK OPEN / COMMAND PALETTE */
.quick-open-overlay {
  position: fixed; inset: 0;
  background: rgba(0, 0, 0, 0.55);
  z-index: 300;
  display: flex;
  align-items: flex-start;
  justify-content: center;
  padding-top: 12vh;
  backdrop-filter: blur(2px);
}
.quick-open-panel {
  width: 100%; max-width: 500px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 10px;
  box-shadow: 0 24px 64px rgba(0, 0, 0, 0.6);
  overflow: hidden;
  display: flex; flex-direction: column;
  max-height: 70vh;
}
#quickOpenInput {
  width: 100%; background: var(--bg-surface); border: none;
  border-bottom: 1px solid var(--border);
  color: var(--text-primary); font-size: 15px; padding: 14px 16px;
  outline: none; font-family: inherit; flex-shrink: 0;
}
#quickOpenInput::placeholder { color: var(--text-muted); }
.quick-open-results { overflow-y: auto; flex: 1; }
.quick-open-item {
  display: flex; align-items: baseline; gap: 10px;
  padding: 9px 16px; cursor: pointer;
  border-bottom: 1px solid rgba(49, 50, 68, 0.5);
}
.quick-open-item:last-child { border-bottom: none; }
.quick-open-item:hover, .quick-open-item.selected { background: var(--bg-hover); }
.quick-open-item .qo-id { color: var(--accent); font-size: 11px; font-weight: 600; font-family: 'SF Mono', 'Fira Code', monospace; min-width: 60px; flex-shrink: 0; }
.quick-open-item .qo-title { font-size: 13px; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.quick-open-empty { padding: 24px 16px; text-align: center; color: var(--text-muted); font-size: 13px; }
.quick-open-hint {
  padding: 7px 16px; font-size: 11px; color: var(--text-muted);
  background: var(--bg-tertiary); border-top: 1px solid var(--border);
  display: flex; gap: 16px; flex-shrink: 0;
}
.quick-open-hint kbd {
  display: inline-block; background: var(--bg-surface); border: 1px solid var(--border);
  border-radius: 3px; padding: 0px 5px; font-size: 10px; font-family: inherit;
  color: var(--text-secondary); margin-right: 3px;
}

/* KEYBOARD SHORTCUTS MODAL */
.shortcuts-modal-overlay {
  display: none; position: fixed; inset: 0;
  background: rgba(0, 0, 0, 0.65); z-index: 1000;
  align-items: center; justify-content: center;
  backdrop-filter: blur(2px);
}
.shortcuts-modal-overlay.active { display: flex; }
.shortcuts-modal {
  background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 10px;
  width: 520px; max-width: calc(100vw - 32px); max-height: calc(100vh - 64px);
  overflow-y: auto; box-shadow: 0 24px 64px rgba(0, 0, 0, 0.6);
}
.shortcuts-modal-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 18px 24px 14px; border-bottom: 1px solid var(--border);
}
.shortcuts-modal-header h2 { font-size: 15px; font-weight: 700; color: var(--text-primary); }
.shortcuts-modal-close {
  background: none; border: none; color: var(--text-muted); font-size: 20px;
  cursor: pointer; line-height: 1; padding: 2px 6px; border-radius: 4px;
}
.shortcuts-modal-close:hover { color: var(--text-primary); background: var(--bg-hover); }
.shortcuts-modal-body { padding: 16px 24px 20px; }
.shortcuts-group { margin-bottom: 20px; }
.shortcuts-group:last-child { margin-bottom: 0; }
.shortcuts-group-label { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.8px; color: var(--text-muted); margin-bottom: 8px; }
.shortcuts-table { width: 100%; border-collapse: collapse; }
.shortcuts-table tr + tr td { border-top: 1px solid var(--border); }
.shortcuts-table td { padding: 7px 0; font-size: 13px; vertical-align: middle; }
.shortcuts-table td:first-child { color: var(--text-secondary); padding-right: 24px; white-space: nowrap; }
.shortcuts-table td:last-child { color: var(--text-muted); text-align: right; }
.kbd {
  display: inline-block; background: var(--bg-surface); border: 1px solid var(--bg-hover);
  border-bottom-width: 2px; border-radius: 4px; padding: 1px 7px; font-size: 11px;
  font-family: 'SF Mono', 'Fira Code', monospace; color: var(--accent); white-space: nowrap;
}
.kbd + .kbd { margin-left: 4px; }

/* RESPONSIVE - MOBILE (below 768px) */
@media (max-width: 768px) {

  /* --- Hamburger menu button: touch-friendly 44px target --- */
  .hamburger {
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 44px;
    min-height: 44px;
    font-size: 22px;
    padding: 0;
    border-radius: 6px;
    -webkit-tap-highlight-color: transparent;
  }
  .hamburger:active {
    background: var(--bg-hover);
  }

  /* --- Header: compact for mobile, no overflow --- */
  .header {
    padding: 0 8px;
    gap: 6px;
    overflow: hidden;
  }
  .header-brand {
    font-size: 12px;
    letter-spacing: 0.5px;
    flex-shrink: 0;
  }
  .search-box {
    max-width: none;
    min-width: 0;
    flex: 1;
  }
  .search-box input {
    font-size: 16px; /* prevents iOS auto-zoom on focus */
    padding: 8px 12px 8px 32px;
    min-height: 38px;
  }
  .header-actions {
    gap: 2px;
    flex-shrink: 0;
  }
  .header-actions .graph-label { display: none; }
  .header-btn {
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 6px;
    font-size: 15px;
    -webkit-tap-highlight-color: transparent;
  }
  .header-btn:active {
    background: var(--bg-hover);
  }

  /* --- Tab bar: horizontally scrollable with touch momentum --- */
  .tab-bar {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scroll-snap-type: x proximity;
    flex-shrink: 0;
  }
  .tab {
    min-height: 44px;
    padding: 6px 14px;
    font-size: 13px;
    scroll-snap-align: start;
    flex-shrink: 0;
    -webkit-tap-highlight-color: transparent;
  }
  .tab-close {
    min-width: 30px;
    min-height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    border-radius: 4px;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- Layout: stack vertically on mobile --- */
  .layout {
    flex-direction: column;
    height: calc(100vh - var(--header-height));
    overflow: hidden;
  }

  /* --- Sidebar: fixed overlay sliding in from left --- */
  .sidebar {
    position: fixed;
    top: var(--header-height);
    left: 0;
    bottom: 24px;
    z-index: 50;
    transform: translateX(-100%);
    transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: none;
    will-change: transform;
  }
  .sidebar.open {
    transform: translateX(0);
    box-shadow: 6px 0 32px rgba(0, 0, 0, 0.5);
  }

  /* --- Sidebar overlay: tap outside to close --- */
  .sidebar-overlay {
    display: none;
    position: fixed;
    inset: 0;
    top: var(--header-height);
    bottom: 24px;
    background: rgba(0, 0, 0, 0.5);
    z-index: 49;
    -webkit-tap-highlight-color: transparent;
  }
  .sidebar-overlay.active {
    display: block;
  }

  /* --- Sidebar items: touch-friendly 44px tap targets --- */
  .sidebar-section-header {
    min-height: 44px;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .sidebar-item {
    min-height: 44px;
    padding: 8px 12px 8px 28px;
    display: flex;
    align-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .sidebar-item:active {
    background: var(--bg-hover);
  }
  .filter-tag {
    min-height: 34px;
    display: inline-flex;
    align-items: center;
    padding: 4px 14px;
    font-size: 12px;
  }
  .clear-filter {
    min-width: 44px;
    min-height: 44px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  /* --- Main content: reduced padding --- */
  .main-content {
    padding: 16px 14px;
    flex: 1;
    min-height: 0;
    overflow-y: auto;
  }
  .reading-progress-bar {
    margin: -16px -14px 16px -14px;
  }
  .welcome {
    margin: 40px auto;
    padding: 0 8px;
  }
  .welcome h1 { font-size: 22px; }
  .welcome p { font-size: 13px; }
  .welcome .stats { gap: 16px; flex-wrap: wrap; }
  .welcome .stat-num { font-size: 22px; }

  /* --- Doc viewer --- */
  .doc-header h1 { font-size: 18px; word-break: break-word; }
  .doc-meta { font-size: 11px; gap: 6px; }
  .doc-meta .badge { padding: 3px 8px; }
  .doc-body { font-size: 14px; line-height: 1.65; }
  .doc-body h1 { font-size: 19px; }
  .doc-body h2 { font-size: 16px; }
  .doc-body h3 { font-size: 14px; }
  .doc-body pre {
    padding: 12px;
    font-size: 12px;
    -webkit-overflow-scrolling: touch;
  }
  .doc-body table {
    display: block;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  .doc-body blockquote {
    padding: 6px 12px;
    margin: 8px 0;
  }
  .doc-body ul, .doc-body ol { margin-left: 18px; }

  /* --- Code copy button: always visible on mobile (no hover) --- */
  .code-copy-btn {
    opacity: 1;
    min-width: 44px;
    min-height: 32px;
    padding: 4px 10px;
    font-size: 12px;
  }

  /* --- Doc toolbar: scrollable, prevents overflow --- */
  .doc-toolbar {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    flex-wrap: nowrap;
    gap: 6px;
    padding-bottom: 10px;
    margin-bottom: 16px;
    scrollbar-width: none;
  }
  .doc-toolbar::-webkit-scrollbar { display: none; }
  .doc-toolbar button {
    min-height: 44px;
    min-width: 44px;
    padding: 8px 16px;
    flex-shrink: 0;
    white-space: nowrap;
    font-size: 13px;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- Backlinks panel: moves below content (not side-by-side) --- */
  .backlinks-panel {
    width: 100%;
    min-width: 100%;
    max-height: none;
    border-left: none;
    border-top: 1px solid var(--border);
    overflow-y: auto;
    flex-shrink: 0;
    padding: 14px;
  }
  .backlinks-panel.active {
    display: block;
    max-height: 45vh;
  }
  .backlink-item {
    min-height: 44px;
    display: flex;
    align-items: center;
    padding: 6px 0;
    -webkit-tap-highlight-color: transparent;
  }
  .tag-item {
    min-height: 34px;
    display: inline-flex;
    align-items: center;
    padding: 4px 14px;
    font-size: 12px;
  }
  .toc-item {
    min-height: 38px;
    display: flex;
    align-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .local-graph {
    height: 160px;
  }
  .backlinks-section h3 {
    min-height: 32px;
    display: flex;
    align-items: center;
  }

  /* --- Quick open palette: full-width on mobile --- */
  .quick-open-overlay {
    padding-top: 0;
    align-items: flex-start;
  }
  .quick-open-panel {
    max-width: 100%;
    width: 100%;
    border-radius: 0 0 10px 10px;
    max-height: 85vh;
  }
  #quickOpenInput {
    font-size: 16px; /* prevents iOS zoom */
    padding: 16px;
    min-height: 52px;
  }
  .quick-open-item {
    min-height: 48px;
    padding: 10px 16px;
    display: flex;
    align-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .quick-open-hint {
    flex-wrap: wrap;
    padding: 8px 16px;
    gap: 8px;
  }

  /* --- Search results dropdown --- */
  .search-results {
    max-height: 60vh;
  }
  .search-result-item {
    min-height: 44px;
    padding: 10px 12px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- Shortcuts modal --- */
  .shortcuts-modal {
    width: calc(100vw - 16px);
    max-height: calc(100vh - 32px);
  }
  .shortcuts-modal-body { padding: 12px 16px 16px; }
  .shortcuts-modal-header { padding: 14px 16px 10px; }
  .shortcuts-modal-close {
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* --- Favorites button: touch-friendly --- */
  .favorite-btn {
    min-width: 44px;
    min-height: 44px;
  }
  .sidebar-section.favorites-section .sidebar-item .fav-remove {
    opacity: 0.6;
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* --- Scroll-to-top: touch-friendly --- */
  .scroll-to-top {
    bottom: 16px;
    right: 16px;
    width: 44px;
    height: 44px;
  }

  /* --- Status bar --- */
  .status-bar {
    font-size: 10px;
    padding: 0 8px;
    gap: 8px;
    overflow: hidden;
    white-space: nowrap;
  }

  /* --- Edit area --- */
  .edit-area {
    font-size: 14px;
    padding: 12px;
    min-height: 300px;
  }
  .save-bar button {
    min-height: 44px;
    min-width: 80px;
    padding: 8px 20px;
    font-size: 14px;
    -webkit-tap-highlight-color: transparent;
  }

  /* --- Breadcrumb --- */
  .breadcrumb {
    font-size: 11px;
    flex-wrap: wrap;
    gap: 4px;
  }
  .breadcrumb .bc-domain {
    min-height: 28px;
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
  }

  /* --- Doc links: touch-friendly --- */
  a.doc-link {
    padding: 2px 0;
  }
}

/* Extra small screens (below 480px) */
@media (max-width: 480px) {
  .header-brand { display: none; }
  .main-content { padding: 12px 10px; }
  .reading-progress-bar { margin: -12px -10px 12px -10px; }
  .doc-header h1 { font-size: 16px; }
  .doc-body { font-size: 13px; line-height: 1.6; }
  .doc-body h1 { font-size: 17px; }
  .doc-body h2 { font-size: 15px; }
  .doc-body h3 { font-size: 13px; }
  .welcome h1 { font-size: 18px; }
  .welcome p { font-size: 12px; }
  .quick-open-panel { border-radius: 0; }
  .doc-meta { gap: 4px; }
  .doc-meta .badge { font-size: 10px; }
}

/* FAVORITES STAR BUTTON (doc toolbar) */
.favorite-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 16px;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 4px;
  line-height: 1;
  transition: color 0.15s, border-color 0.15s;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin-left: auto;
}
.favorite-btn:hover { color: var(--yellow); border-color: var(--yellow); background: var(--bg-surface); }
.favorite-btn.favorited { color: var(--yellow); border-color: var(--yellow); }

/* FAVORITES SIDEBAR SECTION */
.sidebar-section.favorites-section .sidebar-section-header {
  color: var(--yellow);
}
.sidebar-section.favorites-section .sidebar-item {
  padding-right: 8px;
}
.sidebar-section.favorites-section .sidebar-item .fav-remove {
  margin-left: auto;
  font-size: 13px;
  color: var(--text-muted);
  opacity: 0;
  padding: 0 4px;
  cursor: pointer;
  flex-shrink: 0;
  transition: opacity 0.15s;
  line-height: 1;
}
.sidebar-section.favorites-section .sidebar-item:hover .fav-remove {
  opacity: 1;
}
.sidebar-section.favorites-section .sidebar-item .fav-remove:hover {
  color: var(--red);
}
.sidebar-section.favorites-section .sidebar-items-empty {
  padding: 4px 12px 8px 28px;
  font-size: 12px;
  color: var(--text-muted);
  font-style: italic;
}

/* SCROLL-TO-TOP BUTTON */
.scroll-to-top {
  position: absolute;
  bottom: 24px;
  right: 24px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: rgba(49, 50, 68, 0.85);
  border: 1px solid var(--border);
  color: var(--accent);
  font-size: 18px;
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 30;
  opacity: 0;
  transform: translateY(12px);
  pointer-events: none;
  transition: opacity 0.25s ease, transform 0.25s ease, background 0.15s ease, border-color 0.15s ease;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}
.scroll-to-top.visible {
  opacity: 1;
  transform: translateY(0);
  pointer-events: auto;
}
.scroll-to-top:hover {
  background: rgba(69, 71, 90, 0.95);
  color: var(--text-primary);
  border-color: var(--accent);
}
.scroll-to-top:active {
  transform: scale(0.92);
}


/* RECENTLY VIEWED */
.recent-section { border-bottom: 1px solid var(--border); padding-bottom: 4px; margin-bottom: 4px; }
.recent-section-header {
  display: flex;
  align-items: center;
  padding: 6px 12px;
  cursor: pointer;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--yellow);
  user-select: none;
}
.recent-section-header:hover { color: var(--text-primary); }
.recent-section-header .chevron {
  margin-right: 6px;
  font-size: 10px;
  transition: transform 0.15s;
  display: inline-block;
  width: 12px;
}
.recent-section.collapsed .chevron { transform: rotate(-90deg); }
.recent-section.collapsed .recent-items { display: none; }
.recent-section.collapsed .recent-clear-btn { display: none; }
.recent-clear-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 10px;
  padding: 1px 6px;
  border-radius: 3px;
  cursor: pointer;
  margin-left: auto;
  line-height: 1.4;
}
.recent-clear-btn:hover { color: var(--red); border-color: var(--red); }

/* FULLSCREEN / FOCUS MODE */
body.fullscreen-mode .sidebar {
  width: 0; min-width: 0; padding: 0; overflow: hidden;
  border-right-color: transparent; opacity: 0; pointer-events: none;
}
body.fullscreen-mode .backlinks-panel {
  width: 0; min-width: 0; padding: 0; overflow: hidden;
  border-left-color: transparent; opacity: 0; pointer-events: none;
}
body.fullscreen-mode .tab-bar {
  max-height: 0; min-height: 0; overflow: hidden; border-bottom: none; opacity: 0;
}
body.fullscreen-mode .main-content {
  padding: 48px 64px;
}
body.fullscreen-mode .reading-progress-bar {
  margin: -48px -64px 48px -64px;
}
body.fullscreen-mode .doc-viewer {
  max-width: 800px;
  margin: 0 auto;
}
body.fullscreen-mode .welcome {
  max-width: 800px;
}
body.fullscreen-mode #fullscreenToggle {
  background: var(--accent-dim);
  border-color: var(--accent);
  color: var(--accent);
}

/* Smooth transitions for fullscreen */
.sidebar {
  transition: width 0.3s ease, min-width 0.3s ease, opacity 0.25s ease,
              padding 0.3s ease, border-right-color 0.3s ease, transform 0.2s;
}
.backlinks-panel {
  transition: width 0.3s ease, min-width 0.3s ease, opacity 0.25s ease,
              padding 0.3s ease, border-left-color 0.3s ease;
}
.tab-bar {
  transition: max-height 0.3s ease, opacity 0.25s ease;
}
.main-content {
  transition: padding 0.3s ease;
}
.doc-viewer {
  transition: max-width 0.3s ease, margin 0.3s ease, opacity 0.15s ease;
}

/* Floating exit hint */
.fullscreen-exit-hint {
  display: none;
  position: fixed;
  bottom: 36px;
  left: 50%;
  transform: translateX(-50%) translateY(8px);
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  color: var(--text-muted);
  padding: 6px 16px;
  border-radius: 8px;
  font-size: 12px;
  z-index: 150;
  cursor: pointer;
  white-space: nowrap;
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
  user-select: none;
}
.fullscreen-exit-hint:hover {
  color: var(--text-primary);
  border-color: var(--accent);
}
.fullscreen-exit-hint .kbd {
  font-size: 10px;
  margin-left: 6px;
}
body.fullscreen-mode .fullscreen-exit-hint {
  display: block;
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* Scrollbar */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--bg-secondary); }
::-webkit-scrollbar-thumb { background: var(--bg-hover); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

/* ─── PRINT STYLES ───────────────────────────────────────────────────────── */
@media print {
  /* Reset base colors for paper */
  * { color-adjust: exact; -webkit-print-color-adjust: exact; }
  html, body {
    background: #fff !important;
    color: #000 !important;
    height: auto !important;
    overflow: visible !important;
    font-size: 12pt;
  }

  /* Hide all chrome: sidebar, backlinks, toolbar, tabs, header, graph, overlays, status bar */
  .header,
  .tab-bar,
  .sidebar,
  .sidebar-overlay,
  .backlinks-panel,
  .doc-toolbar,
  .status-bar,
  .quick-open-overlay,
  .shortcuts-modal-overlay,
  .search-results,
  .local-graph,
  #localGraphTooltip,
  .hamburger,
  .welcome,
  .edit-area,
  .save-bar,
  .loading,
  .breadcrumb,
  .code-copy-btn,
  .doc-reading-info,
  .fullscreen-exit-hint,
  .reading-progress-bar,
  .minimap-container,
  .toast-container { display: none !important; }

  /* Layout: full width, no flex constraints */
  .layout {
    display: block !important;
    height: auto !important;
    overflow: visible !important;
  }
  .main-content {
    padding: 0 !important;
    overflow: visible !important;
    width: 100% !important;
    max-width: 100% !important;
  }
  .doc-viewer {
    display: block !important;
    max-width: 100% !important;
  }

  /* Doc header: show title and ID prominently at top of printed page */
  .doc-header {
    margin-bottom: 16pt !important;
    border-bottom: 2pt solid #000;
    padding-bottom: 10pt;
  }
  .doc-header h1 {
    font-size: 20pt !important;
    color: #000 !important;
    margin-bottom: 6pt !important;
  }
  .doc-meta {
    font-size: 10pt !important;
    color: #333 !important;
  }
  .doc-meta .badge {
    background: #eee !important;
    color: #333 !important;
    border: 1px solid #ccc;
    padding: 1pt 6pt;
  }

  /* Body text */
  .doc-body {
    font-size: 11pt !important;
    line-height: 1.6 !important;
    color: #000 !important;
  }
  .doc-body h1 {
    font-size: 18pt !important;
    color: #000 !important;
    margin: 18pt 0 8pt !important;
  }
  .doc-body h2 {
    font-size: 15pt !important;
    color: #000 !important;
    border-bottom: 1px solid #999 !important;
    padding-bottom: 3pt !important;
    margin: 14pt 0 7pt !important;
  }
  .doc-body h3 {
    font-size: 13pt !important;
    color: #222 !important;
    margin: 10pt 0 5pt !important;
  }
  .doc-body p { color: #000 !important; }
  .doc-body em { color: #000 !important; font-style: italic; }
  .doc-body strong { color: #000 !important; }
  .doc-body ul, .doc-body ol { color: #000 !important; }
  .doc-body li { color: #000 !important; }
  .doc-body blockquote {
    border-left: 3px solid #666 !important;
    background: #f5f5f5 !important;
    color: #000 !important;
    padding: 6pt 12pt !important;
  }

  /* Inline code */
  .doc-body code {
    background: #f0f0f0 !important;
    color: #000 !important;
    border: 1px solid #ddd;
    padding: 0pt 3pt;
    font-size: 9pt !important;
  }

  /* Code blocks: avoid page breaks inside, clean border */
  .doc-body pre {
    background: #f5f5f5 !important;
    color: #000 !important;
    border: 1px solid #ccc;
    padding: 10pt !important;
    border-radius: 0 !important;
    page-break-inside: avoid;
    break-inside: avoid;
    overflow-x: visible !important;
    white-space: pre-wrap !important;
    word-wrap: break-word !important;
  }
  .doc-body pre code {
    background: none !important;
    border: none !important;
    color: #000 !important;
  }

  /* Tables: avoid page breaks inside, clean borders */
  .doc-body table {
    page-break-inside: avoid;
    break-inside: avoid;
    border-collapse: collapse !important;
    width: 100% !important;
  }
  .doc-body th, .doc-body td {
    border: 1px solid #999 !important;
    padding: 5pt 8pt !important;
    font-size: 10pt !important;
    color: #000 !important;
  }
  .doc-body th {
    background: #e8e8e8 !important;
    font-weight: 700 !important;
    color: #000 !important;
  }

  /* Links: show URL after the link text */
  .doc-body a[href]::after {
    content: " (" attr(href) ")";
    font-size: 9pt;
    color: #555;
    font-style: italic;
    word-break: break-all;
  }
  /* Doc-link cross-references (onclick-based, no href) -- keep clean */
  a.doc-link::after { content: none !important; }
  a.doc-link { color: #000 !important; text-decoration: underline !important; }

  /* General link styling for print */
  a { color: #000 !important; text-decoration: underline !important; }

  /* Headings: avoid orphaned headings at bottom of page */
  .doc-body h1, .doc-body h2, .doc-body h3 {
    page-break-after: avoid;
    break-after: avoid;
  }

  /* Images: avoid breaking */
  .doc-body img {
    max-width: 100% !important;
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Page margins */
  @page {
    margin: 2cm;
  }
}

/* STATS DASHBOARD */
.stats-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.75);
  z-index: 500;
  backdrop-filter: blur(4px);
  overflow-y: auto;
}
.stats-overlay.active { display: block; }
.stats-dashboard {
  max-width: 900px;
  margin: 40px auto;
  padding: 32px 40px 48px;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 12px;
  box-shadow: 0 24px 64px rgba(0, 0, 0, 0.6);
  position: relative;
}
.stats-dashboard-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 28px;
  border-bottom: 1px solid var(--border);
  padding-bottom: 16px;
}
.stats-dashboard-header h2 {
  font-size: 18px;
  font-weight: 700;
  color: var(--accent);
  letter-spacing: 0.5px;
}
.stats-close-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 18px;
  cursor: pointer;
  padding: 4px 10px;
  border-radius: 6px;
  line-height: 1;
}
.stats-close-btn:hover { color: var(--text-primary); background: var(--bg-hover); }
.stats-summary {
  display: flex;
  gap: 24px;
  margin-bottom: 32px;
  flex-wrap: wrap;
}
.stats-card {
  flex: 1;
  min-width: 140px;
  background: var(--bg-surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 16px 20px;
  text-align: center;
}
.stats-card-num {
  font-size: 32px;
  font-weight: 700;
  color: var(--accent);
  line-height: 1.2;
}
.stats-card-label {
  font-size: 11px;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-top: 4px;
}
.stats-section {
  margin-bottom: 28px;
}
.stats-section h3 {
  font-size: 13px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-secondary);
  margin-bottom: 12px;
}
.stats-bar-chart {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.stats-bar-row {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
}
.stats-bar-label {
  min-width: 160px;
  max-width: 200px;
  color: var(--text-secondary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  text-align: right;
  flex-shrink: 0;
}
.stats-bar-track {
  flex: 1;
  height: 20px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}
.stats-bar-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.4s ease;
  min-width: 2px;
}
.stats-bar-value {
  min-width: 36px;
  color: var(--text-muted);
  font-size: 11px;
  font-family: 'SF Mono', 'Fira Code', monospace;
  text-align: right;
  flex-shrink: 0;
}
.stats-table {
  width: 100%;
  border-collapse: collapse;
}
.stats-table th {
  text-align: left;
  font-size: 11px;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.3px;
  padding: 6px 10px;
  border-bottom: 1px solid var(--border);
}
.stats-table td {
  padding: 6px 10px;
  font-size: 13px;
  border-bottom: 1px solid rgba(49, 50, 68, 0.5);
  color: var(--text-secondary);
}
.stats-table tr:hover td { background: var(--bg-surface); }
.stats-table .st-docid {
  color: var(--accent);
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
}
.stats-table .st-docid:hover { text-decoration: underline; }
.stats-table .st-num {
  text-align: right;
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 12px;
  color: var(--text-muted);
}
.stats-columns {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 28px;
}
@media (max-width: 768px) {
  .stats-dashboard { margin: 16px; padding: 20px; }
  .stats-columns { grid-template-columns: 1fr; }
  .stats-bar-label { min-width: 100px; max-width: 120px; }
}

/* SYNTAX HIGHLIGHTING */
.syn-keyword { color: var(--mauve); }
.syn-string { color: var(--green); }
.syn-comment { color: var(--overlay0, #6c7086); font-style: italic; }
.syn-number { color: var(--peach); }
.syn-tag { color: var(--red); }
.syn-attr { color: var(--yellow); }

/* DOCUMENT OUTLINE MINIMAP */
.minimap-container {
  position: absolute;
  top: 0;
  right: 0;
  width: 40px;
  height: 100%;
  z-index: 20;
  pointer-events: none;
  display: none;
}
.minimap-container.visible {
  display: block;
}
.minimap-container canvas {
  display: block;
  width: 100%;
  height: 100%;
  pointer-events: auto;
  cursor: pointer;
}
.minimap-viewport {
  position: absolute;
  left: 2px;
  right: 2px;
  background: rgba(137, 180, 250, 0.10);
  border: 1px solid rgba(137, 180, 250, 0.25);
  border-radius: 2px;
  pointer-events: none;
  transition: top 0.08s ease-out, height 0.08s ease-out;
}
@media (max-width: 768px) {
  .minimap-container { display: none !important; }
}
@media print {
  .minimap-container { display: none !important; }
}


/* TOAST NOTIFICATIONS */
.toast-container {
  position: fixed;
  bottom: 40px;
  right: 20px;
  z-index: 900;
  display: flex;
  flex-direction: column-reverse;
  gap: 8px;
  pointer-events: none;
  max-width: 380px;
  width: calc(100vw - 40px);
}
.toast {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 16px;
  border-radius: 8px;
  font-size: 13px;
  line-height: 1.4;
  color: var(--text-primary);
  background: var(--bg-tertiary);
  border: 1px solid var(--border);
  box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4), 0 2px 8px rgba(0, 0, 0, 0.2);
  pointer-events: auto;
  transform: translateX(calc(100% + 20px));
  opacity: 0;
  animation: toast-slide-in 0.35s cubic-bezier(0.22, 1, 0.36, 1) forwards;
  overflow: hidden;
  word-break: break-word;
}
.toast.toast-dismissing {
  animation: toast-slide-out 0.3s cubic-bezier(0.55, 0, 1, 0.45) forwards;
}
.toast-icon {
  font-size: 16px;
  flex-shrink: 0;
  line-height: 1;
}
.toast-message {
  flex: 1;
  min-width: 0;
}
.toast.toast-success { border-left: 3px solid var(--green); }
.toast.toast-success .toast-icon { color: var(--green); }
.toast.toast-info { border-left: 3px solid var(--accent); }
.toast.toast-info .toast-icon { color: var(--accent); }
.toast.toast-warning { border-left: 3px solid var(--yellow); }
.toast.toast-warning .toast-icon { color: var(--yellow); }
.toast.toast-error { border-left: 3px solid var(--red); }
.toast.toast-error .toast-icon { color: var(--red); }

@keyframes toast-slide-in {
  from { transform: translateX(calc(100% + 20px)); opacity: 0; }
  to   { transform: translateX(0); opacity: 1; }
}
@keyframes toast-slide-out {
  from { transform: translateX(0); opacity: 1; }
  to   { transform: translateX(calc(100% + 20px)); opacity: 0; }
}

@media print {
  .toast-container { display: none !important; }
}

/* SIDEBAR RESIZE HANDLE */
.sidebar-resize-handle {
  width: 4px;
  cursor: col-resize;
  background: transparent;
  flex-shrink: 0;
  position: relative;
  z-index: 10;
  transition: background 0.15s ease;
}
.sidebar-resize-handle::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 0;
  width: 4px;
  height: 48px;
  transform: translateY(-50%);
  border-radius: 2px;
  background: transparent;
  transition: background 0.15s ease;
}
.sidebar-resize-handle:hover {
  background: var(--border);
}
.sidebar-resize-handle:hover::after {
  background: var(--text-muted);
}
body.sidebar-resizing .sidebar-resize-handle {
  background: var(--accent);
}
body.sidebar-resizing .sidebar-resize-handle::after {
  background: var(--accent);
}
body.sidebar-resizing {
  user-select: none;
  -webkit-user-select: none;
  cursor: col-resize;
}
body.sidebar-resizing .sidebar {
  transition: none;
}
body.fullscreen-mode .sidebar-resize-handle {
  display: none;
}
@media (max-width: 768px) {
  .sidebar-resize-handle {
    display: none;
  }
}

/* IMAGE ZOOM LIGHTBOX */
.doc-body img {
  cursor: zoom-in;
  transition: opacity 0.15s;
}
.doc-body img:hover {
  opacity: 0.85;
}
.lightbox-overlay {
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.25s ease, visibility 0.25s ease;
  cursor: zoom-out;
}
.lightbox-overlay.active {
  opacity: 1;
  visibility: visible;
}
.lightbox-img-wrapper {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  max-width: 95vw;
  max-height: 85vh;
  overflow: hidden;
  cursor: default;
}
.lightbox-img-wrapper img {
  max-width: 95vw;
  max-height: 85vh;
  object-fit: contain;
  transform-origin: center center;
  transform: scale(0.9);
  transition: transform 0.25s ease;
  user-select: none;
  -webkit-user-drag: none;
  pointer-events: auto;
}
.lightbox-overlay.active .lightbox-img-wrapper img {
  transform: scale(1);
}
.lightbox-img-wrapper.zoomed {
  cursor: grab;
  overflow: visible;
}
.lightbox-img-wrapper.zoomed.dragging {
  cursor: grabbing;
}
.lightbox-img-wrapper.zoomed img {
  max-width: none;
  max-height: none;
  transition: none;
}
.lightbox-close {
  position: absolute;
  top: 16px;
  right: 20px;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  color: #fff;
  font-size: 24px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.15s, transform 0.15s;
  z-index: 10001;
  line-height: 1;
}
.lightbox-close:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: scale(1.1);
}
.lightbox-caption {
  color: rgba(255, 255, 255, 0.8);
  font-size: 13px;
  text-align: center;
  padding: 10px 20px;
  max-width: 80vw;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  opacity: 0;
  transform: translateY(8px);
  transition: opacity 0.3s ease 0.1s, transform 0.3s ease 0.1s;
}
.lightbox-overlay.active .lightbox-caption {
  opacity: 1;
  transform: translateY(0);
}
.lightbox-zoom-hint {
  position: absolute;
  bottom: 60px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.45);
  font-size: 11px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease;
}
.lightbox-overlay.active .lightbox-zoom-hint {
  opacity: 1;
  transition-delay: 0.6s;
}
.lightbox-overlay.active .lightbox-zoom-hint.faded {
  opacity: 0;
  transition-delay: 0s;
}
@media print {
  .lightbox-overlay { display: none !important; }
  .doc-body img { cursor: default; }
}
</style>
<script>
// Apply saved theme immediately to avoid flash of wrong theme
(function() {
  var saved = localStorage.getItem('holm-theme');
  if (saved === 'light') {
    document.documentElement.style.background = '#ffffff';
    document.documentElement.style.colorScheme = 'light';
  }
})();

// ─── SIDEBAR RESIZE (DRAG HANDLE) ──────────────────────────────────────────
(function() {
  const SIDEBAR_WIDTH_KEY = 'holm-sidebar-width';
  const MIN_WIDTH = 180;
  const MAX_WIDTH = 500;
  const handle = document.getElementById('sidebarResizeHandle');
  const sidebar = document.getElementById('sidebar');

  // Restore saved width on load
  const savedWidth = localStorage.getItem(SIDEBAR_WIDTH_KEY);
  if (savedWidth) {
    const w = Math.min(MAX_WIDTH, Math.max(MIN_WIDTH, parseInt(savedWidth, 10)));
    document.documentElement.style.setProperty('--sidebar-width', w + 'px');
  }

  let isDragging = false;
  let startX = 0;
  let startWidth = 0;

  function getStartWidth() {
    return sidebar.getBoundingClientRect().width;
  }

  function onDragStart(clientX) {
    isDragging = true;
    startX = clientX;
    startWidth = getStartWidth();
    document.body.classList.add('sidebar-resizing');
  }

  function onDragMove(clientX) {
    if (!isDragging) return;
    const delta = clientX - startX;
    const newWidth = Math.min(MAX_WIDTH, Math.max(MIN_WIDTH, startWidth + delta));
    document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
  }

  function onDragEnd() {
    if (!isDragging) return;
    isDragging = false;
    document.body.classList.remove('sidebar-resizing');
    // Save current width
    const currentWidth = sidebar.getBoundingClientRect().width;
    localStorage.setItem(SIDEBAR_WIDTH_KEY, Math.round(currentWidth));
  }

  // Mouse events
  handle.addEventListener('mousedown', function(e) {
    e.preventDefault();
    onDragStart(e.clientX);
  });

  document.addEventListener('mousemove', function(e) {
    if (!isDragging) return;
    e.preventDefault();
    onDragMove(e.clientX);
  });

  document.addEventListener('mouseup', function(e) {
    onDragEnd();
  });

  // Touch events for tablet support
  handle.addEventListener('touchstart', function(e) {
    if (e.touches.length !== 1) return;
    e.preventDefault();
    onDragStart(e.touches[0].clientX);
  }, { passive: false });

  document.addEventListener('touchmove', function(e) {
    if (!isDragging) return;
    if (e.touches.length !== 1) return;
    e.preventDefault();
    onDragMove(e.touches[0].clientX);
  }, { passive: false });

  document.addEventListener('touchend', function(e) {
    onDragEnd();
  });

  document.addEventListener('touchcancel', function(e) {
    onDragEnd();
  });
})();

</script>
</head>
<body>

<!-- HEADER -->
<div class="header">
  <button class="hamburger" onclick="toggleSidebar()">☰</button>
  <div class="header-brand">HOLM VAULT</div>
  <div class="search-box">
    <input type="text" id="searchInput" placeholder="Search docs... (Cmd+K)" autocomplete="off">
    <div class="search-results" id="searchResults"></div>
  </div>
  <div class="header-actions">
    <button class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle light/dark theme">☾</button>
    <button class="header-btn" onclick="window.open('/graph.html','_blank')"><span class="graph-label">Graph </span>⬡</button>
    <button class="header-btn" id="statsBtn" onclick="openStatsDashboard()" title="Domain Statistics"><span class="graph-label">Stats </span>&#x25A4;</button>
    <button class="header-btn" id="backlinkToggle" onclick="toggleBacklinks()">◫</button>
    <button class="header-btn" id="fullscreenToggle" onclick="toggleFullscreen()" title="Focus mode (Cmd+Shift+F)">&#x26F6;</button>
    <button class="header-btn" onclick="showShortcutsModal()">?</button>
  </div>
</div>

<!-- TAB BAR -->
<div class="tab-bar" id="tabBar"></div>

<!-- LAYOUT -->
<div class="layout">
  <div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleSidebar()"></div>

  <!-- SIDEBAR -->
  <div class="sidebar" id="sidebar">
    <div id="sidebarContent">
      <div class="loading"><div class="spinner"></div>Loading...</div>
    </div>
    <div class="doc-count" id="docCount"></div>
  </div>

  <!-- SIDEBAR RESIZE HANDLE -->
  <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>

  <!-- MAIN CONTENT -->
  <div class="main-content" id="mainContent">
    <div class="reading-progress-bar" id="readingProgressBar"></div>
    <div class="welcome" id="welcome">
      <h1>HOLM VAULT</h1>
      <p>The holm.chat Documentation Institution — an Obsidian-like knowledge explorer backed by MongoDB.</p>
      <p style="margin-top:8px;color:var(--text-muted)">Select a document from the sidebar, use search, or press <kbd class="kbd">Cmd</kbd><kbd class="kbd">K</kbd> to begin.</p>
      <div class="stats" id="welcomeStats"></div>
    </div>
    <div class="doc-viewer" id="docViewer">
      <div class="breadcrumb" id="breadcrumb">
        <span class="bc-vault">HOLM Vault</span>
        <span class="bc-separator">&#8250;</span>
        <span class="bc-domain" id="bcDomain"></span>
        <span class="bc-separator">&#8250;</span>
        <span class="bc-current" id="bcDocId"></span>
      </div>
      <div class="doc-header">
        <h1 id="docTitle"></h1>
        <div class="doc-badges" id="docBadges"></div>
        <div class="doc-meta" id="docMeta"></div>
        <div class="doc-reading-info" id="docReadingInfo"></div>
      </div>
      <div class="doc-toolbar">
        <button class="nav-btn" id="btnNavBack" onclick="navBack()" title="Back (Alt+Left)" disabled>&#x2190;</button>
        <button class="nav-btn" id="btnNavForward" onclick="navForward()" title="Forward (Alt+Right)" disabled>&#x2192;</button>
        <div class="nav-separator"></div>
        <button class="active" onclick="setViewMode('preview')" id="btnPreview">Preview</button>
        <button onclick="setViewMode('edit')" id="btnEdit">Edit</button>
        <button onclick="setViewMode('raw')" id="btnRaw">Raw HTML</button>
        <button class="favorite-btn" id="favoriteBtn" onclick="toggleFavorite()" title="Toggle favorite">&#9734;</button>
        <button onclick="exportAsMarkdown()" title="Export as Markdown">&#x2913; Export</button>
      </div>
      <div class="doc-body" id="docBody"></div>
      <textarea class="edit-area" id="editArea"></textarea>
      <div class="save-bar" id="saveBar">
        <button class="save-btn" onclick="saveDoc()">Save</button>
        <button class="cancel-btn" onclick="setViewMode('preview')">Cancel</button>
      </div>
    </div>
    <button class="scroll-to-top" id="scrollToTop" title="Scroll to top">&#x2191;</button>
    <!-- DOCUMENT OUTLINE MINIMAP -->
    <div class="minimap-container" id="minimapContainer">
      <canvas id="minimapCanvas"></canvas>
      <div class="minimap-viewport" id="minimapViewport"></div>
    </div>
  </div>

  <!-- BACKLINKS PANEL -->
  <div class="backlinks-panel" id="backlinksPanel">
    <div class="local-graph" id="localGraphContainer">
      <canvas id="localGraphCanvas"></canvas>
    </div>
    <div id="localGraphTooltip"></div>
    <div class="backlinks-section toc-section">
      <h3>Contents</h3>
      <div id="tocList"></div>
    </div>
    <div class="backlinks-section">
      <h3>Depends On</h3>
      <div id="dependsOnList"></div>
    </div>
    <div class="backlinks-section">
      <h3>Depended Upon By</h3>
      <div id="dependedByList"></div>
    </div>
    <div class="backlinks-section">
      <h3>Tags</h3>
      <div id="tagsList"></div>
    </div>
    <div class="backlinks-section notes-section" id="notesSection">
      <h3>My Notes <span class="notes-count" id="notesCount"></span></h3>
      <textarea class="notes-textarea" id="notesTextarea" rows="3" placeholder="Add a personal note for this document..."></textarea>
      <div class="notes-actions">
        <button class="notes-clear-btn" id="notesClearBtn" onclick="clearCurrentNote()">Clear note</button>
        <span class="notes-saved-indicator" id="notesSavedIndicator">Saved</span>
      </div>
    </div>
    <div class="backlinks-section related-section" id="relatedSection">
      <h3 onclick="document.getElementById('relatedSection').classList.toggle('collapsed')"><span class="related-chevron">&#9660;</span> <span id="relatedHeader">Related</span></h3>
      <div class="related-list" id="relatedList"></div>
    </div>
  </div>
</div>

<!-- DOC LINK PREVIEW TOOLTIP -->
<div class="doc-link-tooltip" id="docLinkTooltip">
  <div class="doc-link-tooltip-id" id="tooltipDocId"></div>
  <div class="doc-link-tooltip-title" id="tooltipTitle"></div>
  <div class="doc-link-tooltip-domain" id="tooltipDomain"></div>
  <div class="doc-link-tooltip-excerpt" id="tooltipExcerpt"></div>
  <div class="doc-link-tooltip-tags" id="tooltipTags"></div>
</div>

<!-- FULLSCREEN EXIT HINT -->
<div class="fullscreen-exit-hint" id="fullscreenExitHint" onclick="toggleFullscreen()">
  Exit focus mode <span class="kbd">Esc</span>
</div>

<!-- TOAST NOTIFICATIONS -->
<div class="toast-container" id="toastContainer"></div>

<!-- STATUS BAR -->
<div class="status-bar">
  <span id="statusDocs">0 docs</span>
  <span id="statusDomain"></span>
  <span id="statusUpdated"></span>
</div>

<!-- QUICK OPEN -->
<div class="quick-open-overlay" id="quickOpen" style="display:none">
  <div class="quick-open-panel">
    <input type="text" id="quickOpenInput" placeholder="Type to search docs..." autocomplete="off" spellcheck="false">
    <div class="quick-open-results" id="quickOpenResults"></div>
    <div class="quick-open-hint">
      <span><kbd>↑</kbd><kbd>↓</kbd> navigate</span>
      <span><kbd>↵</kbd> open</span>
      <span><kbd>Esc</kbd> close</span>
      <span><kbd>⌘K</kbd> toggle</span>
    </div>
  </div>
</div>

<!-- KEYBOARD SHORTCUTS MODAL -->
<div class="shortcuts-modal-overlay" id="shortcutsModal" onclick="closeShortcutsModal(event)">
  <div class="shortcuts-modal">
    <div class="shortcuts-modal-header">
      <h2>Keyboard Shortcuts</h2>
      <button class="shortcuts-modal-close" onclick="hideShortcutsModal()">&times;</button>
    </div>
    <div class="shortcuts-modal-body">
      <div class="shortcuts-group">
        <div class="shortcuts-group-label">Navigation</div>
        <table class="shortcuts-table">
          <tr><td>Quick open</td><td><span class="kbd">Cmd</span><span class="kbd">K</span></td></tr>
          <tr><td>Graph view</td><td><span class="kbd">Cmd</span><span class="kbd">G</span></td></tr>
          <tr><td>Previous document</td><td><span class="kbd">Alt</span><span class="kbd">↑</span></td></tr>
          <tr><td>Next document</td><td><span class="kbd">Alt</span><span class="kbd">↓</span></td></tr>
          <tr><td>History back</td><td><span class="kbd">Alt</span><span class="kbd">←</span></td></tr>
          <tr><td>History forward</td><td><span class="kbd">Alt</span><span class="kbd">→</span></td></tr>
        </table>
      </div>
      <div class="shortcuts-group">
        <div class="shortcuts-group-label">View</div>
        <table class="shortcuts-table">
          <tr><td>Toggle sidebar</td><td><span class="kbd">Cmd</span><span class="kbd">\</span></td></tr>
          <tr><td>Toggle backlinks</td><td><span class="kbd">Cmd</span><span class="kbd">B</span></td></tr>
          <tr><td>Focus mode</td><td><span class="kbd">Cmd</span><span class="kbd">Shift</span><span class="kbd">F</span></td></tr>
        </table>
      </div>
      <div class="shortcuts-group">
        <div class="shortcuts-group-label">Editing</div>
        <table class="shortcuts-table">
          <tr><td>Toggle edit mode</td><td><span class="kbd">Cmd</span><span class="kbd">E</span></td></tr>
          <tr><td>Save</td><td><span class="kbd">Cmd</span><span class="kbd">S</span></td></tr>
        </table>
      </div>
      <div class="shortcuts-group">
        <div class="shortcuts-group-label">General</div>
        <table class="shortcuts-table">
          <tr><td>Show shortcuts</td><td><span class="kbd">?</span></td></tr>
          <tr><td>Close / cancel</td><td><span class="kbd">Esc</span></td></tr>
        </table>
      </div>
    </div>
  </div>
</div>

<script>
// ─── STATE ──────────────────────────────────────────────────────────────────
let allDocs = [];
let currentDoc = null;
let viewMode = 'preview';
let backlinksPanelOpen = window.innerWidth > 768;
let docsById = {};
let activeTagFilter = null;
let openTabs = [];
let navHistory = [];
let navHistoryPos = -1;
let navIsTraversing = false;
const NAV_HISTORY_MAX = 50;

const DOMAIN_COLORS = {
  '1': '#89b4fa', '2': '#a6e3a1', '3': '#f38ba8', '4': '#fab387',
  '5': '#cba6f7', '6': '#94e2d5', '7': '#f9e2af', '8': '#f5c2e7',
  '9': '#89dceb', '10': '#b4befe', '11': '#74c7ec', '12': '#f38ba8',
  '13': '#a6e3a1', '14': '#fab387', '15': '#cba6f7', '16': '#94e2d5',
  '17': '#f9e2af', '18': '#f5c2e7', '19': '#89dceb', '20': '#b4befe',
  'META': '#6c7086', 'FW': '#585b70', 'HIC': '#74c7ec'
};

// ─── TOAST NOTIFICATIONS ────────────────────────────────────────────────────
const TOAST_ICONS = {
  success: '\u2714',
  info: '\u24D8',
  warning: '\u26A0',
  error: '\u2716'
};
const TOAST_MAX = 4;

function showToast(message, type) {
  type = type || 'info';
  const container = document.getElementById('toastContainer');
  if (!container) return;

  const toasts = container.querySelectorAll('.toast:not(.toast-dismissing)');
  if (toasts.length >= TOAST_MAX) {
    dismissToast(toasts[toasts.length - 1]);
  }

  const el = document.createElement('div');
  el.className = 'toast toast-' + type;
  el.innerHTML =
    '<span class="toast-icon">' + (TOAST_ICONS[type] || '') + '</span>' +
    '<span class="toast-message">' + escHtml(message) + '</span>';
  container.appendChild(el);

  const duration = (type === 'warning' || type === 'error') ? 5000 : 3000;
  el._toastTimer = setTimeout(function() { dismissToast(el); }, duration);
}

function dismissToast(el) {
  if (!el || el.classList.contains('toast-dismissing')) return;
  clearTimeout(el._toastTimer);
  el.classList.add('toast-dismissing');
  el.addEventListener('animationend', function() { el.remove(); }, { once: true });
}

// ─── THEME ──────────────────────────────────────────────────────────────────────
function applyTheme(theme) {
  const btn = document.getElementById('themeToggle');
  if (theme === 'light') {
    document.body.classList.add('light-theme');
    if (btn) btn.textContent = '\u2600';
    document.documentElement.style.background = '#ffffff';
    document.documentElement.style.colorScheme = 'light';
  } else {
    document.body.classList.remove('light-theme');
    if (btn) btn.textContent = '\u263e';
    document.documentElement.style.background = '#1e1e2e';
    document.documentElement.style.colorScheme = 'dark';
  }
}

function toggleTheme() {
  const isLight = document.body.classList.contains('light-theme');
  const newTheme = isLight ? 'dark' : 'light';
  localStorage.setItem('holm-theme', newTheme);
  applyTheme(newTheme);
}

// Apply theme on DOM ready (before full render)
(function() {
  var saved = localStorage.getItem('holm-theme');
  if (saved === 'light') {
    document.body.classList.add('light-theme');
  }
  // Update button text once DOM is available
  var btn = document.getElementById('themeToggle');
  if (btn) btn.textContent = saved === 'light' ? '\u2600' : '\u263e';
})();

// ─── INIT ───────────────────────────────────────────────────────────────────
document.addEventListener('DOMContentLoaded', init);

async function init() {
  try {
    const res = await fetch('/api/docs');
    allDocs = await res.json();
    docsById = {};
    allDocs.forEach(d => docsById[d.docId] = d);
    renderSidebar();
    renderWelcomeStats();
    if (backlinksPanelOpen) document.getElementById('backlinksPanel').classList.add('active');
    if (window.location.hash) {
      const id = window.location.hash.slice(1).toUpperCase();
      if (docsById[id]) openDoc(id);
    }
  } catch (err) {
    document.getElementById('sidebarContent').innerHTML =
      '<div style="padding:16px;color:var(--red)">Failed to load docs. Is the API running?</div>';
    showToast('Failed to load docs. Is the API running?', 'error');
  }
}

function renderWelcomeStats() {
  const domains = new Set(allDocs.map(d => d.domain));
  document.getElementById('welcomeStats').innerHTML = `
    <div class="stat"><div class="stat-num">${allDocs.length}</div><div class="stat-label">Documents</div></div>
    <div class="stat"><div class="stat-num">${domains.size}</div><div class="stat-label">Domains</div></div>
  `;
  document.getElementById('statusDocs').textContent = `${allDocs.length} docs`;
}

// ─── SIDEBAR ────────────────────────────────────────────────────────────────
function renderSidebar() {
  const sourceDocs = activeTagFilter
    ? allDocs.filter(doc => doc.tags && doc.tags.includes(activeTagFilter))
    : allDocs;

  const groups = {};
  sourceDocs.forEach(doc => {
    const key = doc.domain || 'Other';
    if (!groups[key]) groups[key] = { name: doc.domainName || key, docs: [] };
    groups[key].docs.push(doc);
  });

  const sortedKeys = Object.keys(groups).sort((a, b) => {
    const na = parseInt(a), nb = parseInt(b);
    if (!isNaN(na) && !isNaN(nb)) return na - nb;
    if (!isNaN(na)) return -1;
    if (!isNaN(nb)) return 1;
    return a.localeCompare(b);
  });

  let filterBar = '';
  if (activeTagFilter) {
    filterBar = `<div class="sidebar-filter">Filtered: <span class="filter-tag active">#${escHtml(activeTagFilter)}</span> <span class="clear-filter" onclick="clearTagFilter()">✕</span></div>`;
  }

  let html = '';
  for (const key of sortedKeys) {
    const g = groups[key];
    const color = DOMAIN_COLORS[key] || 'var(--text-muted)';
    html += `<div class="sidebar-section" data-domain="${key}">
      <div class="sidebar-section-header" onclick="toggleSection(this)" style="color:${color}">
        <span class="chevron">&#9660;</span>D${key} ${g.name} <span style="margin-left:auto;font-size:10px;opacity:0.6">${g.docs.length}</span>
      </div>
      <div class="sidebar-items-wrap"><div class="sidebar-items">`;
    for (const doc of g.docs) {
      const _noteIcon = getHolmNotes()[doc.docId] ? '<span class="note-icon" title="Has personal note">&#9998;</span>' : '';
      html += `<div class="sidebar-item" data-id="${doc.docId}" onclick="openDoc('${doc.docId}')">
        <span class="doc-id">${doc.docId}</span>
        <span class="doc-title">${escHtml(doc.title)}</span>
        ${_noteIcon}
      </div>`;
    }
    html += '</div></div></div>';
  }

  if (activeTagFilter && sourceDocs.length === 0) {
    html = `<div style="padding:16px;color:var(--text-muted);font-size:13px">No documents tagged <strong>#${escHtml(activeTagFilter)}</strong></div>`;
  }

  document.getElementById('sidebarContent').innerHTML = buildFavoritesHtml() + renderRecentSection() + filterBar + html;
  document.getElementById('docCount').textContent = activeTagFilter
    ? `${sourceDocs.length} of ${allDocs.length} documents`
    : `${allDocs.length} documents`;

  // Restore collapsed state from localStorage
  applySidebarState();
}

// ─── SIDEBAR COLLAPSE STATE PERSISTENCE ─────────────────────────────────────
const SIDEBAR_STATE_KEY = 'holm-sidebar-state';

function getSidebarState() {
  try {
    const raw = localStorage.getItem(SIDEBAR_STATE_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch (e) { return {}; }
}

function saveSidebarState(state) {
  try { localStorage.setItem(SIDEBAR_STATE_KEY, JSON.stringify(state)); } catch (e) {}
}

function applySidebarState() {
  const state = getSidebarState();
  // Determine the active doc's domain so we can force it open
  const activeDomain = currentDoc ? currentDoc.domain : null;

  document.querySelectorAll('.sidebar-section[data-domain]').forEach(section => {
    const domain = section.dataset.domain;
    const wrap = section.querySelector('.sidebar-items-wrap');
    const items = section.querySelector('.sidebar-items');
    if (!wrap || !items) return;

    // If this domain has the active doc, always expand it
    const shouldCollapse = (domain === activeDomain) ? false : (state[domain] === true);

    if (shouldCollapse) {
      section.classList.add('collapsed');
      wrap.style.height = '0px';
    } else {
      section.classList.remove('collapsed');
      wrap.style.height = items.scrollHeight + 'px';
      // After transition ends, set to auto so it can resize naturally
      requestAnimationFrame(() => {
        requestAnimationFrame(() => { wrap.style.height = 'auto'; });
      });
    }
  });
}

function toggleSection(headerEl) {
  const section = headerEl.parentElement;
  const domain = section.dataset.domain;
  const wrap = section.querySelector('.sidebar-items-wrap');
  const items = section.querySelector('.sidebar-items');
  if (!wrap || !items) return;

  const isCollapsed = section.classList.contains('collapsed');

  if (isCollapsed) {
    // Expand: set height from 0 to scrollHeight, then auto
    section.classList.remove('collapsed');
    wrap.style.height = '0px';
    // Force reflow
    void wrap.offsetHeight;
    wrap.style.height = items.scrollHeight + 'px';
    const onEnd = () => {
      wrap.style.height = 'auto';
      wrap.removeEventListener('transitionend', onEnd);
    };
    wrap.addEventListener('transitionend', onEnd);
  } else {
    // Collapse: set explicit height first, then transition to 0
    wrap.style.height = items.scrollHeight + 'px';
    // Force reflow
    void wrap.offsetHeight;
    section.classList.add('collapsed');
    wrap.style.height = '0px';
  }

  // Persist state
  const state = getSidebarState();
  state[domain] = !isCollapsed; // after toggle: collapsed = !wasCollapsed
  saveSidebarState(state);
}

// ─── TAG FILTER ─────────────────────────────────────────────────────────────
function filterByTag(tag) {
  activeTagFilter = tag;
  renderSidebar();
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) { activeItem.classList.add('active'); activeItem.scrollIntoView({ block: 'nearest' }); }
  }
}

function clearTagFilter() {
  activeTagFilter = null;
  renderSidebar();
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) { activeItem.classList.add('active'); activeItem.scrollIntoView({ block: 'nearest' }); }
  }
}

function filterByDomain(domainKey) {
  // Clear any active tag filter first
  activeTagFilter = null;
  renderSidebar();

  // Collapse all sections, then expand only the matching domain
  const filterState = {};
  document.querySelectorAll('.sidebar-section[data-domain]').forEach(section => {
    const d = section.dataset.domain;
    if (d === domainKey) {
      filterState[d] = false;
    } else {
      filterState[d] = true;
    }
  });
  saveSidebarState(filterState);
  applySidebarState();
  const targetSection = document.querySelector(`.sidebar-section[data-domain="${domainKey}"]`);
  if (targetSection) targetSection.scrollIntoView({ block: 'start', behavior: 'smooth' });

  // Re-highlight active doc if any
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) { activeItem.classList.add('active'); activeItem.scrollIntoView({ block: 'nearest' }); }
  }
}

// ─── TABS + DOC OPEN ────────────────────────────────────────────────────────
let _docHasLoaded = false; // tracks whether a doc has been rendered at least once

async function openDoc(id, skipHistory) {
  if (!openTabs.find(t => t.docId === id)) {
    const meta = docsById[id];
    openTabs.push({ docId: id, title: meta ? meta.title : id });
  }
  if (!skipHistory && !navIsTraversing) {
    // Truncate any forward history
    navHistory = navHistory.slice(0, navHistoryPos + 1);
    navHistory.push(id);
    // Cap at max
    if (navHistory.length > NAV_HISTORY_MAX) {
      navHistory = navHistory.slice(navHistory.length - NAV_HISTORY_MAX);
    }
    navHistoryPos = navHistory.length - 1;
    updateNavButtons();
  }
  await switchTab(id);
}

async function switchTab(docId) {
  // If the requested doc is already displayed, just highlight its tab — no animation
  if (currentDoc && currentDoc.docId === docId) {
    renderTabs();
    return;
  }

  try {
    const res = await fetch(`/api/docs/${docId}`);
    if (!res.ok) throw new Error('Not found');
    const newDoc = await res.json();

    const viewer = document.getElementById('docViewer');
    // Only animate on subsequent switches, not the very first doc load
    const shouldAnimate = _docHasLoaded && viewer.classList.contains('active');

    const applyContent = () => {
      currentDoc = newDoc;

      const tab = openTabs.find(t => t.docId === docId);
      if (tab && tab.title === docId) tab.title = currentDoc.title;
      renderTabs();

      // Track in recently viewed
      addToRecent(currentDoc.docId, currentDoc.title);
      renderSidebar();

      window.location.hash = docId;

      document.querySelectorAll('.sidebar-item').forEach(el => el.classList.remove('active'));
      const activeItem = document.querySelector(`.sidebar-item[data-id="${docId}"]`);
      if (activeItem) {
        activeItem.classList.add('active');
        // Ensure the active doc's domain section is expanded
        const parentSection = activeItem.closest('.sidebar-section');
        if (parentSection && parentSection.classList.contains('collapsed')) {
          const header = parentSection.querySelector('.sidebar-section-header');
          if (header) toggleSection(header);
        }
        activeItem.scrollIntoView({ block: 'nearest' });
      }

      document.getElementById('welcome').style.display = 'none';
      viewer.classList.add('active');

      document.getElementById('docTitle').textContent = `${currentDoc.docId} — ${currentDoc.title}`;
      document.getElementById('docMeta').innerHTML = `
        <span class="badge" style="color:${DOMAIN_COLORS[currentDoc.domain] || 'var(--text-muted)'}">Domain ${currentDoc.domain}: ${escHtml(currentDoc.domainName)}</span>
      `;
      renderDocBadges();

      // Breadcrumb
      const bcDomain = document.getElementById('bcDomain');
      const domainLabel = currentDoc.domainName ? `D${currentDoc.domain} ${currentDoc.domainName}` : `Domain ${currentDoc.domain}`;
      bcDomain.textContent = domainLabel;
      bcDomain.style.color = DOMAIN_COLORS[currentDoc.domain] || 'var(--text-secondary)';
      bcDomain.onclick = function() { filterByDomain(currentDoc.domain); };
      document.getElementById('bcDocId').textContent = currentDoc.docId;
      document.getElementById('breadcrumb').classList.add('active');

      updateReadingInfo();
      updateFavoriteBtn();
      setViewMode('preview');
      renderBacklinks();

      document.getElementById('statusDomain').textContent = `Domain ${currentDoc.domain}`;
      document.getElementById('statusUpdated').textContent = `Updated: ${new Date(currentDoc.updatedAt).toLocaleDateString()}`;

      if (window.innerWidth <= 768) {
        document.getElementById('sidebar').classList.remove('open');
        document.getElementById('sidebarOverlay').classList.remove('active');
      }

      _docHasLoaded = true;
    };

    if (shouldAnimate) {
      // Fade out (150ms), swap content, then fade in (150ms)
      viewer.classList.add('doc-transitioning');
      setTimeout(() => {
        applyContent();
        // Force reflow so the browser registers opacity:0 before removing the class
        void viewer.offsetHeight;
        viewer.classList.remove('doc-transitioning');
      }, 150);
    } else {
      // First load — no animation, just show content immediately
      applyContent();
    }

  } catch (err) {
    console.error('Failed to open doc:', err);
    showToast('Failed to open document: ' + err.message, 'error');
  }
}

function renderTabs() {
  const bar = document.getElementById('tabBar');
  if (openTabs.length === 0) { bar.innerHTML = ''; return; }
  bar.innerHTML = openTabs.map(tab => {
    const isActive = currentDoc && currentDoc.docId === tab.docId;
    return `<div class="tab${isActive ? ' active' : ''}" data-tab-id="${escHtml(tab.docId)}"
               draggable="true"
               ondragstart="handleTabDragStart(event)"
               ondragover="handleTabDragOver(event)"
               ondragenter="handleTabDragEnter(event)"
               ondragleave="handleTabDragLeave(event)"
               ondrop="handleTabDrop(event)"
               ondragend="handleTabDragEnd(event)"
               onclick="switchTab('${escHtml(tab.docId)}')"
               onmousedown="handleTabMousedown(event, '${escHtml(tab.docId)}')"
               title="${escHtml(tab.docId)}: ${escHtml(tab.title)}">
      <span class="tab-id">${escHtml(tab.docId)}</span>
      <span class="tab-title">${escHtml(tab.title)}</span>
      <span class="tab-close" onclick="event.stopPropagation(); closeTab('${escHtml(tab.docId)}')">×</span>
    </div>`;
  }).join('');
  const activeTab = bar.querySelector('.tab.active');
  if (activeTab) activeTab.scrollIntoView({ block: 'nearest', inline: 'nearest' });
}

function closeTab(docId) {
  const idx = openTabs.findIndex(t => t.docId === docId);
  if (idx === -1) return;
  openTabs.splice(idx, 1);
  if (currentDoc && currentDoc.docId === docId) {
    if (openTabs.length === 0) {
      currentDoc = null;
      document.getElementById('docViewer').classList.remove('active');
      document.getElementById('welcome').style.display = '';
      document.querySelectorAll('.sidebar-item').forEach(el => el.classList.remove('active'));
      window.location.hash = '';
      renderTabs();
      if (typeof window.hideMinimap === 'function') window.hideMinimap();
    } else {
      const nextTab = openTabs[Math.min(idx, openTabs.length - 1)];
      switchTab(nextTab.docId);
    }
  } else {
    renderTabs();
  }
}

function handleTabMousedown(event, docId) {
  if (event.button === 1) { event.preventDefault(); closeTab(docId); }
}

// ─── TAB DRAG AND DROP ────────────────────────────────────────────────────
let draggedTabId = null;

function handleTabDragStart(event) {
  const tabEl = event.target.closest('.tab');
  if (!tabEl) return;
  draggedTabId = tabEl.dataset.tabId;
  tabEl.classList.add('dragging');
  event.dataTransfer.effectAllowed = 'move';
  event.dataTransfer.setData('text/plain', draggedTabId);
}

function handleTabDragOver(event) {
  event.preventDefault();
  event.dataTransfer.dropEffect = 'move';
}

function handleTabDragEnter(event) {
  event.preventDefault();
  const tabEl = event.target.closest('.tab');
  if (!tabEl || tabEl.dataset.tabId === draggedTabId) return;
  tabEl.classList.add('drag-over');
}

function handleTabDragLeave(event) {
  const tabEl = event.target.closest('.tab');
  if (!tabEl) return;
  // Only remove if we actually left the tab element (not just moved to a child)
  const related = event.relatedTarget;
  if (related && tabEl.contains(related)) return;
  tabEl.classList.remove('drag-over');
}

function handleTabDrop(event) {
  event.preventDefault();
  const targetTabEl = event.target.closest('.tab');
  if (!targetTabEl) return;
  const targetTabId = targetTabEl.dataset.tabId;
  targetTabEl.classList.remove('drag-over');

  // Prevent drop on self
  if (!draggedTabId || draggedTabId === targetTabId) return;

  const fromIdx = openTabs.findIndex(t => t.docId === draggedTabId);
  const toIdx = openTabs.findIndex(t => t.docId === targetTabId);
  if (fromIdx === -1 || toIdx === -1) return;

  // Remove the dragged tab and insert at the new position
  const [movedTab] = openTabs.splice(fromIdx, 1);
  openTabs.splice(toIdx, 0, movedTab);

  renderTabs();
}

function handleTabDragEnd(event) {
  draggedTabId = null;
  // Clean up all drag classes
  document.querySelectorAll('.tab.dragging, .tab.drag-over').forEach(el => {
    el.classList.remove('dragging', 'drag-over');
  });
}

// ─── VIEW MODE ──────────────────────────────────────────────────────────────
function setViewMode(mode) {
  viewMode = mode;
  const body = document.getElementById('docBody');
  const edit = document.getElementById('editArea');
  const saveBar = document.getElementById('saveBar');
  document.querySelectorAll('.doc-toolbar button').forEach(b => b.classList.remove('active'));

  if (mode === 'preview') {
    body.style.display = 'block';
    body.innerHTML = linkifyDocIds(currentDoc.content);
    addCopyButtons();
    highlightCodeBlocks();
    edit.classList.remove('active');
    saveBar.classList.remove('active');
    document.getElementById('btnPreview').classList.add('active');
  } else if (mode === 'edit') {
    body.style.display = 'none';
    edit.value = currentDoc.content;
    edit.classList.add('active');
    saveBar.classList.add('active');
    document.getElementById('btnEdit').classList.add('active');
  } else if (mode === 'raw') {
    body.style.display = 'block';
    body.innerHTML = `<pre><code>${escHtml(currentDoc.content)}</code></pre>`;
    addCopyButtons();
    highlightCodeBlocks();
    edit.classList.remove('active');
    saveBar.classList.remove('active');
    document.getElementById('btnRaw').classList.add('active');
  }

  // Update minimap after content change
  if (mode === 'preview' || mode === 'raw') {
    if (typeof window.updateMinimap === 'function') window.updateMinimap();
  } else {
    if (typeof window.hideMinimap === 'function') window.hideMinimap();
  }
}

async function saveDoc() {
  if (!currentDoc) return;
  const content = document.getElementById('editArea').value;
  try {
    const res = await fetch(`/api/docs/${currentDoc.docId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content })
    });
    if (!res.ok) throw new Error('Save failed');
    currentDoc.content = content;
    setViewMode('preview');
    showToast('Document saved successfully', 'success');
  } catch (err) {
    showToast('Failed to save: ' + err.message, 'error');
  }
}

// ─── EXPORT AS MARKDOWN ─────────────────────────────────────────────────────
function htmlToMarkdown(html) {
  let md = html;

  // Fenced code blocks: <pre><code>...</code></pre>
  md = md.replace(/<pre[^>]*>\s*<code[^>]*>([\s\S]*?)<\/code>\s*<\/pre>/gi, function(_, code) {
    const decoded = code.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&').replace(/&quot;/g, '"').replace(/&#39;/g, "'");
    return '\n```\n' + decoded.trim() + '\n```\n';
  });

  // Tables
  md = md.replace(/<table[^>]*>([\s\S]*?)<\/table>/gi, function(_, tableHtml) {
    const rows = [];
    const rowRegex = /<tr[^>]*>([\s\S]*?)<\/tr>/gi;
    let rowMatch;
    while ((rowMatch = rowRegex.exec(tableHtml)) !== null) {
      const cells = [];
      const cellRegex = /<(?:td|th)[^>]*>([\s\S]*?)<\/(?:td|th)>/gi;
      let cellMatch;
      while ((cellMatch = cellRegex.exec(rowMatch[1])) !== null) {
        cells.push(cellMatch[1].replace(/<[^>]+>/g, '').trim());
      }
      rows.push(cells);
    }
    if (rows.length === 0) return '';
    let table = '';
    table += '| ' + rows[0].join(' | ') + ' |\n';
    table += '| ' + rows[0].map(() => '---').join(' | ') + ' |\n';
    for (let i = 1; i < rows.length; i++) {
      table += '| ' + rows[i].join(' | ') + ' |\n';
    }
    return '\n' + table + '\n';
  });

  // Blockquotes
  md = md.replace(/<blockquote[^>]*>([\s\S]*?)<\/blockquote>/gi, function(_, content) {
    const text = content.replace(/<[^>]+>/g, '').trim();
    return '\n' + text.split('\n').map(line => '> ' + line.trim()).join('\n') + '\n';
  });

  // Headings
  md = md.replace(/<h1[^>]*>([\s\S]*?)<\/h1>/gi, function(_, t) { return '\n# ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h2[^>]*>([\s\S]*?)<\/h2>/gi, function(_, t) { return '\n## ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h3[^>]*>([\s\S]*?)<\/h3>/gi, function(_, t) { return '\n### ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h4[^>]*>([\s\S]*?)<\/h4>/gi, function(_, t) { return '\n#### ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h5[^>]*>([\s\S]*?)<\/h5>/gi, function(_, t) { return '\n##### ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });
  md = md.replace(/<h6[^>]*>([\s\S]*?)<\/h6>/gi, function(_, t) { return '\n###### ' + t.replace(/<[^>]+>/g, '').trim() + '\n'; });

  // Unordered lists
  md = md.replace(/<ul[^>]*>([\s\S]*?)<\/ul>/gi, function(_, listHtml) {
    let result = '\n';
    const liRegex = /<li[^>]*>([\s\S]*?)<\/li>/gi;
    let liMatch;
    while ((liMatch = liRegex.exec(listHtml)) !== null) {
      result += '- ' + liMatch[1].replace(/<[^>]+>/g, '').trim() + '\n';
    }
    return result + '\n';
  });

  // Ordered lists
  md = md.replace(/<ol[^>]*>([\s\S]*?)<\/ol>/gi, function(_, listHtml) {
    let result = '\n';
    let num = 1;
    const liRegex = /<li[^>]*>([\s\S]*?)<\/li>/gi;
    let liMatch;
    while ((liMatch = liRegex.exec(listHtml)) !== null) {
      result += num + '. ' + liMatch[1].replace(/<[^>]+>/g, '').trim() + '\n';
      num++;
    }
    return result + '\n';
  });

  // Links: <a href="...">text</a>
  md = md.replace(/<a[^>]+href="([^"]*)"[^>]*>([\s\S]*?)<\/a>/gi, function(_, href, text) {
    const linkText = text.replace(/<[^>]+>/g, '').trim();
    return '[' + linkText + '](' + href + ')';
  });

  // Bold
  md = md.replace(/<(?:strong|b)[^>]*>([\s\S]*?)<\/(?:strong|b)>/gi, function(_, t) { return '**' + t.replace(/<[^>]+>/g, '').trim() + '**'; });

  // Italic
  md = md.replace(/<(?:em|i)[^>]*>([\s\S]*?)<\/(?:em|i)>/gi, function(_, t) { return '*' + t.replace(/<[^>]+>/g, '').trim() + '*'; });

  // Paragraphs
  md = md.replace(/<p[^>]*>([\s\S]*?)<\/p>/gi, function(_, t) { return '\n' + t.trim() + '\n'; });

  // Line breaks
  md = md.replace(/<br\s*\/?>/gi, '\n');

  // Horizontal rules
  md = md.replace(/<hr\s*\/?>/gi, '\n---\n');

  // Strip all remaining HTML tags
  md = md.replace(/<[^>]+>/g, '');

  // Decode common HTML entities
  md = md.replace(/&amp;/g, '&');
  md = md.replace(/&lt;/g, '<');
  md = md.replace(/&gt;/g, '>');
  md = md.replace(/&quot;/g, '"');
  md = md.replace(/&#39;/g, "'");
  md = md.replace(/&nbsp;/g, ' ');

  // Clean up excessive blank lines (3+ newlines -> 2)
  md = md.replace(/\n{3,}/g, '\n\n');

  return md.trim() + '\n';
}

function exportAsMarkdown() {
  if (!currentDoc) return;

  const doc = currentDoc;

  // Build YAML front matter
  let frontMatter = '---\n';
  frontMatter += 'docId: "' + (doc.docId || '') + '"\n';
  frontMatter += 'title: "' + (doc.title || '').replace(/"/g, '\\"') + '"\n';
  frontMatter += 'domain: ' + (doc.domain != null ? doc.domain : '') + '\n';
  frontMatter += 'tags: [' + (Array.isArray(doc.tags) ? doc.tags.map(function(t) { return '"' + t + '"'; }).join(', ') : '') + ']\n';
  frontMatter += 'version: "' + (doc.version || '') + '"\n';
  frontMatter += 'status: "' + (doc.status || '') + '"\n';
  frontMatter += 'date: "' + (doc.date || '') + '"\n';
  frontMatter += '---\n\n';

  // Convert HTML content to Markdown
  const markdownBody = htmlToMarkdown(doc.content || '');

  const fullMarkdown = frontMatter + markdownBody;

  // Download via Blob + object URL + programmatic anchor click
  const blob = new Blob([fullMarkdown], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (doc.docId || 'export') + '.md';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ─── LINKIFY DOC IDS ────────────────────────────────────────────────────────
function linkifyDocIds(html) {
  const DOC_ID_RE = /\b([A-Z]{1,10}-\d{1,4}|D\d{1,2}-\d{1,4}|DOMAIN-\d{1,2}|APPENDIX-[A-Z](?:-\d)?)\b/g;
  const ANCHOR_RE = /(<a[\s\S]*?<\/a>)/gi;
  const parts = html.split(ANCHOR_RE);
  return parts.map((part, i) => {
    if (i % 2 === 1) return part;
    const TAG_RE = /(<[^>]+>)/g;
    const subParts = part.split(TAG_RE);
    return subParts.map((sub, j) => {
      if (j % 2 === 1) return sub;
      return sub.replace(DOC_ID_RE, (match) =>
        `<a class="doc-link" onclick="openDoc('${match}')" title="Open ${match}">${match}</a>`
      );
    }).join('');
  }).join('');
}

// ─── BACKLINKS + TOC + LOCAL GRAPH ──────────────────────────────────────────
function renderBacklinks() {
  if (!currentDoc) return;

  renderLocalGraph();
  renderTOC();

  // Depends On
  const depOn = document.getElementById('dependsOnList');
  if (currentDoc.dependsOn && currentDoc.dependsOn.length > 0) {
    depOn.innerHTML = currentDoc.dependsOn.map(id => {
      const ref = docsById[id];
      const title = ref ? ref.title : id;
      return `<a class="backlink-item" onclick="openDoc('${id}')">${id}: ${escHtml(title)}</a>`;
    }).join('');
  } else {
    depOn.innerHTML = '<span style="color:var(--text-muted);font-size:12px">None</span>';
  }

  // Depended Upon By
  const depBy = document.getElementById('dependedByList');
  if (currentDoc.dependedBy && currentDoc.dependedBy.length > 0) {
    depBy.innerHTML = currentDoc.dependedBy.map(id => {
      const ref = docsById[id];
      const title = ref ? ref.title : id;
      return `<a class="backlink-item" onclick="openDoc('${id}')">${id}: ${escHtml(title)}</a>`;
    }).join('');
  } else {
    depBy.innerHTML = '<span style="color:var(--text-muted);font-size:12px">None</span>';
  }

  // Tags (clickable for filtering)
  const tags = document.getElementById('tagsList');
  if (currentDoc.tags && currentDoc.tags.length > 0) {
    tags.innerHTML = currentDoc.tags.map(t =>
      `<span class="tag-item" onclick="filterByTag('${escHtml(t)}')">#${escHtml(t)}</span>`
    ).join('');
  } else {
    tags.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No tags</span>';
  }

  // Related Documents
  renderRelatedDocs();

  // Personal Notes
  renderNotes();
}

function renderRelatedDocs() {
  var header = document.getElementById('relatedHeader');
  var list = document.getElementById('relatedList');
  if (!currentDoc || !currentDoc.tags || currentDoc.tags.length === 0) {
    header.textContent = 'Related (0)';
    list.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No related documents</span>';
    return;
  }

  var excludeIds = new Set();
  excludeIds.add(currentDoc.docId);
  if (currentDoc.dependsOn) currentDoc.dependsOn.forEach(function(id) { excludeIds.add(id); });
  if (currentDoc.dependedBy) currentDoc.dependedBy.forEach(function(id) { excludeIds.add(id); });

  var currentTags = new Set(currentDoc.tags);

  var scored = [];
  allDocs.forEach(function(doc) {
    if (excludeIds.has(doc.docId)) return;
    if (!doc.tags || doc.tags.length === 0) return;
    var shared = 0;
    doc.tags.forEach(function(t) { if (currentTags.has(t)) shared++; });
    if (shared > 0) scored.push({ doc: doc, shared: shared });
  });

  scored.sort(function(a, b) { return b.shared - a.shared || a.doc.docId.localeCompare(b.doc.docId); });

  var top = scored.slice(0, 5);

  header.textContent = 'Related (' + top.length + ')';

  if (top.length === 0) {
    list.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No related documents</span>';
    return;
  }

  list.innerHTML = top.map(function(item) {
    var doc = item.doc, shared = item.shared;
    return '<div class="related-item">' +
      '<a class="related-item-link" onclick="openDoc(\'' + doc.docId + '\')">' + doc.docId + '</a>' +
      '<div class="related-item-title">' + escHtml(doc.title) + '</div>' +
      '<div class="related-item-score">' + shared + ' tag' + (shared !== 1 ? 's' : '') + ' in common</div>' +
    '</div>';
  }).join('');
}

// ─── PERSONAL ANNOTATIONS/NOTES ──────────────────────────────────────────────
const HOLM_NOTES_KEY = 'holm-notes';
let _noteSaveTimer = null;
let _noteSavedTimeout = null;

function getHolmNotes() {
  try {
    const raw = localStorage.getItem(HOLM_NOTES_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch (e) { return {}; }
}

function saveHolmNotes(notes) {
  try {
    localStorage.setItem(HOLM_NOTES_KEY, JSON.stringify(notes));
  } catch (e) { console.error('Failed to save notes:', e); }
}

function getNotesCount() {
  const notes = getHolmNotes();
  return Object.keys(notes).filter(k => notes[k] && notes[k].trim()).length;
}

function renderNotes() {
  const textarea = document.getElementById('notesTextarea');
  const countEl = document.getElementById('notesCount');
  const clearBtn = document.getElementById('notesClearBtn');
  const savedIndicator = document.getElementById('notesSavedIndicator');
  if (!textarea || !countEl) return;

  // Update count
  const count = getNotesCount();
  countEl.textContent = count > 0 ? '(' + count + ' doc' + (count !== 1 ? 's' : '') + ')' : '';

  // Load note for current doc
  if (currentDoc) {
    const notes = getHolmNotes();
    textarea.value = notes[currentDoc.docId] || '';
    textarea.disabled = false;
    clearBtn.style.display = textarea.value.trim() ? 'inline-block' : 'none';
  } else {
    textarea.value = '';
    textarea.disabled = true;
    clearBtn.style.display = 'none';
  }

  // Hide saved indicator
  savedIndicator.classList.remove('visible');

  // Remove old listener and attach new one
  textarea.removeEventListener('input', _handleNoteInput);
  textarea.addEventListener('input', _handleNoteInput);
}

function _handleNoteInput() {
  if (!currentDoc) return;
  const textarea = document.getElementById('notesTextarea');
  const clearBtn = document.getElementById('notesClearBtn');
  if (!textarea) return;

  clearBtn.style.display = textarea.value.trim() ? 'inline-block' : 'none';

  // Debounce save (500ms)
  if (_noteSaveTimer) clearTimeout(_noteSaveTimer);
  _noteSaveTimer = setTimeout(function() {
    _saveCurrentNote(textarea.value);
  }, 500);
}

function _saveCurrentNote(text) {
  if (!currentDoc) return;
  const notes = getHolmNotes();
  if (text && text.trim()) {
    notes[currentDoc.docId] = text;
  } else {
    delete notes[currentDoc.docId];
  }
  saveHolmNotes(notes);

  // Update count display
  const countEl = document.getElementById('notesCount');
  if (countEl) {
    const count = getNotesCount();
    countEl.textContent = count > 0 ? '(' + count + ' doc' + (count !== 1 ? 's' : '') + ')' : '';
  }

  // Show "Saved" indicator briefly
  _showSavedIndicator();

  // Update sidebar note icons
  _updateSidebarNoteIcons();
}

function _showSavedIndicator() {
  const el = document.getElementById('notesSavedIndicator');
  if (!el) return;
  el.classList.add('visible');
  if (_noteSavedTimeout) clearTimeout(_noteSavedTimeout);
  _noteSavedTimeout = setTimeout(function() {
    el.classList.remove('visible');
  }, 1500);
}

function clearCurrentNote() {
  if (!currentDoc) return;
  const notes = getHolmNotes();
  delete notes[currentDoc.docId];
  saveHolmNotes(notes);

  const textarea = document.getElementById('notesTextarea');
  if (textarea) textarea.value = '';

  const clearBtn = document.getElementById('notesClearBtn');
  if (clearBtn) clearBtn.style.display = 'none';

  // Update count
  const countEl = document.getElementById('notesCount');
  if (countEl) {
    const count = getNotesCount();
    countEl.textContent = count > 0 ? '(' + count + ' doc' + (count !== 1 ? 's' : '') + ')' : '';
  }

  _showSavedIndicator();
  _updateSidebarNoteIcons();
}

function _updateSidebarNoteIcons() {
  const notes = getHolmNotes();
  document.querySelectorAll('.sidebar-item[data-id]').forEach(function(item) {
    const docId = item.getAttribute('data-id');
    let icon = item.querySelector('.note-icon');
    if (notes[docId] && notes[docId].trim()) {
      if (!icon) {
        icon = document.createElement('span');
        icon.className = 'note-icon';
        icon.title = 'Has personal note';
        icon.innerHTML = '&#9998;';
        item.appendChild(icon);
      }
    } else {
      if (icon) icon.remove();
    }
  });
}

// ─── TABLE OF CONTENTS ──────────────────────────────────────────────────────
function slugify(text) {
  return text.toLowerCase().replace(/[^\w\s-]/g, '').trim().replace(/[\s_]+/g, '-').replace(/-+/g, '-');
}

function renderTOC() {
  const tocList = document.getElementById('tocList');
  if (!currentDoc || !currentDoc.content) {
    tocList.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No headings</span>';
    return;
  }
  const headings = [];
  const regex = /<h([23])[^>]*>(.*?)<\/h\1>/gi;
  let match;
  while ((match = regex.exec(currentDoc.content)) !== null) {
    const level = match[1];
    const rawText = match[2].replace(/<[^>]+>/g, '').trim();
    const id = slugify(rawText);
    headings.push({ level, text: rawText, id });
  }
  if (headings.length === 0) {
    tocList.innerHTML = '<span style="color:var(--text-muted);font-size:12px">No headings</span>';
    return;
  }
  const docBody = document.getElementById('docBody');
  if (docBody) {
    const domHeadings = docBody.querySelectorAll('h2, h3');
    let tocIndex = 0;
    domHeadings.forEach(el => { if (tocIndex < headings.length) { el.id = headings[tocIndex].id; tocIndex++; } });
  }
  tocList.innerHTML = headings.map(h =>
    `<span class="toc-item toc-h${h.level}" onclick="scrollToHeading('${h.id}')">${escHtml(h.text)}</span>`
  ).join('');
}

function scrollToHeading(id) {
  const target = document.getElementById(id);
  const mainContent = document.getElementById('mainContent');
  if (target && mainContent) {
    const offset = target.offsetTop - mainContent.offsetTop;
    mainContent.scrollTo({ top: offset - 16, behavior: 'smooth' });
  }
}

// ─── LOCAL GRAPH ────────────────────────────────────────────────────────────
function renderLocalGraph() {
  const container = document.getElementById('localGraphContainer');
  const tooltip = document.getElementById('localGraphTooltip');
  const oldCanvas = container.querySelector('canvas');
  const canvas = document.createElement('canvas');
  canvas.id = 'localGraphCanvas';
  if (oldCanvas) container.replaceChild(canvas, oldCanvas);
  else container.appendChild(canvas);

  const W = container.clientWidth || 240;
  const H = container.clientHeight || 200;
  const DPR = window.devicePixelRatio || 1;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  const ctx = canvas.getContext('2d');
  ctx.scale(DPR, DPR);

  if (!currentDoc) return;

  const dependsOn = Array.isArray(currentDoc.dependsOn) ? currentDoc.dependsOn : [];
  const dependedBy = Array.isArray(currentDoc.dependedBy) ? currentDoc.dependedBy : [];
  const neighborIds = [...new Set([...dependsOn, ...dependedBy])];

  const nodes = [
    { id: currentDoc.docId, isCenter: true, domain: currentDoc.domain, x: W/2, y: H/2, vx: 0, vy: 0, fx: 0, fy: 0 },
    ...neighborIds.map((id, i) => {
      const doc = docsById[id];
      const angle = (2 * Math.PI * i) / Math.max(neighborIds.length, 1);
      const r = Math.min(W, H) * 0.30;
      return { id, isCenter: false, domain: doc ? doc.domain : null, x: W/2 + r * Math.cos(angle), y: H/2 + r * Math.sin(angle), vx: 0, vy: 0, fx: 0, fy: 0 };
    })
  ];
  const nodeIndex = {};
  nodes.forEach((n, i) => nodeIndex[n.id] = i);

  const edgeSet = new Set();
  const edges = [];
  function addEdge(a, b) {
    const key = [a, b].sort().join('||');
    if (!edgeSet.has(key) && nodeIndex[a] !== undefined && nodeIndex[b] !== undefined) {
      edgeSet.add(key);
      edges.push({ a, b });
    }
  }
  dependsOn.forEach(id => addEdge(currentDoc.docId, id));
  dependedBy.forEach(id => addEdge(id, currentDoc.docId));

  // Force simulation
  const cx = W/2, cy = H/2;
  for (let iter = 0; iter < 120; iter++) {
    nodes.forEach(n => { n.fx = 0; n.fy = 0; });
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const a = nodes[i], b = nodes[j];
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist2 = dx * dx + dy * dy + 0.01;
        const dist = Math.sqrt(dist2);
        const force = 2800 / dist2;
        const ffx = (dx / dist) * force, ffy = (dy / dist) * force;
        a.fx -= ffx; a.fy -= ffy; b.fx += ffx; b.fy += ffy;
      }
    }
    edges.forEach(({ a: aId, b: bId }) => {
      const a = nodes[nodeIndex[aId]], b = nodes[nodeIndex[bId]];
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.sqrt(dx * dx + dy * dy) + 0.01;
      const delta = (dist - 72) * 0.12;
      const ffx = (dx / dist) * delta, ffy = (dy / dist) * delta;
      a.fx += ffx; a.fy += ffy; b.fx -= ffx; b.fy -= ffy;
    });
    nodes.forEach(n => { n.fx += (cx - n.x) * 0.06; n.fy += (cy - n.y) * 0.06; });
    nodes.forEach(n => {
      if (n.isCenter) { n.x = cx; n.y = cy; return; }
      n.vx = (n.vx + n.fx) * 0.82; n.vy = (n.vy + n.fy) * 0.82;
      n.x += n.vx; n.y += n.vy;
      n.x = Math.max(20, Math.min(W - 20, n.x));
      n.y = Math.max(20, Math.min(H - 20, n.y));
    });
  }

  function nodeColor(domain) { return DOMAIN_COLORS[domain] || '#6c7086'; }

  // Draw
  ctx.fillStyle = '#181825'; ctx.fillRect(0, 0, W, H);
  edges.forEach(({ a: aId, b: bId }) => {
    const a = nodes[nodeIndex[aId]], b = nodes[nodeIndex[bId]];
    ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y);
    ctx.strokeStyle = '#45475a'; ctx.lineWidth = 1.2; ctx.stroke();
  });
  nodes.forEach(n => {
    const radius = n.isCenter ? 9 : 6;
    const color = nodeColor(n.domain);
    if (n.isCenter) { ctx.beginPath(); ctx.arc(n.x, n.y, radius + 4, 0, 2 * Math.PI); ctx.fillStyle = color + '33'; ctx.fill(); }
    ctx.beginPath(); ctx.arc(n.x, n.y, radius, 0, 2 * Math.PI); ctx.fillStyle = color; ctx.fill();
    if (n.isCenter) { ctx.strokeStyle = '#cdd6f4'; ctx.lineWidth = 1.5; ctx.stroke(); }
  });

  // Interaction
  function hitTest(px, py) {
    for (let i = nodes.length - 1; i >= 0; i--) {
      const n = nodes[i], r = n.isCenter ? 9 : 6;
      const dx = px - n.x, dy = py - n.y;
      if (dx * dx + dy * dy <= (r + 3) * (r + 3)) return n;
    }
    return null;
  }
  function eventPos(e) { const rect = canvas.getBoundingClientRect(); return { px: e.clientX - rect.left, py: e.clientY - rect.top }; }

  canvas.addEventListener('mousemove', function(e) {
    const { px, py } = eventPos(e);
    const hit = hitTest(px, py);
    if (hit) {
      this.style.cursor = hit.isCenter ? 'default' : 'pointer';
      tooltip.style.display = 'block';
      tooltip.textContent = hit.id;
      tooltip.style.left = (e.clientX + 12) + 'px';
      tooltip.style.top = (e.clientY - 6) + 'px';
    } else {
      this.style.cursor = 'default';
      tooltip.style.display = 'none';
    }
  });
  canvas.addEventListener('mouseleave', function() { tooltip.style.display = 'none'; });
  canvas.addEventListener('click', function(e) {
    const { px, py } = eventPos(e);
    const hit = hitTest(px, py);
    if (hit && !hit.isCenter) openDoc(hit.id);
  });
}

// ─── SEARCH ─────────────────────────────────────────────────────────────────
let searchTimeout;
document.getElementById('searchInput').addEventListener('input', function() {
  clearTimeout(searchTimeout);
  const q = this.value.trim();
  if (q.length < 2) { document.getElementById('searchResults').classList.remove('active'); return; }
  searchTimeout = setTimeout(() => doSearch(q), 250);
});
document.getElementById('searchInput').addEventListener('focus', function() {
  if (this.value.trim().length >= 2) document.getElementById('searchResults').classList.add('active');
});
document.addEventListener('click', function(e) {
  if (!e.target.closest('.search-box')) document.getElementById('searchResults').classList.remove('active');
});

async function doSearch(q) {
  try {
    const res = await fetch(`/api/search?q=${encodeURIComponent(q)}`);
    const results = await res.json();
    const container = document.getElementById('searchResults');
    if (results.length === 0) {
      container.innerHTML = '<div class="search-result-item" style="color:var(--text-muted)">No results found</div>';
      showToast('No results found', 'warning');
    } else {
      container.innerHTML = results.map(r => `
        <div class="search-result-item" onclick="openDoc('${r.docId}');document.getElementById('searchResults').classList.remove('active');">
          <div class="sr-id">${r.docId}</div>
          <div class="sr-title">${escHtml(r.title)}</div>
          ${r.snippet ? `<div class="sr-snippet">${r.snippet}</div>` : ''}
        </div>
      `).join('');
    }
    container.classList.add('active');
  } catch (err) {
    console.error('Search failed:', err);
    showToast('Search failed: ' + err.message, 'error');
  }
}

// ─── QUICK OPEN ─────────────────────────────────────────────────────────────
let quickOpenSelectedIndex = -1;
let quickOpenFilteredDocs = [];

function openQuickOpen() {
  const overlay = document.getElementById('quickOpen');
  const input = document.getElementById('quickOpenInput');
  overlay.style.display = 'flex';
  input.value = '';
  quickOpenSelectedIndex = -1;
  renderQuickOpenResults('');
  requestAnimationFrame(() => input.focus());
}

function closeQuickOpen() {
  document.getElementById('quickOpen').style.display = 'none';
  quickOpenSelectedIndex = -1;
  quickOpenFilteredDocs = [];
}

function renderQuickOpenResults(query) {
  const term = query.trim().toLowerCase();
  const container = document.getElementById('quickOpenResults');
  quickOpenFilteredDocs = term.length === 0
    ? allDocs.slice(0, 15)
    : allDocs.filter(d => d.docId.toLowerCase().includes(term) || d.title.toLowerCase().includes(term)).slice(0, 15);

  if (quickOpenFilteredDocs.length === 0) {
    container.innerHTML = `<div class="quick-open-empty">No documents match "${escHtml(query)}"</div>`;
    return;
  }
  container.innerHTML = quickOpenFilteredDocs.map((doc, i) => `
    <div class="quick-open-item${i === quickOpenSelectedIndex ? ' selected' : ''}" data-index="${i}"
         onmousedown="quickOpenSelectDoc('${escHtml(doc.docId)}')">
      <span class="qo-id">${escHtml(doc.docId)}</span>
      <span class="qo-title">${escHtml(doc.title)}</span>
    </div>
  `).join('');
}

function quickOpenSetSelected(index) {
  const items = document.querySelectorAll('.quick-open-item');
  items.forEach(el => el.classList.remove('selected'));
  if (index >= 0 && index < items.length) {
    items[index].classList.add('selected');
    items[index].scrollIntoView({ block: 'nearest' });
  }
  quickOpenSelectedIndex = index;
}

function quickOpenSelectDoc(docId) { closeQuickOpen(); openDoc(docId); }

document.getElementById('quickOpenInput').addEventListener('input', function() {
  quickOpenSelectedIndex = -1;
  renderQuickOpenResults(this.value);
});
document.getElementById('quickOpenInput').addEventListener('keydown', function(e) {
  const total = quickOpenFilteredDocs.length;
  if (e.key === 'ArrowDown') { e.preventDefault(); quickOpenSetSelected(quickOpenSelectedIndex < total - 1 ? quickOpenSelectedIndex + 1 : 0); }
  else if (e.key === 'ArrowUp') { e.preventDefault(); quickOpenSetSelected(quickOpenSelectedIndex > 0 ? quickOpenSelectedIndex - 1 : total - 1); }
  else if (e.key === 'Enter') { e.preventDefault(); const idx = quickOpenSelectedIndex >= 0 ? quickOpenSelectedIndex : 0; const doc = quickOpenFilteredDocs[idx]; if (doc) quickOpenSelectDoc(doc.docId); }
  else if (e.key === 'Escape') { closeQuickOpen(); }
});
document.getElementById('quickOpen').addEventListener('mousedown', function(e) { if (e.target === this) closeQuickOpen(); });

// ─── TOGGLE FUNCTIONS ───────────────────────────────────────────────────────
function toggleSidebar() {
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('sidebarOverlay');
  sidebar.classList.toggle('open');
  overlay.classList.toggle('active');
}

function toggleBacklinks() {
  backlinksPanelOpen = !backlinksPanelOpen;
  document.getElementById('backlinksPanel').classList.toggle('active', backlinksPanelOpen);
  document.getElementById('backlinkToggle').classList.toggle('active', backlinksPanelOpen);
}

// ─── FULLSCREEN / FOCUS MODE ────────────────────────────────────────────────
let fullscreenMode = false;
let _backlinksPanelWasOpen = false;

function toggleFullscreen() {
  fullscreenMode = !fullscreenMode;
  document.body.classList.toggle('fullscreen-mode', fullscreenMode);

  if (fullscreenMode) {
    // Remember backlinks state before hiding
    _backlinksPanelWasOpen = backlinksPanelOpen;
  } else {
    // Restore backlinks panel if it was open before entering fullscreen
    if (_backlinksPanelWasOpen && !backlinksPanelOpen) {
      backlinksPanelOpen = true;
      document.getElementById('backlinksPanel').classList.add('active');
      document.getElementById('backlinkToggle').classList.add('active');
    }
  }
}

// ─── SHORTCUTS MODAL ────────────────────────────────────────────────────────
function showShortcutsModal() { document.getElementById('shortcutsModal').classList.add('active'); }
function hideShortcutsModal() { document.getElementById('shortcutsModal').classList.remove('active'); }
function closeShortcutsModal(event) { if (event.target === document.getElementById('shortcutsModal')) hideShortcutsModal(); }

// ─── CODE BLOCK COPY BUTTONS ────────────────────────────────────────────────
function addCopyButtons() {
  const docBody = document.getElementById('docBody');
  if (!docBody) return;
  docBody.querySelectorAll('pre').forEach(pre => {
    if (pre.querySelector('.code-copy-btn')) return;
    const btn = document.createElement('button');
    btn.className = 'code-copy-btn';
    btn.textContent = 'Copy';
    btn.addEventListener('click', function() {
      const code = pre.querySelector('code');
      const text = code ? code.textContent : pre.textContent;
      navigator.clipboard.writeText(text).then(() => {
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        showToast('Copied to clipboard', 'success');
        setTimeout(() => {
          btn.textContent = 'Copy';
          btn.classList.remove('copied');
        }, 1500);
      });
    });
    pre.appendChild(btn);
  });
}


// ─── SYNTAX HIGHLIGHTING FOR CODE BLOCKS ────────────────────────────────────
function highlightCodeBlocks() {
  const docBody = document.getElementById('docBody');
  if (!docBody) return;
  docBody.querySelectorAll('pre > code').forEach(codeEl => {
    if (codeEl.dataset.synHighlighted) return;
    codeEl.dataset.synHighlighted = '1';
    const raw = codeEl.innerHTML;
    const rules = [
      // Block comments: /* ... */
      { re: /(\/\*[\s\S]*?\*\/)/g, cls: 'syn-comment' },
      // Line comments: // ...
      { re: /(\/\/[^\n]*)/g, cls: 'syn-comment' },
      // Template literals
      { re: /(`(?:[^`\\]|\\.)*`)/g, cls: 'syn-string' },
      // Double-quoted strings
      { re: /("(?:[^"\\]|\\.)*")/g, cls: 'syn-string' },
      // Single-quoted strings
      { re: /('(?:[^'\\]|\\.)*')/g, cls: 'syn-string' },
      // HTML tags: <tagname ...> and </tagname>
      { re: /(&lt;\/?)([\w-]+)([\s\S]*?)(&gt;)/g, cls: null, handler: function(m) {
        return '<span class="syn-tag">' + m[1] + m[2] + '</span>' +
               m[3].replace(/([\w-]+)(=)/g, '<span class="syn-attr">$1</span>$2') +
               '<span class="syn-tag">' + m[4] + '</span>';
      }},
      // Keywords (whole word)
      { re: /\b(function|const|let|var|return|if|else|for|while|class|import|export|async|await|try|catch|throw|new|this|true|false|null|undefined)\b/g, cls: 'syn-keyword' },
      // Numbers (integers, floats, hex, binary, octal)
      { re: /\b(0[xXbBoO][\da-fA-F_]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/g, cls: 'syn-number' }
    ];
    // Gather all matches with their positions
    const allMatches = [];
    for (let ri = 0; ri < rules.length; ri++) {
      const rule = rules[ri];
      const re = new RegExp(rule.re.source, rule.re.flags);
      let m;
      while ((m = re.exec(raw)) !== null) {
        allMatches.push({ index: m.index, length: m[0].length, match: m, rule: rule });
      }
    }
    // Sort by position; if same position, longer match wins
    allMatches.sort((a, b) => a.index - b.index || b.length - a.length);
    let result = '';
    let pos = 0;
    for (let i = 0; i < allMatches.length; i++) {
      const tok = allMatches[i];
      if (tok.index < pos) continue; // skip overlapping
      result += raw.slice(pos, tok.index);
      if (tok.rule.handler) {
        result += tok.rule.handler(tok.match);
      } else {
        result += '<span class="' + tok.rule.cls + '">' + tok.match[0] + '</span>';
      }
      pos = tok.index + tok.length;
    }
    result += raw.slice(pos);
    codeEl.innerHTML = result;
  });
}
// ─── WORD COUNT & READING TIME ──────────────────────────────────────────────
function updateReadingInfo() {
  const el = document.getElementById('docReadingInfo');
  if (!currentDoc || !currentDoc.content) { el.textContent = ''; return; }
  const plainText = currentDoc.content.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
  const words = plainText ? plainText.split(/\s+/).length : 0;
  const minutes = Math.max(1, Math.ceil(words / 200));
  const formatted = words.toLocaleString();
  el.textContent = `${formatted} words \u00b7 ${minutes} min read`;
}

// ─── FAVORITES / BOOKMARKS ──────────────────────────────────────────────────
const FAVORITES_KEY = 'holm-favorites';

function getFavorites() {
  try {
    const raw = localStorage.getItem(FAVORITES_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) {
    return [];
  }
}

function saveFavorites(favs) {
  localStorage.setItem(FAVORITES_KEY, JSON.stringify(favs));
}

function isFavorite(docId) {
  return getFavorites().includes(docId);
}

function toggleFavorite() {
  if (!currentDoc) return;
  const favs = getFavorites();
  const idx = favs.indexOf(currentDoc.docId);
  const wasAdded = idx === -1;
  if (wasAdded) {
    favs.push(currentDoc.docId);
  } else {
    favs.splice(idx, 1);
  }
  saveFavorites(favs);
  updateFavoriteBtn();
  renderSidebar();
  showToast(wasAdded ? 'Added to favorites' : 'Removed from favorites', 'info');
  // Re-highlight the active sidebar item after re-render
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) activeItem.classList.add('active');
  }
}

function removeFavorite(docId, event) {
  if (event) { event.stopPropagation(); }
  const favs = getFavorites();
  const idx = favs.indexOf(docId);
  if (idx !== -1) {
    favs.splice(idx, 1);
    saveFavorites(favs);
    updateFavoriteBtn();
    renderSidebar();
    if (currentDoc) {
      const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
      if (activeItem) activeItem.classList.add('active');
    }
  }
}

function updateFavoriteBtn() {
  const btn = document.getElementById('favoriteBtn');
  if (!btn || !currentDoc) return;
  const faved = isFavorite(currentDoc.docId);
  btn.classList.toggle('favorited', faved);
  btn.innerHTML = faved ? '&#9733;' : '&#9734;';
  btn.title = faved ? 'Remove from favorites' : 'Add to favorites';
}

function buildFavoritesHtml() {
  const favs = getFavorites();
  if (favs.length === 0) {
    return '<div class="sidebar-section favorites-section">' +
      '<div class="sidebar-section-header" onclick="toggleSection(this)">' +
      '<span class="chevron">\u25BC</span>\u2605 Favorites <span style="margin-left:auto;font-size:10px;opacity:0.6">0</span>' +
      '</div>' +
      '<div class="sidebar-items-wrap" style="height:auto"><div class="sidebar-items">' +
      '<div class="sidebar-items-empty">No favorites yet</div>' +
      '</div></div></div>';
  }
  let items = '';
  for (const docId of favs) {
    const doc = docsById[docId];
    const title = doc ? doc.title : docId;
    items += '<div class="sidebar-item" data-id="' + docId + '" onclick="openDoc(\'' + docId + '\')">' +
      '<span class="doc-id">' + docId + '</span>' +
      '<span class="doc-title">' + escHtml(title) + '</span>' +
      '<span class="fav-remove" onclick="removeFavorite(\'' + docId + '\', event)" title="Remove favorite">\u2715</span>' +
      '</div>';
  }
  return '<div class="sidebar-section favorites-section">' +
    '<div class="sidebar-section-header" onclick="toggleSection(this)">' +
    '<span class="chevron">\u25BC</span>\u2605 Favorites <span style="margin-left:auto;font-size:10px;opacity:0.6">' + favs.length + '</span>' +
    '</div>' +
    '<div class="sidebar-items-wrap" style="height:auto"><div class="sidebar-items">' + items + '</div></div></div>';
}

// ─── DOC BADGES ──────────────────────────────────────────────────────────
function getStatusBadgeClass(status) {
  if (!status) return 'badge-status-other';
  const s = status.toLowerCase().trim();
  if (s === 'ratified') return 'badge-status-ratified';
  if (s === 'draft') return 'badge-status-draft';
  if (s === 'active') return 'badge-status-active';
  if (s === 'deprecated') return 'badge-status-deprecated';
  return 'badge-status-other';
}

function renderDocBadges() {
  const el = document.getElementById('docBadges');
  if (!currentDoc) { el.innerHTML = ''; return; }
  let html = '';
  if (currentDoc.version) {
    html += '<span class="doc-badge-pill badge-version">v' + escHtml(currentDoc.version) + '</span>';
  }
  if (currentDoc.status) {
    const cls = getStatusBadgeClass(currentDoc.status);
    html += '<span class="doc-badge-pill ' + cls + '">' + escHtml(currentDoc.status) + '</span>';
  }
  if (currentDoc.date) {
    html += '<span class="doc-badge-pill badge-date">' + escHtml(currentDoc.date) + '</span>';
  }
  el.innerHTML = html;
}

// ─── UTILITY ────────────────────────────────────────────────────────────────
function escHtml(s) {
  if (!s) return '';
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function navigateDoc(direction) {
  if (!allDocs.length) return;
  if (!currentDoc) { openDoc(direction === 'next' ? allDocs[0].docId : allDocs[allDocs.length - 1].docId); return; }
  const idx = allDocs.findIndex(d => d.docId === currentDoc.docId);
  if (idx === -1) return;
  const target = direction === 'prev' ? idx - 1 : idx + 1;
  if (target < 0 || target >= allDocs.length) return;
  openDoc(allDocs[target].docId);
}

function navBack() {
  if (navHistoryPos <= 0) return;
  navHistoryPos--;
  navIsTraversing = true;
  openDoc(navHistory[navHistoryPos], true).then(() => {
    navIsTraversing = false;
    updateNavButtons();
  });
}

function navForward() {
  if (navHistoryPos >= navHistory.length - 1) return;
  navHistoryPos++;
  navIsTraversing = true;
  openDoc(navHistory[navHistoryPos], true).then(() => {
    navIsTraversing = false;
    updateNavButtons();
  });
}

function updateNavButtons() {
  const backBtn = document.getElementById('btnNavBack');
  const fwdBtn = document.getElementById('btnNavForward');
  if (backBtn) backBtn.disabled = navHistoryPos <= 0;
  if (fwdBtn) fwdBtn.disabled = navHistoryPos >= navHistory.length - 1;
}

// ─── KEYBOARD NAVIGATION ───────────────────────────────────────────────────
function isTypingTarget() {
  const el = document.activeElement;
  return el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || el.isContentEditable);
}

document.addEventListener('keydown', function(e) {
  const mod = (navigator.platform.toUpperCase().includes('MAC') ? e.metaKey : e.ctrlKey);

  if (mod && e.key === 'k') { e.preventDefault(); const o = document.getElementById('quickOpen'); if (o.style.display === 'none') openQuickOpen(); else closeQuickOpen(); return; }
  if (mod && e.key === 'e') { e.preventDefault(); if (currentDoc) setViewMode(viewMode === 'edit' ? 'preview' : 'edit'); return; }
  if (mod && e.key === 's') { e.preventDefault(); if (currentDoc && viewMode === 'edit') saveDoc(); return; }
  if (mod && e.key === 'g') { e.preventDefault(); window.open('/graph.html', '_blank'); return; }
  if (mod && e.key === 'b') { e.preventDefault(); toggleBacklinks(); return; }
  if (mod && e.shiftKey && (e.key === 'f' || e.key === 'F')) { e.preventDefault(); toggleFullscreen(); return; }
  if (mod && e.key === '\\') { e.preventDefault(); toggleSidebar(); return; }
  if (mod && e.key === '[') { e.preventDefault(); window.history.back(); return; }
  if (mod && e.key === ']') { e.preventDefault(); window.history.forward(); return; }
  if (e.altKey && e.key === 'ArrowUp') { e.preventDefault(); navigateDoc('prev'); return; }
  if (e.altKey && e.key === 'ArrowDown') { e.preventDefault(); navigateDoc('next'); return; }
  if (e.altKey && e.key === 'ArrowLeft') { e.preventDefault(); navBack(); return; }
  if (e.altKey && e.key === 'ArrowRight') { e.preventDefault(); navForward(); return; }

  if (e.key === 'Escape') {
    const so = document.getElementById('statsOverlay');
    if (so && so.classList.contains('active')) { closeStatsDashboard(); return; }
    const sm = document.getElementById('shortcutsModal');
    if (sm && sm.classList.contains('active')) { hideShortcutsModal(); return; }
    const qo = document.getElementById('quickOpen');
    if (qo && qo.style.display !== 'none') { closeQuickOpen(); return; }
    if (fullscreenMode) { toggleFullscreen(); return; }
    if (currentDoc && viewMode === 'edit') { setViewMode('preview'); return; }
  }

  if (e.key === '?' && !mod && !e.altKey && !isTypingTarget()) { e.preventDefault(); showShortcutsModal(); }
});


// ─── RECENTLY VIEWED ────────────────────────────────────────────────────────
const RECENT_KEY = 'holm-recent';
const RECENT_MAX = 10;

function getRecentDocs() {
  try {
    return JSON.parse(localStorage.getItem(RECENT_KEY)) || [];
  } catch { return []; }
}

function addToRecent(docId, title) {
  let recent = getRecentDocs();
  // Remove existing entry for this docId (dedup)
  recent = recent.filter(r => r.id !== docId);
  // Add to front
  recent.unshift({ id: docId, title: title });
  // Cap at max
  if (recent.length > RECENT_MAX) recent = recent.slice(0, RECENT_MAX);
  localStorage.setItem(RECENT_KEY, JSON.stringify(recent));
}

function clearRecentHistory() {
  localStorage.removeItem(RECENT_KEY);
  renderSidebar();
  // Re-highlight active doc
  if (currentDoc) {
    const activeItem = document.querySelector(`.sidebar-item[data-id="${currentDoc.docId}"]`);
    if (activeItem) { activeItem.classList.add('active'); }
  }
}

function toggleRecentSection(el) {
  el.closest('.recent-section').classList.toggle('collapsed');
}

function renderRecentSection() {
  const recent = getRecentDocs();
  if (recent.length === 0) return '';
  let items = '';
  for (const r of recent) {
    const safeId = escHtml(r.id);
    const safeTitle = escHtml(r.title);
    items += `<div class="sidebar-item" data-id="${safeId}" onclick="openDoc('${safeId}')">
      <span class="doc-id">${safeId}</span>
      <span class="doc-title">${safeTitle}</span>
    </div>`;
  }
  return `<div class="recent-section">
    <div class="recent-section-header" onclick="toggleRecentSection(this)">
      <span class="chevron">&#9660;</span>Recent
      <button class="recent-clear-btn" onclick="event.stopPropagation(); clearRecentHistory();" title="Clear history">clear</button>
    </div>
    <div class="recent-items">${items}</div>
  </div>`;
}

// ─── DOC LINK PREVIEW TOOLTIPS ──────────────────────────────────────────
const docContentCache = {};
let tooltipTimer = null;
let tooltipActiveLink = null;

function stripHtmlToPlainText(html) {
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  return (tmp.textContent || tmp.innerText || '').replace(/\s+/g, ' ').trim();
}

function positionTooltipEl(el, mouseX, mouseY) {
  const tw = 320, th = el.offsetHeight || 180, pad = 12;
  let left = mouseX + pad, top = mouseY + pad;
  if (left + tw > window.innerWidth - pad) left = mouseX - tw - pad;
  if (left < pad) left = pad;
  if (top + th > window.innerHeight - pad) top = mouseY - th - pad;
  if (top < pad) top = pad;
  el.style.left = left + 'px';
  el.style.top = top + 'px';
}

async function getDocContentForTooltip(docId) {
  if (docContentCache[docId]) return docContentCache[docId];
  if (currentDoc && currentDoc.docId === docId && currentDoc.content) {
    docContentCache[docId] = currentDoc;
    return currentDoc;
  }
  const basicInfo = docsById[docId];
  if (!basicInfo) return null;
  try {
    const res = await fetch('/api/docs/' + docId);
    if (!res.ok) return basicInfo;
    const fullDoc = await res.json();
    docContentCache[docId] = fullDoc;
    return fullDoc;
  } catch (err) {
    return basicInfo;
  }
}

function showDocLinkTooltip(docId, mx, my) {
  const tip = document.getElementById('docLinkTooltip');
  getDocContentForTooltip(docId).then(function(doc) {
    if (!doc || tooltipActiveLink === null) return;
    document.getElementById('tooltipDocId').textContent = doc.docId;
    document.getElementById('tooltipTitle').textContent = doc.title || doc.docId;
    const dEl = document.getElementById('tooltipDomain');
    dEl.textContent = doc.domainName ? 'Domain ' + doc.domain + ': ' + doc.domainName : (doc.domain ? 'Domain ' + doc.domain : '');
    dEl.style.color = DOMAIN_COLORS[doc.domain] || 'var(--text-muted)';
    const exEl = document.getElementById('tooltipExcerpt');
    if (doc.content) {
      const plain = stripHtmlToPlainText(doc.content);
      exEl.textContent = plain.length > 150 ? plain.slice(0, 150) + '...' : plain;
      exEl.style.display = '';
    } else {
      exEl.textContent = '';
      exEl.style.display = 'none';
    }
    const tEl = document.getElementById('tooltipTags');
    if (doc.tags && doc.tags.length > 0) {
      tEl.innerHTML = doc.tags.map(function(t) { return '<span class="doc-link-tooltip-tag">#' + escHtml(t) + '</span>'; }).join('');
      tEl.style.display = '';
    } else {
      tEl.innerHTML = '';
      tEl.style.display = 'none';
    }
    positionTooltipEl(tip, mx, my);
    tip.classList.add('visible');
  });
}

function hideDocLinkTooltip() {
  clearTimeout(tooltipTimer);
  tooltipTimer = null;
  tooltipActiveLink = null;
  document.getElementById('docLinkTooltip').classList.remove('visible');
}

document.getElementById('docBody').addEventListener('mouseenter', function(e) {
  const link = e.target.closest('a.doc-link');
  if (!link) return;
  const docId = link.textContent.trim();
  if (currentDoc && currentDoc.docId === docId) return;
  if (!docsById[docId]) return;
  tooltipActiveLink = link;
  clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(function() {
    if (tooltipActiveLink === link) {
      const rect = link.getBoundingClientRect();
      showDocLinkTooltip(docId, rect.left + rect.width / 2, rect.bottom);
    }
  }, 300);
}, true);

document.getElementById('docBody').addEventListener('mouseleave', function(e) {
  const link = e.target.closest('a.doc-link');
  if (!link) return;
  hideDocLinkTooltip();
}, true);

document.getElementById('mainContent').addEventListener('scroll', function() {
  if (tooltipActiveLink) hideDocLinkTooltip();
}, { passive: true });

// ─── HASH ROUTING ───────────────────────────────────────────────────────────
window.addEventListener('hashchange', () => {
  const id = window.location.hash.slice(1).toUpperCase();
  if (id && docsById[id] && (!currentDoc || currentDoc.docId !== id)) openDoc(id);
});


// ─── SCROLL TO TOP ──────────────────────────────────────────────────────────
(function() {
  const mainContent = document.getElementById('mainContent');
  const scrollBtn = document.getElementById('scrollToTop');
  if (!mainContent || !scrollBtn) return;

  mainContent.addEventListener('scroll', function() {
    if (mainContent.scrollTop > 300) {
      scrollBtn.classList.add('visible');
    } else {
      scrollBtn.classList.remove('visible');
    }
  });

  scrollBtn.addEventListener('click', function() {
    mainContent.scrollTo({ top: 0, behavior: 'smooth' });
  });
})();

// ─── READING PROGRESS BAR ───────────────────────────────────────────────────
(function() {
  const mainContent = document.getElementById('mainContent');
  const progressBar = document.getElementById('readingProgressBar');
  if (\!mainContent || \!progressBar) return;

  function updateProgressBar() {
    const docViewer = document.getElementById('docViewer');
    const isDocOpen = docViewer && docViewer.classList.contains('active');
    const scrollHeight = mainContent.scrollHeight;
    const clientHeight = mainContent.clientHeight;
    const isScrollable = scrollHeight > clientHeight + 10;

    if (\!isDocOpen || \!isScrollable) {
      progressBar.classList.remove('visible');
      progressBar.style.width = '0%';
      return;
    }

    progressBar.classList.add('visible');
    const scrollTop = mainContent.scrollTop;
    const maxScroll = scrollHeight - clientHeight;
    const pct = Math.min(100, Math.max(0, (scrollTop / maxScroll) * 100));
    progressBar.style.width = pct + '%';
  }

  mainContent.addEventListener('scroll', updateProgressBar, { passive: true });

  // Observe class changes on docViewer to detect open/close
  const docViewer = document.getElementById('docViewer');
  if (docViewer) {
    const observer = new MutationObserver(updateProgressBar);
    observer.observe(docViewer, { attributes: true, attributeFilter: ['class'] });
  }

  // Also update on window resize (content may become scrollable/non-scrollable)
  window.addEventListener('resize', updateProgressBar, { passive: true });
})();

// ─── STATS DASHBOARD ────────────────────────────────────────────────────────
async function openStatsDashboard() {
  document.getElementById('statsOverlay').classList.add('active');
  await renderStatsDashboard();
}

function closeStatsDashboard() {
  document.getElementById('statsOverlay').classList.remove('active');
}

async function renderStatsDashboard() {
  const container = document.getElementById('statsDashboardContent');

  // Compute domain groups
  const domainMap = {};
  let totalEdges = 0;
  const connectionCounts = {};

  allDocs.forEach(doc => {
    const key = doc.domain || 'Other';
    const name = doc.domainName || key;
    if (!domainMap[key]) domainMap[key] = { name, count: 0 };
    domainMap[key].count++;

    const depOn = Array.isArray(doc.dependsOn) ? doc.dependsOn.length : 0;
    const depBy = Array.isArray(doc.dependedBy) ? doc.dependedBy.length : 0;
    totalEdges += depOn;
    connectionCounts[doc.docId] = {
      total: depOn + depBy,
      dependsOn: depOn,
      dependedBy: depBy,
      title: doc.title
    };
  });

  // Sort domains
  const domainKeys = Object.keys(domainMap).sort((a, b) => {
    const na = parseInt(a), nb = parseInt(b);
    if (!isNaN(na) && !isNaN(nb)) return na - nb;
    if (!isNaN(na)) return -1;
    if (!isNaN(nb)) return 1;
    return a.localeCompare(b);
  });

  const maxDomainCount = Math.max(...domainKeys.map(k => domainMap[k].count), 1);
  const domainCount = domainKeys.length;

  // Top 10 most connected docs
  const topConnected = Object.entries(connectionCounts)
    .sort((a, b) => b[1].total - a[1].total)
    .slice(0, 10);

  // Fetch tags from API
  let tagData = [];
  try {
    const tagRes = await fetch('/api/tags');
    if (tagRes.ok) {
      tagData = await tagRes.json();
    }
  } catch (e) {
    // Fallback: compute tags from allDocs
  }

  // If API didn't return tags, compute from allDocs
  if (!tagData || tagData.length === 0) {
    const tagCounts = {};
    allDocs.forEach(doc => {
      if (doc.tags && Array.isArray(doc.tags)) {
        doc.tags.forEach(t => {
          tagCounts[t] = (tagCounts[t] || 0) + 1;
        });
      }
    });
    tagData = Object.entries(tagCounts)
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count);
  }

  // If tagData is an object with tag->count, normalize
  if (tagData && !Array.isArray(tagData)) {
    tagData = Object.entries(tagData)
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count);
  }

  const topTags = (tagData || []).slice(0, 10);
  const maxTagCount = topTags.length > 0 ? Math.max(...topTags.map(t => t.count), 1) : 1;

  // Build HTML
  let html = '';

  // Summary cards
  html += '<div class="stats-summary">';
  html += '<div class="stats-card"><div class="stats-card-num">' + allDocs.length + '</div><div class="stats-card-label">Total Documents</div></div>';
  html += '<div class="stats-card"><div class="stats-card-num">' + domainCount + '</div><div class="stats-card-label">Domains</div></div>';
  html += '<div class="stats-card"><div class="stats-card-num">' + totalEdges + '</div><div class="stats-card-label">Dependency Edges</div></div>';
  html += '<div class="stats-card"><div class="stats-card-num">' + topTags.length + '</div><div class="stats-card-label">Unique Tags</div></div>';
  html += '</div>';

  // Domain bar chart
  html += '<div class="stats-section"><h3>Documents per Domain</h3><div class="stats-bar-chart">';
  domainKeys.forEach(key => {
    const d = domainMap[key];
    const pct = (d.count / maxDomainCount * 100).toFixed(1);
    const color = DOMAIN_COLORS[key] || '#6c7086';
    html += '<div class="stats-bar-row">';
    html += '<div class="stats-bar-label" title="D' + escHtml(key) + ' ' + escHtml(d.name) + '">D' + escHtml(key) + ' ' + escHtml(d.name) + '</div>';
    html += '<div class="stats-bar-track"><div class="stats-bar-fill" style="width:' + pct + '%;background:' + color + '"></div></div>';
    html += '<div class="stats-bar-value">' + d.count + '</div>';
    html += '</div>';
  });
  html += '</div></div>';

  // Two-column layout for tables
  html += '<div class="stats-columns">';

  // Top 10 most connected
  html += '<div class="stats-section"><h3>Top 10 Most Connected Documents</h3>';
  html += '<table class="stats-table"><thead><tr><th>Document</th><th style="text-align:right">Links</th></tr></thead><tbody>';
  topConnected.forEach(([docId, info]) => {
    html += '<tr>';
    html += '<td><span class="st-docid" onclick="closeStatsDashboard();openDoc(\'' + escHtml(docId) + '\')">' + escHtml(docId) + '</span><br><span style="font-size:11px;color:var(--text-muted)">' + escHtml(info.title) + '</span></td>';
    html += '<td class="st-num">' + info.total + '<br><span style="font-size:10px;color:var(--text-muted)">' + info.dependsOn + ' out / ' + info.dependedBy + ' in</span></td>';
    html += '</tr>';
  });
  html += '</tbody></table></div>';

  // Top 10 tags
  html += '<div class="stats-section"><h3>Top 10 Tags</h3>';
  if (topTags.length > 0) {
    html += '<div class="stats-bar-chart">';
    topTags.forEach(t => {
      const pct = (t.count / maxTagCount * 100).toFixed(1);
      html += '<div class="stats-bar-row">';
      html += '<div class="stats-bar-label" style="min-width:100px;max-width:140px;cursor:pointer" onclick="closeStatsDashboard();filterByTag(\'' + escHtml(t.tag) + '\')">#' + escHtml(t.tag) + '</div>';
      html += '<div class="stats-bar-track"><div class="stats-bar-fill" style="width:' + pct + '%;background:var(--mauve)"></div></div>';
      html += '<div class="stats-bar-value">' + t.count + '</div>';
      html += '</div>';
    });
    html += '</div>';
  } else {
    html += '<span style="color:var(--text-muted);font-size:13px">No tags available</span>';
  }
  html += '</div>';

  html += '</div>'; // close stats-columns

  container.innerHTML = html;
}

</script>

<!-- STATS DASHBOARD OVERLAY -->
<div class="stats-overlay" id="statsOverlay" onclick="if(event.target===this)closeStatsDashboard()">
  <div class="stats-dashboard">
    <div class="stats-dashboard-header">
      <h2>Domain Statistics Dashboard</h2>
      <button class="stats-close-btn" onclick="closeStatsDashboard()">&times;</button>
    </div>
    <div id="statsDashboardContent">
      <div class="loading"><div class="spinner"></div>Loading statistics...</div>
    </div>
  </div>
</div>


<!-- IMAGE ZOOM LIGHTBOX -->
<div class="lightbox-overlay" id="lightboxOverlay">
  <button class="lightbox-close" id="lightboxClose" title="Close (Esc)">&times;</button>
  <div class="lightbox-img-wrapper" id="lightboxWrapper">
    <img id="lightboxImg" src="" alt="">
  </div>
  <div class="lightbox-caption" id="lightboxCaption"></div>
  <div class="lightbox-zoom-hint" id="lightboxZoomHint">Scroll to zoom &middot; Drag to pan</div>
</div>
<script>
// ─── IMAGE ZOOM LIGHTBOX ─────────────────────────────────────────────────────
(function() {
  const overlay = document.getElementById('lightboxOverlay');
  const wrapper = document.getElementById('lightboxWrapper');
  const lbImg = document.getElementById('lightboxImg');
  const caption = document.getElementById('lightboxCaption');
  const closeBtn = document.getElementById('lightboxClose');
  const zoomHint = document.getElementById('lightboxZoomHint');

  let currentScale = 1;
  let panX = 0, panY = 0;
  let isDragging = false;
  let dragStartX = 0, dragStartY = 0;
  let panStartX = 0, panStartY = 0;
  const MIN_SCALE = 1;
  const MAX_SCALE = 5;

  function openLightbox(imgEl) {
    lbImg.src = imgEl.src;
    lbImg.alt = imgEl.alt || '';
    if (imgEl.alt) {
      caption.textContent = imgEl.alt;
      caption.style.display = '';
    } else {
      caption.textContent = '';
      caption.style.display = 'none';
    }
    resetZoom();
    zoomHint.classList.remove('faded');
    overlay.classList.add('active');
    document.body.style.overflow = 'hidden';
  }

  function closeLightbox() {
    overlay.classList.remove('active');
    document.body.style.overflow = '';
    setTimeout(function() {
      lbImg.src = '';
      resetZoom();
    }, 250);
  }

  function resetZoom() {
    currentScale = 1;
    panX = 0;
    panY = 0;
    applyTransform();
    wrapper.classList.remove('zoomed', 'dragging');
  }

  function applyTransform() {
    if (currentScale <= 1) {
      lbImg.style.transform = 'scale(1)';
      wrapper.classList.remove('zoomed');
    } else {
      lbImg.style.transform = 'scale(' + currentScale + ') translate(' + (panX / currentScale) + 'px, ' + (panY / currentScale) + 'px)';
      wrapper.classList.add('zoomed');
    }
  }

  // Click on images inside #docBody
  document.getElementById('docBody').addEventListener('click', function(e) {
    var target = e.target;
    if (target.tagName === 'IMG') {
      e.preventDefault();
      e.stopPropagation();
      openLightbox(target);
    }
  });

  // Close button
  closeBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    closeLightbox();
  });

  // Click on backdrop to close (but not on image or wrapper)
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) {
      closeLightbox();
    }
  });

  // Escape key
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && overlay.classList.contains('active')) {
      closeLightbox();
    }
  });

  // Scroll wheel zoom
  overlay.addEventListener('wheel', function(e) {
    if (!overlay.classList.contains('active')) return;
    e.preventDefault();
    zoomHint.classList.add('faded');

    var delta = e.deltaY > 0 ? -0.15 : 0.15;
    var newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, currentScale + delta));

    // If zooming back to 1, reset pan
    if (newScale <= MIN_SCALE) {
      currentScale = MIN_SCALE;
      panX = 0;
      panY = 0;
    } else {
      currentScale = newScale;
    }

    applyTransform();
  }, { passive: false });

  // Drag to pan when zoomed
  wrapper.addEventListener('mousedown', function(e) {
    if (currentScale <= 1) return;
    e.preventDefault();
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    panStartX = panX;
    panStartY = panY;
    wrapper.classList.add('dragging');
  });

  document.addEventListener('mousemove', function(e) {
    if (!isDragging) return;
    e.preventDefault();
    panX = panStartX + (e.clientX - dragStartX);
    panY = panStartY + (e.clientY - dragStartY);
    applyTransform();
  });

  document.addEventListener('mouseup', function() {
    if (isDragging) {
      isDragging = false;
      wrapper.classList.remove('dragging');
    }
  });

  // Touch support for pan
  var touchStartX = 0, touchStartY = 0;
  var touchPanStartX = 0, touchPanStartY = 0;
  var isTouchDragging = false;

  wrapper.addEventListener('touchstart', function(e) {
    if (currentScale <= 1 || e.touches.length !== 1) return;
    isTouchDragging = true;
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchPanStartX = panX;
    touchPanStartY = panY;
    wrapper.classList.add('dragging');
  }, { passive: true });

  wrapper.addEventListener('touchmove', function(e) {
    if (!isTouchDragging || e.touches.length !== 1) return;
    e.preventDefault();
    panX = touchPanStartX + (e.touches[0].clientX - touchStartX);
    panY = touchPanStartY + (e.touches[0].clientY - touchStartY);
    applyTransform();
  }, { passive: false });

  wrapper.addEventListener('touchend', function() {
    if (isTouchDragging) {
      isTouchDragging = false;
      wrapper.classList.remove('dragging');
    }
  });
})();

// ─── DOCUMENT OUTLINE MINIMAP ────────────────────────────────────────────────
(function() {
  var mainContent = document.getElementById('mainContent');
  var minimapContainer = document.getElementById('minimapContainer');
  var minimapCanvas = document.getElementById('minimapCanvas');
  var minimapViewport = document.getElementById('minimapViewport');
  if (!mainContent || !minimapContainer || !minimapCanvas || !minimapViewport) return;

  var ctx = minimapCanvas.getContext('2d');
  var minimapElements = [];
  var minimapVisible = false;
  var rafPending = false;

  var MM_COLORS = {
    h1: 'rgba(137, 180, 250, 0.7)',
    h2: 'rgba(137, 180, 250, 0.5)',
    h3: 'rgba(250, 179, 135, 0.5)',
    p: 'rgba(108, 112, 134, 0.35)',
    pre: 'rgba(166, 227, 161, 0.35)',
    blockquote: 'rgba(203, 166, 247, 0.3)',
    table: 'rgba(148, 226, 213, 0.3)',
    li: 'rgba(108, 112, 134, 0.25)'
  };

  var MM_WIDTHS = {
    h1: 28, h2: 22, h3: 16,
    p: 3, pre: 30, blockquote: 26, table: 30, li: 2
  };

  var MM_BAR_H = { h1: 3, h2: 2.5, h3: 2, p: 2, li: 2 };

  function scanStructure() {
    var docBody = document.getElementById('docBody');
    if (!docBody || docBody.style.display === 'none') return [];

    var elems = [];
    var scrollH = mainContent.scrollHeight;
    if (scrollH <= 0) return [];

    var nodes = docBody.querySelectorAll('h1, h2, h3, p, pre, blockquote, table, li');
    var mainRect = mainContent.getBoundingClientRect();
    var st = mainContent.scrollTop;

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var tag = node.tagName.toLowerCase();
      if (tag === 'p' && node.closest('blockquote')) continue;
      if (tag === 'li' && node.querySelector('p')) continue;

      var rect = node.getBoundingClientRect();
      var topInDoc = rect.top - mainRect.top + st;

      elems.push({
        tag: tag,
        top: topInDoc,
        height: rect.height,
        color: MM_COLORS[tag] || MM_COLORS.p,
        width: MM_WIDTHS[tag] || 3,
        barH: MM_BAR_H[tag] || 0
      });
    }
    return elems;
  }

  function shouldShow() {
    var dv = document.getElementById('docViewer');
    if (!dv || !dv.classList.contains('active')) return false;
    var db = document.getElementById('docBody');
    if (!db || db.style.display === 'none') return false;
    if (mainContent.scrollHeight <= mainContent.clientHeight + 50) return false;
    if (window.innerWidth <= 768) return false;
    return true;
  }

  function renderMinimap() {
    if (!shouldShow()) {
      if (minimapVisible) {
        minimapContainer.classList.remove('visible');
        minimapVisible = false;
      }
      return;
    }
    if (!minimapVisible) {
      minimapContainer.classList.add('visible');
      minimapVisible = true;
    }

    var dpr = window.devicePixelRatio || 1;
    var cw = minimapContainer.clientWidth;
    var ch = minimapContainer.clientHeight;
    if (cw === 0 || ch === 0) return;

    minimapCanvas.width = cw * dpr;
    minimapCanvas.height = ch * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, cw, ch);

    ctx.fillStyle = 'rgba(17, 17, 27, 0.4)';
    ctx.fillRect(0, 0, cw, ch);

    var scrollH = mainContent.scrollHeight;
    if (scrollH <= 0) return;
    var scale = ch / scrollH;

    for (var i = 0; i < minimapElements.length; i++) {
      var el = minimapElements[i];
      var y = el.top * scale;
      var w = el.width;
      var x = (cw - w) / 2;

      ctx.fillStyle = el.color;

      if (el.tag === 'p' || el.tag === 'li') {
        ctx.beginPath();
        ctx.arc(cw / 2, y + 1, el.tag === 'p' ? 1.2 : 0.8, 0, Math.PI * 2);
        ctx.fill();
      } else if (el.tag === 'pre' || el.tag === 'blockquote' || el.tag === 'table') {
        var h = Math.max(2, el.height * scale);
        var r = Math.min(1.5, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.fill();
      } else {
        ctx.fillRect(x, y, w, el.barH);
      }
    }
    updateVP();
  }

  function updateVP() {
    if (!minimapVisible) return;
    var scrollH = mainContent.scrollHeight;
    var clientH = mainContent.clientHeight;
    var ch = minimapContainer.clientHeight;
    if (scrollH <= 0 || ch <= 0) return;
    var scale = ch / scrollH;
    var top = mainContent.scrollTop * scale;
    var h = Math.max(8, clientH * scale);
    minimapViewport.style.top = top + 'px';
    minimapViewport.style.height = h + 'px';
  }

  minimapCanvas.addEventListener('click', function(e) {
    var rect = minimapCanvas.getBoundingClientRect();
    var clickY = e.clientY - rect.top;
    var ch = rect.height;
    var scrollH = mainContent.scrollHeight;
    var clientH = mainContent.clientHeight;
    if (ch <= 0 || scrollH <= 0) return;
    var ratio = clickY / ch;
    var target = (ratio * scrollH) - (clientH / 2);
    mainContent.scrollTo({ top: Math.max(0, target), behavior: 'smooth' });
  });

  var isDragging = false;
  minimapCanvas.addEventListener('mousedown', function(e) {
    isDragging = true;
    e.preventDefault();
  });
  document.addEventListener('mousemove', function(e) {
    if (!isDragging || !minimapVisible) return;
    var rect = minimapCanvas.getBoundingClientRect();
    var clickY = e.clientY - rect.top;
    var ch = rect.height;
    var scrollH = mainContent.scrollHeight;
    var clientH = mainContent.clientHeight;
    if (ch <= 0) return;
    var ratio = clickY / ch;
    var target = (ratio * scrollH) - (clientH / 2);
    mainContent.scrollTo({ top: Math.max(0, Math.min(target, scrollH - clientH)) });
  });
  document.addEventListener('mouseup', function() { isDragging = false; });

  mainContent.addEventListener('scroll', function() {
    if (!minimapVisible) return;
    if (!rafPending) {
      rafPending = true;
      requestAnimationFrame(function() {
        updateVP();
        rafPending = false;
      });
    }
  }, { passive: true });

  var resizeTimer = null;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(function() {
      minimapElements = scanStructure();
      renderMinimap();
    }, 200);
  });

  window.updateMinimap = function() {
    setTimeout(function() {
      minimapElements = scanStructure();
      renderMinimap();
    }, 120);
  };

  window.hideMinimap = function() {
    minimapContainer.classList.remove('visible');
    minimapVisible = false;
  };
})();
</script>


</body>
</html>
